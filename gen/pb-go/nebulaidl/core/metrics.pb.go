// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nebulaidl/core/metrics.proto

package core

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Span represents a duration trace of Nebula execution. The id field denotes a Nebula execution entity or an operation
// which uniquely identifies the Span. The spans attribute allows this Span to be further broken down into more
// precise definitions.
type Span struct {
	// start_time defines the instance this span began.
	StartTime *timestamp.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end_time defines the instance this span completed.
	EndTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Types that are valid to be assigned to Id:
	//	*Span_WorkflowId
	//	*Span_NodeId
	//	*Span_TaskId
	//	*Span_OperationId
	Id isSpan_Id `protobuf_oneof:"id"`
	// spans defines a collection of Spans that breakdown this execution.
	Spans                []*Span  `protobuf:"bytes,7,rep,name=spans,proto3" json:"spans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d47f114b82ac215, []int{0}
}

func (m *Span) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Span.Unmarshal(m, b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Span.Marshal(b, m, deterministic)
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return xxx_messageInfo_Span.Size(m)
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Span) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

type isSpan_Id interface {
	isSpan_Id()
}

type Span_WorkflowId struct {
	WorkflowId *WorkflowExecutionIdentifier `protobuf:"bytes,3,opt,name=workflow_id,json=workflowId,proto3,oneof"`
}

type Span_NodeId struct {
	NodeId *NodeExecutionIdentifier `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3,oneof"`
}

type Span_TaskId struct {
	TaskId *TaskExecutionIdentifier `protobuf:"bytes,5,opt,name=task_id,json=taskId,proto3,oneof"`
}

type Span_OperationId struct {
	OperationId string `protobuf:"bytes,6,opt,name=operation_id,json=operationId,proto3,oneof"`
}

func (*Span_WorkflowId) isSpan_Id() {}

func (*Span_NodeId) isSpan_Id() {}

func (*Span_TaskId) isSpan_Id() {}

func (*Span_OperationId) isSpan_Id() {}

func (m *Span) GetId() isSpan_Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Span) GetWorkflowId() *WorkflowExecutionIdentifier {
	if x, ok := m.GetId().(*Span_WorkflowId); ok {
		return x.WorkflowId
	}
	return nil
}

func (m *Span) GetNodeId() *NodeExecutionIdentifier {
	if x, ok := m.GetId().(*Span_NodeId); ok {
		return x.NodeId
	}
	return nil
}

func (m *Span) GetTaskId() *TaskExecutionIdentifier {
	if x, ok := m.GetId().(*Span_TaskId); ok {
		return x.TaskId
	}
	return nil
}

func (m *Span) GetOperationId() string {
	if x, ok := m.GetId().(*Span_OperationId); ok {
		return x.OperationId
	}
	return ""
}

func (m *Span) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Span) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Span_WorkflowId)(nil),
		(*Span_NodeId)(nil),
		(*Span_TaskId)(nil),
		(*Span_OperationId)(nil),
	}
}

func init() {
	proto.RegisterType((*Span)(nil), "nebulaidl.core.Span")
}

func init() { proto.RegisterFile("nebulaidl/core/metrics.proto", fileDescriptor_2d47f114b82ac215) }

var fileDescriptor_2d47f114b82ac215 = []byte{
	// 337 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xcf, 0x4b, 0xc3, 0x30,
	0x14, 0x80, 0xf7, 0x7b, 0x2e, 0x15, 0x0f, 0xc5, 0xc3, 0x18, 0xc2, 0x86, 0x1e, 0x1c, 0x8a, 0x09,
	0x4c, 0x3c, 0x28, 0x9e, 0x06, 0xc2, 0x7a, 0xd9, 0xa1, 0x0e, 0x04, 0x2f, 0x23, 0x6d, 0xde, 0x6a,
	0x58, 0x9b, 0x57, 0x9a, 0x94, 0xf9, 0x1f, 0xf9, 0x6f, 0x4a, 0x1a, 0x37, 0xd9, 0x98, 0x78, 0x4c,
	0xf3, 0x7d, 0x5f, 0x09, 0xef, 0x91, 0x0b, 0x05, 0x51, 0x99, 0x72, 0x29, 0x52, 0x16, 0x63, 0x01,
	0x2c, 0x03, 0x53, 0xc8, 0x58, 0xd3, 0xbc, 0x40, 0x83, 0xfe, 0xd9, 0xee, 0x96, 0xda, 0xdb, 0xc1,
	0xf0, 0x80, 0x96, 0x02, 0x94, 0x91, 0x2b, 0x09, 0x85, 0x13, 0x06, 0xc3, 0x04, 0x31, 0x49, 0x81,
	0x55, 0xa7, 0xa8, 0x5c, 0x31, 0x23, 0x33, 0xd0, 0x86, 0x67, 0xb9, 0x03, 0x2e, 0xbf, 0x9a, 0xa4,
	0xf5, 0x9a, 0x73, 0xe5, 0x3f, 0x12, 0xa2, 0x0d, 0x2f, 0xcc, 0xd2, 0x12, 0xfd, 0xfa, 0xa8, 0x3e,
	0xf6, 0x26, 0x03, 0xea, 0x74, 0xba, 0xd5, 0xe9, 0x62, 0xab, 0x87, 0xbd, 0x8a, 0xb6, 0x67, 0xff,
	0x81, 0x9c, 0x80, 0x12, 0x4e, 0x6c, 0xfc, 0x2b, 0x76, 0x41, 0x89, 0x4a, 0x9b, 0x13, 0x6f, 0x83,
	0xc5, 0x7a, 0x95, 0xe2, 0x66, 0x29, 0x45, 0xbf, 0x59, 0x99, 0xb7, 0x74, 0xff, 0x89, 0xf4, 0xed,
	0x07, 0x79, 0xf9, 0x84, 0xb8, 0x34, 0x12, 0x55, 0xb0, 0x7b, 0xe3, 0xac, 0x16, 0x92, 0x6d, 0x21,
	0x10, 0xfe, 0x94, 0x74, 0x15, 0x0a, 0xb0, 0xad, 0x56, 0xd5, 0xba, 0x3e, 0x6c, 0xcd, 0x51, 0xc0,
	0xf1, 0x4e, 0xc7, 0x9a, 0xae, 0x61, 0xb8, 0x5e, 0xdb, 0x46, 0xfb, 0x78, 0x63, 0xc1, 0xf5, 0xfa,
	0x8f, 0x86, 0x35, 0x03, 0xe1, 0x5f, 0x91, 0x53, 0xcc, 0xa1, 0xe0, 0x16, 0xb0, 0xa1, 0xce, 0xa8,
	0x3e, 0xee, 0xcd, 0x6a, 0xa1, 0xb7, 0xfb, 0x1a, 0x08, 0xff, 0x86, 0xb4, 0x75, 0xce, 0x95, 0xee,
	0x77, 0x47, 0xcd, 0xb1, 0x37, 0x39, 0x3f, 0xfc, 0x8d, 0x9d, 0x49, 0xe8, 0x90, 0x69, 0x8b, 0x34,
	0xa4, 0x98, 0x3e, 0xbf, 0x3f, 0x25, 0xd2, 0x7c, 0x94, 0x11, 0x8d, 0x31, 0x63, 0x0e, 0x8f, 0x53,
	0x2c, 0x85, 0x66, 0xbf, 0x5b, 0x90, 0x80, 0x62, 0x79, 0x74, 0x97, 0x20, 0xdb, 0xdf, 0x8c, 0xa8,
	0x53, 0x4d, 0xe2, 0xfe, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xfd, 0x61, 0xc7, 0x5f, 0x60, 0x02, 0x00,
	0x00,
}
