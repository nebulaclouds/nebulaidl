// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nebulaidl/plugins/array_job.proto

package plugins

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Describes a job that can process independent pieces of data concurrently. Multiple copies of the runnable component
// will be executed concurrently.
type ArrayJob struct {
	// Defines the maximum number of instances to bring up concurrently at any given point. Note that this is an
	// optimistic restriction and that, due to network partitioning or other failures, the actual number of currently
	// running instances might be more. This has to be a positive number if assigned. Default value is size.
	Parallelism int64 `protobuf:"varint,1,opt,name=parallelism,proto3" json:"parallelism,omitempty"`
	// Defines the number of instances to launch at most. This number should match the size of the input if the job
	// requires processing of all input data. This has to be a positive number.
	// In the case this is not defined, the back-end will determine the size at run-time by reading the inputs.
	Size int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// Types that are valid to be assigned to SuccessCriteria:
	//	*ArrayJob_MinSuccesses
	//	*ArrayJob_MinSuccessRatio
	SuccessCriteria      isArrayJob_SuccessCriteria `protobuf_oneof:"success_criteria"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ArrayJob) Reset()         { *m = ArrayJob{} }
func (m *ArrayJob) String() string { return proto.CompactTextString(m) }
func (*ArrayJob) ProtoMessage()    {}
func (*ArrayJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_37f09b158623ae16, []int{0}
}

func (m *ArrayJob) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ArrayJob.Unmarshal(m, b)
}
func (m *ArrayJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ArrayJob.Marshal(b, m, deterministic)
}
func (m *ArrayJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArrayJob.Merge(m, src)
}
func (m *ArrayJob) XXX_Size() int {
	return xxx_messageInfo_ArrayJob.Size(m)
}
func (m *ArrayJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ArrayJob.DiscardUnknown(m)
}

var xxx_messageInfo_ArrayJob proto.InternalMessageInfo

func (m *ArrayJob) GetParallelism() int64 {
	if m != nil {
		return m.Parallelism
	}
	return 0
}

func (m *ArrayJob) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type isArrayJob_SuccessCriteria interface {
	isArrayJob_SuccessCriteria()
}

type ArrayJob_MinSuccesses struct {
	MinSuccesses int64 `protobuf:"varint,3,opt,name=min_successes,json=minSuccesses,proto3,oneof"`
}

type ArrayJob_MinSuccessRatio struct {
	MinSuccessRatio float32 `protobuf:"fixed32,4,opt,name=min_success_ratio,json=minSuccessRatio,proto3,oneof"`
}

func (*ArrayJob_MinSuccesses) isArrayJob_SuccessCriteria() {}

func (*ArrayJob_MinSuccessRatio) isArrayJob_SuccessCriteria() {}

func (m *ArrayJob) GetSuccessCriteria() isArrayJob_SuccessCriteria {
	if m != nil {
		return m.SuccessCriteria
	}
	return nil
}

func (m *ArrayJob) GetMinSuccesses() int64 {
	if x, ok := m.GetSuccessCriteria().(*ArrayJob_MinSuccesses); ok {
		return x.MinSuccesses
	}
	return 0
}

func (m *ArrayJob) GetMinSuccessRatio() float32 {
	if x, ok := m.GetSuccessCriteria().(*ArrayJob_MinSuccessRatio); ok {
		return x.MinSuccessRatio
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ArrayJob) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ArrayJob_MinSuccesses)(nil),
		(*ArrayJob_MinSuccessRatio)(nil),
	}
}

func init() {
	proto.RegisterType((*ArrayJob)(nil), "nebulaidl.plugins.ArrayJob")
}

func init() { proto.RegisterFile("nebulaidl/plugins/array_job.proto", fileDescriptor_37f09b158623ae16) }

var fileDescriptor_37f09b158623ae16 = []byte{
	// 226 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0xd0, 0x31, 0x4f, 0xc3, 0x30,
	0x10, 0x05, 0xe0, 0xa6, 0xad, 0x10, 0x32, 0x20, 0xa8, 0xa7, 0x8c, 0x01, 0x09, 0xa9, 0x03, 0xc4,
	0x03, 0x33, 0x42, 0x74, 0xaa, 0x18, 0xc3, 0xc6, 0x12, 0xd9, 0xae, 0x65, 0x0e, 0xd9, 0x3e, 0xcb,
	0x67, 0x0f, 0xf0, 0x8f, 0xf8, 0x97, 0x28, 0x81, 0xd2, 0x48, 0xdd, 0x4e, 0xf7, 0xbe, 0xe5, 0x3d,
	0x76, 0x1d, 0x8c, 0x2a, 0x4e, 0xc2, 0xce, 0x89, 0xe8, 0x8a, 0x85, 0x40, 0x42, 0xa6, 0x24, 0x3f,
	0xfb, 0x0f, 0x54, 0x6d, 0x4c, 0x98, 0x91, 0xaf, 0xfe, 0x49, 0xfb, 0x47, 0x6e, 0xbe, 0x2b, 0x76,
	0xfa, 0x3c, 0xb0, 0x17, 0x54, 0xbc, 0x61, 0x67, 0x51, 0x26, 0xe9, 0x9c, 0x71, 0x40, 0xbe, 0xae,
	0x9a, 0x6a, 0xbd, 0xe8, 0xa6, 0x2f, 0xce, 0xd9, 0x92, 0xe0, 0xcb, 0xd4, 0xf3, 0x31, 0x1a, 0x6f,
	0x7e, 0xcb, 0x2e, 0x3c, 0x84, 0x9e, 0x8a, 0xd6, 0x86, 0xc8, 0x50, 0xbd, 0x18, 0xc2, 0xed, 0xac,
	0x3b, 0xf7, 0x10, 0x5e, 0xf7, 0x5f, 0x7e, 0xc7, 0x56, 0x13, 0xd6, 0x27, 0x99, 0x01, 0xeb, 0x65,
	0x53, 0xad, 0xe7, 0xdb, 0x59, 0x77, 0x79, 0xa0, 0xdd, 0x10, 0x6c, 0x38, 0xbb, 0xda, 0x4b, 0x9d,
	0x20, 0x9b, 0x04, 0x72, 0xf3, 0xf4, 0xf6, 0x68, 0x21, 0xbf, 0x17, 0xd5, 0x6a, 0xf4, 0xe2, 0xb7,
	0x8b, 0x76, 0x58, 0x76, 0x24, 0x0e, 0xdd, 0xad, 0x09, 0x22, 0xaa, 0x7b, 0x8b, 0xe2, 0x68, 0x0f,
	0x75, 0x32, 0xce, 0xf0, 0xf0, 0x13, 0x00, 0x00, 0xff, 0xff, 0x07, 0x99, 0x5a, 0xc2, 0x2b, 0x01,
	0x00, 0x00,
}
