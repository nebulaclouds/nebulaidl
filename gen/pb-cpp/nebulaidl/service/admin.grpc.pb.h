// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: nebulaidl/service/admin.proto
#ifndef GRPC_nebulaidl_2fservice_2fadmin_2eproto__INCLUDED
#define GRPC_nebulaidl_2fservice_2fadmin_2eproto__INCLUDED

#include "nebulaidl/service/admin.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class Channel;
class CompletionQueue;
class ServerCompletionQueue;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc_impl

namespace grpc {
class ServerContext;
}  // namespace grpc

namespace nebulaidl {
namespace service {

// The following defines an RPC service that is also served over HTTP via grpc-gateway.
// Standard response codes for both are defined here: https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/errors.go
class AdminService final {
 public:
  static constexpr char const* service_full_name() {
    return "nebulaidl.service.AdminService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create and upload a :ref:`ref_nebulaidl.admin.Task` definition
    virtual ::grpc::Status CreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::nebulaidl::admin::TaskCreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskCreateResponse>> AsyncCreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskCreateResponse>>(AsyncCreateTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskCreateResponse>> PrepareAsyncCreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskCreateResponse>>(PrepareAsyncCreateTaskRaw(context, request, cq));
    }
    // Fetch a :ref:`ref_nebulaidl.admin.Task` definition.
    virtual ::grpc::Status GetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::Task* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Task>> AsyncGetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Task>>(AsyncGetTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Task>> PrepareAsyncGetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Task>>(PrepareAsyncGetTaskRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of task objects.
    virtual ::grpc::Status ListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::nebulaidl::admin::NamedEntityIdentifierList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>> AsyncListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>>(AsyncListTaskIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>> PrepareAsyncListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>>(PrepareAsyncListTaskIdsRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.Task` definitions.
    virtual ::grpc::Status ListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::TaskList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskList>> AsyncListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskList>>(AsyncListTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskList>> PrepareAsyncListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskList>>(PrepareAsyncListTasksRaw(context, request, cq));
    }
    // Create and upload a :ref:`ref_nebulaidl.admin.Workflow` definition
    virtual ::grpc::Status CreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::nebulaidl::admin::WorkflowCreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowCreateResponse>> AsyncCreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowCreateResponse>>(AsyncCreateWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowCreateResponse>> PrepareAsyncCreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowCreateResponse>>(PrepareAsyncCreateWorkflowRaw(context, request, cq));
    }
    // Fetch a :ref:`ref_nebulaidl.admin.Workflow` definition.
    virtual ::grpc::Status GetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::Workflow* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Workflow>> AsyncGetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Workflow>>(AsyncGetWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Workflow>> PrepareAsyncGetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Workflow>>(PrepareAsyncGetWorkflowRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of workflow objects.
    virtual ::grpc::Status ListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::nebulaidl::admin::NamedEntityIdentifierList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>> AsyncListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>>(AsyncListWorkflowIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>> PrepareAsyncListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>>(PrepareAsyncListWorkflowIdsRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.Workflow` definitions.
    virtual ::grpc::Status ListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::WorkflowList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowList>> AsyncListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowList>>(AsyncListWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowList>> PrepareAsyncListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowList>>(PrepareAsyncListWorkflowsRaw(context, request, cq));
    }
    // Create and upload a :ref:`ref_nebulaidl.admin.LaunchPlan` definition
    virtual ::grpc::Status CreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanCreateResponse>> AsyncCreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanCreateResponse>>(AsyncCreateLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanCreateResponse>> PrepareAsyncCreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanCreateResponse>>(PrepareAsyncCreateLaunchPlanRaw(context, request, cq));
    }
    // Fetch a :ref:`ref_nebulaidl.admin.LaunchPlan` definition.
    virtual ::grpc::Status GetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::LaunchPlan* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>> AsyncGetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>>(AsyncGetLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>> PrepareAsyncGetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>>(PrepareAsyncGetLaunchPlanRaw(context, request, cq));
    }
    // Fetch the active version of a :ref:`ref_nebulaidl.admin.LaunchPlan`.
    virtual ::grpc::Status GetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::nebulaidl::admin::LaunchPlan* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>> AsyncGetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>>(AsyncGetActiveLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>> PrepareAsyncGetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>>(PrepareAsyncGetActiveLaunchPlanRaw(context, request, cq));
    }
    // List active versions of :ref:`ref_nebulaidl.admin.LaunchPlan`.
    virtual ::grpc::Status ListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::nebulaidl::admin::LaunchPlanList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>> AsyncListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>>(AsyncListActiveLaunchPlansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>> PrepareAsyncListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>>(PrepareAsyncListActiveLaunchPlansRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of launch plan objects.
    virtual ::grpc::Status ListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::nebulaidl::admin::NamedEntityIdentifierList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>> AsyncListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>>(AsyncListLaunchPlanIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>> PrepareAsyncListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>>(PrepareAsyncListLaunchPlanIdsRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.LaunchPlan` definitions.
    virtual ::grpc::Status ListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::LaunchPlanList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>> AsyncListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>>(AsyncListLaunchPlansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>> PrepareAsyncListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>>(PrepareAsyncListLaunchPlansRaw(context, request, cq));
    }
    // Updates the status of a registered :ref:`ref_nebulaidl.admin.LaunchPlan`.
    virtual ::grpc::Status UpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanUpdateResponse>> AsyncUpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanUpdateResponse>>(AsyncUpdateLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanUpdateResponse>> PrepareAsyncUpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanUpdateResponse>>(PrepareAsyncUpdateLaunchPlanRaw(context, request, cq));
    }
    // Triggers the creation of a :ref:`ref_nebulaidl.admin.Execution`
    virtual ::grpc::Status CreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::nebulaidl::admin::ExecutionCreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>> AsyncCreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>>(AsyncCreateExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>> PrepareAsyncCreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>>(PrepareAsyncCreateExecutionRaw(context, request, cq));
    }
    // Triggers the creation of an identical :ref:`ref_nebulaidl.admin.Execution`
    virtual ::grpc::Status RelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::nebulaidl::admin::ExecutionCreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>> AsyncRelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>>(AsyncRelaunchExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>> PrepareAsyncRelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>>(PrepareAsyncRelaunchExecutionRaw(context, request, cq));
    }
    // Recreates a previously-run workflow execution that will only start executing from the last known failure point.
    // In Recover mode, users cannot change any input parameters or update the version of the execution.
    // This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures,
    // downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again.
    // See :ref:`ref_nebulaidl.admin.ExecutionRecoverRequest` for more details.
    virtual ::grpc::Status RecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::nebulaidl::admin::ExecutionCreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>> AsyncRecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>>(AsyncRecoverExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>> PrepareAsyncRecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>>(PrepareAsyncRecoverExecutionRaw(context, request, cq));
    }
    // Fetches a :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status GetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::nebulaidl::admin::Execution* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Execution>> AsyncGetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Execution>>(AsyncGetExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Execution>> PrepareAsyncGetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Execution>>(PrepareAsyncGetExecutionRaw(context, request, cq));
    }
    // Update execution belonging to project domain :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status UpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::nebulaidl::admin::ExecutionUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionUpdateResponse>> AsyncUpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionUpdateResponse>>(AsyncUpdateExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionUpdateResponse>> PrepareAsyncUpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionUpdateResponse>>(PrepareAsyncUpdateExecutionRaw(context, request, cq));
    }
    // Fetches input and output data for a :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status GetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>> AsyncGetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>>(AsyncGetExecutionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>> PrepareAsyncGetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>>(PrepareAsyncGetExecutionDataRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status ListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::ExecutionList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionList>> AsyncListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionList>>(AsyncListExecutionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionList>> PrepareAsyncListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionList>>(PrepareAsyncListExecutionsRaw(context, request, cq));
    }
    // Terminates an in-progress :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status TerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::nebulaidl::admin::ExecutionTerminateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionTerminateResponse>> AsyncTerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionTerminateResponse>>(AsyncTerminateExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionTerminateResponse>> PrepareAsyncTerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionTerminateResponse>>(PrepareAsyncTerminateExecutionRaw(context, request, cq));
    }
    // Fetches a :ref:`ref_nebulaidl.admin.NodeExecution`.
    virtual ::grpc::Status GetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::nebulaidl::admin::NodeExecution* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecution>> AsyncGetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecution>>(AsyncGetNodeExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecution>> PrepareAsyncGetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecution>>(PrepareAsyncGetNodeExecutionRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.NodeExecution`.
    virtual ::grpc::Status ListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::nebulaidl::admin::NodeExecutionList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>> AsyncListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>>(AsyncListNodeExecutionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>> PrepareAsyncListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>>(PrepareAsyncListNodeExecutionsRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.NodeExecution` launched by the reference :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::nebulaidl::admin::NodeExecutionList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>> AsyncListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>>(AsyncListNodeExecutionsForTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>> PrepareAsyncListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>>(PrepareAsyncListNodeExecutionsForTaskRaw(context, request, cq));
    }
    // Fetches input and output data for a :ref:`ref_nebulaidl.admin.NodeExecution`.
    virtual ::grpc::Status GetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionGetDataResponse>> AsyncGetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionGetDataResponse>>(AsyncGetNodeExecutionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionGetDataResponse>> PrepareAsyncGetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionGetDataResponse>>(PrepareAsyncGetNodeExecutionDataRaw(context, request, cq));
    }
    // Registers a :ref:`ref_nebulaidl.admin.Project` with the Nebula deployment.
    virtual ::grpc::Status RegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::nebulaidl::admin::ProjectRegisterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectRegisterResponse>> AsyncRegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectRegisterResponse>>(AsyncRegisterProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectRegisterResponse>> PrepareAsyncRegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectRegisterResponse>>(PrepareAsyncRegisterProjectRaw(context, request, cq));
    }
    // Updates an existing :ref:`ref_nebulaidl.admin.Project`
    // nebulaidl.admin.Project should be passed but the domains property should be empty;
    // it will be ignored in the handler as domains cannot be updated via this API.
    virtual ::grpc::Status UpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::nebulaidl::admin::ProjectUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectUpdateResponse>> AsyncUpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectUpdateResponse>>(AsyncUpdateProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectUpdateResponse>> PrepareAsyncUpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectUpdateResponse>>(PrepareAsyncUpdateProjectRaw(context, request, cq));
    }
    // Fetches a list of :ref:`ref_nebulaidl.admin.Project`
    virtual ::grpc::Status ListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::nebulaidl::admin::Projects* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Projects>> AsyncListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Projects>>(AsyncListProjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Projects>> PrepareAsyncListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Projects>>(PrepareAsyncListProjectsRaw(context, request, cq));
    }
    // Indicates a :ref:`ref_nebulaidl.event.WorkflowExecutionEvent` has occurred.
    virtual ::grpc::Status CreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionEventResponse>> AsyncCreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionEventResponse>>(AsyncCreateWorkflowEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionEventResponse>> PrepareAsyncCreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionEventResponse>>(PrepareAsyncCreateWorkflowEventRaw(context, request, cq));
    }
    // Indicates a :ref:`ref_nebulaidl.event.NodeExecutionEvent` has occurred.
    virtual ::grpc::Status CreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::nebulaidl::admin::NodeExecutionEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionEventResponse>> AsyncCreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionEventResponse>>(AsyncCreateNodeEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionEventResponse>> PrepareAsyncCreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionEventResponse>>(PrepareAsyncCreateNodeEventRaw(context, request, cq));
    }
    // Indicates a :ref:`ref_nebulaidl.event.TaskExecutionEvent` has occurred.
    virtual ::grpc::Status CreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::nebulaidl::admin::TaskExecutionEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionEventResponse>> AsyncCreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionEventResponse>>(AsyncCreateTaskEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionEventResponse>> PrepareAsyncCreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionEventResponse>>(PrepareAsyncCreateTaskEventRaw(context, request, cq));
    }
    // Fetches a :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status GetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::nebulaidl::admin::TaskExecution* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecution>> AsyncGetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecution>>(AsyncGetTaskExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecution>> PrepareAsyncGetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecution>>(PrepareAsyncGetTaskExecutionRaw(context, request, cq));
    }
    // Fetches a list of :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status ListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::nebulaidl::admin::TaskExecutionList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionList>> AsyncListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionList>>(AsyncListTaskExecutionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionList>> PrepareAsyncListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionList>>(PrepareAsyncListTaskExecutionsRaw(context, request, cq));
    }
    // Fetches input and output data for a :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status GetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionGetDataResponse>> AsyncGetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionGetDataResponse>>(AsyncGetTaskExecutionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionGetDataResponse>> PrepareAsyncGetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionGetDataResponse>>(PrepareAsyncGetTaskExecutionDataRaw(context, request, cq));
    }
    // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>> AsyncUpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>>(AsyncUpdateProjectDomainAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>> PrepareAsyncUpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>>(PrepareAsyncUpdateProjectDomainAttributesRaw(context, request, cq));
    }
    // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status GetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>> AsyncGetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>>(AsyncGetProjectDomainAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>> PrepareAsyncGetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>>(PrepareAsyncGetProjectDomainAttributesRaw(context, request, cq));
    }
    // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>> AsyncDeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>>(AsyncDeleteProjectDomainAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>> PrepareAsyncDeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>>(PrepareAsyncDeleteProjectDomainAttributesRaw(context, request, cq));
    }
    // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` at the project level
    virtual ::grpc::Status UpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesUpdateResponse>> AsyncUpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesUpdateResponse>>(AsyncUpdateProjectAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesUpdateResponse>> PrepareAsyncUpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesUpdateResponse>>(PrepareAsyncUpdateProjectAttributesRaw(context, request, cq));
    }
    // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status GetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesGetResponse>> AsyncGetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesGetResponse>>(AsyncGetProjectAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesGetResponse>> PrepareAsyncGetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesGetResponse>>(PrepareAsyncGetProjectAttributesRaw(context, request, cq));
    }
    // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status DeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesDeleteResponse>> AsyncDeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesDeleteResponse>>(AsyncDeleteProjectAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesDeleteResponse>> PrepareAsyncDeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesDeleteResponse>>(PrepareAsyncDeleteProjectAttributesRaw(context, request, cq));
    }
    // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
    virtual ::grpc::Status UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>> AsyncUpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>>(AsyncUpdateWorkflowAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>> PrepareAsyncUpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>>(PrepareAsyncUpdateWorkflowAttributesRaw(context, request, cq));
    }
    // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
    virtual ::grpc::Status GetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesGetResponse>> AsyncGetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesGetResponse>>(AsyncGetWorkflowAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesGetResponse>> PrepareAsyncGetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesGetResponse>>(PrepareAsyncGetWorkflowAttributesRaw(context, request, cq));
    }
    // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
    virtual ::grpc::Status DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>> AsyncDeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>>(AsyncDeleteWorkflowAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>> PrepareAsyncDeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>>(PrepareAsyncDeleteWorkflowAttributesRaw(context, request, cq));
    }
    // Lists custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a specific resource type.
    virtual ::grpc::Status ListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ListMatchableAttributesResponse>> AsyncListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ListMatchableAttributesResponse>>(AsyncListMatchableAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ListMatchableAttributesResponse>> PrepareAsyncListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ListMatchableAttributesResponse>>(PrepareAsyncListMatchableAttributesRaw(context, request, cq));
    }
    // Returns a list of :ref:`ref_nebulaidl.admin.NamedEntity` objects.
    virtual ::grpc::Status ListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::nebulaidl::admin::NamedEntityList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityList>> AsyncListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityList>>(AsyncListNamedEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityList>> PrepareAsyncListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityList>>(PrepareAsyncListNamedEntitiesRaw(context, request, cq));
    }
    // Returns a :ref:`ref_nebulaidl.admin.NamedEntity` object.
    virtual ::grpc::Status GetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::nebulaidl::admin::NamedEntity* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntity>> AsyncGetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntity>>(AsyncGetNamedEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntity>> PrepareAsyncGetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntity>>(PrepareAsyncGetNamedEntityRaw(context, request, cq));
    }
    // Updates a :ref:`ref_nebulaidl.admin.NamedEntity` object.
    virtual ::grpc::Status UpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityUpdateResponse>> AsyncUpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityUpdateResponse>>(AsyncUpdateNamedEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityUpdateResponse>> PrepareAsyncUpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityUpdateResponse>>(PrepareAsyncUpdateNamedEntityRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::nebulaidl::admin::GetVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // Fetch a :ref:`ref_nebulaidl.admin.DescriptionEntity` object.
    virtual ::grpc::Status GetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::DescriptionEntity* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntity>> AsyncGetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntity>>(AsyncGetDescriptionEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntity>> PrepareAsyncGetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntity>>(PrepareAsyncGetDescriptionEntityRaw(context, request, cq));
    }
    // Fetch a list of :ref:`ref_nebulaidl.admin.DescriptionEntity` definitions.
    virtual ::grpc::Status ListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::nebulaidl::admin::DescriptionEntityList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntityList>> AsyncListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntityList>>(AsyncListDescriptionEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntityList>> PrepareAsyncListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntityList>>(PrepareAsyncListDescriptionEntitiesRaw(context, request, cq));
    }
    // Fetches runtime metrics for a :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status GetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>> AsyncGetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>>(AsyncGetExecutionMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>> PrepareAsyncGetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>>(PrepareAsyncGetExecutionMetricsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Create and upload a :ref:`ref_nebulaidl.admin.Task` definition
      virtual void CreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a :ref:`ref_nebulaidl.admin.Task` definition.
      virtual void GetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Task* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Task* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of task objects.
      virtual void ListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTaskIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListTaskIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.Task` definitions.
      virtual void ListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Create and upload a :ref:`ref_nebulaidl.admin.Workflow` definition
      virtual void CreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a :ref:`ref_nebulaidl.admin.Workflow` definition.
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Workflow* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Workflow* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of workflow objects.
      virtual void ListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListWorkflowIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListWorkflowIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.Workflow` definitions.
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Create and upload a :ref:`ref_nebulaidl.admin.LaunchPlan` definition
      virtual void CreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a :ref:`ref_nebulaidl.admin.LaunchPlan` definition.
      virtual void GetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch the active version of a :ref:`ref_nebulaidl.admin.LaunchPlan`.
      virtual void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // List active versions of :ref:`ref_nebulaidl.admin.LaunchPlan`.
      virtual void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of launch plan objects.
      virtual void ListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListLaunchPlanIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListLaunchPlanIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.LaunchPlan` definitions.
      virtual void ListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Updates the status of a registered :ref:`ref_nebulaidl.admin.LaunchPlan`.
      virtual void UpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Triggers the creation of a :ref:`ref_nebulaidl.admin.Execution`
      virtual void CreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Triggers the creation of an identical :ref:`ref_nebulaidl.admin.Execution`
      virtual void RelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RelaunchExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RelaunchExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Recreates a previously-run workflow execution that will only start executing from the last known failure point.
      // In Recover mode, users cannot change any input parameters or update the version of the execution.
      // This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures,
      // downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again.
      // See :ref:`ref_nebulaidl.admin.ExecutionRecoverRequest` for more details.
      virtual void RecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RecoverExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RecoverExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches a :ref:`ref_nebulaidl.admin.Execution`.
      virtual void GetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Execution* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Execution* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Update execution belonging to project domain :ref:`ref_nebulaidl.admin.Execution`.
      virtual void UpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches input and output data for a :ref:`ref_nebulaidl.admin.Execution`.
      virtual void GetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.Execution`.
      virtual void ListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Terminates an in-progress :ref:`ref_nebulaidl.admin.Execution`.
      virtual void TerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TerminateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void TerminateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches a :ref:`ref_nebulaidl.admin.NodeExecution`.
      virtual void GetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNodeExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecution* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetNodeExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.NodeExecution`.
      virtual void ListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListNodeExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListNodeExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.NodeExecution` launched by the reference :ref:`ref_nebulaidl.admin.TaskExecution`.
      virtual void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches input and output data for a :ref:`ref_nebulaidl.admin.NodeExecution`.
      virtual void GetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNodeExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetNodeExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Registers a :ref:`ref_nebulaidl.admin.Project` with the Nebula deployment.
      virtual void RegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectRegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RegisterProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Updates an existing :ref:`ref_nebulaidl.admin.Project`
      // nebulaidl.admin.Project should be passed but the domains property should be empty;
      // it will be ignored in the handler as domains cannot be updated via this API.
      virtual void UpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches a list of :ref:`ref_nebulaidl.admin.Project`
      virtual void ListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListProjects(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Projects* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListProjects(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Projects* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Indicates a :ref:`ref_nebulaidl.event.WorkflowExecutionEvent` has occurred.
      virtual void CreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateWorkflowEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateWorkflowEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Indicates a :ref:`ref_nebulaidl.event.NodeExecutionEvent` has occurred.
      virtual void CreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateNodeEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateNodeEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Indicates a :ref:`ref_nebulaidl.event.TaskExecutionEvent` has occurred.
      virtual void CreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateTaskEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateTaskEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches a :ref:`ref_nebulaidl.admin.TaskExecution`.
      virtual void GetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecution* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTaskExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches a list of :ref:`ref_nebulaidl.admin.TaskExecution`.
      virtual void ListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTaskExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListTaskExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches input and output data for a :ref:`ref_nebulaidl.admin.TaskExecution`.
      virtual void GetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTaskExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
      virtual void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
      virtual void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
      virtual void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` at the project level
      virtual void UpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
      virtual void GetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
      virtual void DeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
      virtual void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
      virtual void GetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
      virtual void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Lists custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a specific resource type.
      virtual void ListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMatchableAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListMatchableAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Returns a list of :ref:`ref_nebulaidl.admin.NamedEntity` objects.
      virtual void ListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListNamedEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListNamedEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Returns a :ref:`ref_nebulaidl.admin.NamedEntity` object.
      virtual void GetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntity* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Updates a :ref:`ref_nebulaidl.admin.NamedEntity` object.
      virtual void UpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a :ref:`ref_nebulaidl.admin.DescriptionEntity` object.
      virtual void GetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDescriptionEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntity* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetDescriptionEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetch a list of :ref:`ref_nebulaidl.admin.DescriptionEntity` definitions.
      virtual void ListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListDescriptionEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntityList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListDescriptionEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Fetches runtime metrics for a :ref:`ref_nebulaidl.admin.Execution`.
      virtual void GetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecutionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExecutionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskCreateResponse>* AsyncCreateTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskCreateResponse>* PrepareAsyncCreateTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Task>* AsyncGetTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Task>* PrepareAsyncGetTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>* AsyncListTaskIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>* PrepareAsyncListTaskIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskList>* AsyncListTasksRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskList>* PrepareAsyncListTasksRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowCreateResponse>* AsyncCreateWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowCreateResponse>* PrepareAsyncCreateWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Workflow>* AsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Workflow>* PrepareAsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>* AsyncListWorkflowIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>* PrepareAsyncListWorkflowIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowList>* AsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowList>* PrepareAsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanCreateResponse>* AsyncCreateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanCreateResponse>* PrepareAsyncCreateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>* AsyncGetLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>* PrepareAsyncGetLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>* AsyncGetActiveLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlan>* PrepareAsyncGetActiveLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>* AsyncListActiveLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>* PrepareAsyncListActiveLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>* AsyncListLaunchPlanIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityIdentifierList>* PrepareAsyncListLaunchPlanIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>* AsyncListLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanList>* PrepareAsyncListLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanUpdateResponse>* AsyncUpdateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::LaunchPlanUpdateResponse>* PrepareAsyncUpdateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>* AsyncCreateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>* PrepareAsyncCreateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>* AsyncRelaunchExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>* PrepareAsyncRelaunchExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>* AsyncRecoverExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionCreateResponse>* PrepareAsyncRecoverExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Execution>* AsyncGetExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Execution>* PrepareAsyncGetExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionUpdateResponse>* AsyncUpdateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionUpdateResponse>* PrepareAsyncUpdateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>* AsyncGetExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>* PrepareAsyncGetExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionList>* AsyncListExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionList>* PrepareAsyncListExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionTerminateResponse>* AsyncTerminateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ExecutionTerminateResponse>* PrepareAsyncTerminateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecution>* AsyncGetNodeExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecution>* PrepareAsyncGetNodeExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>* AsyncListNodeExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>* PrepareAsyncListNodeExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>* AsyncListNodeExecutionsForTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionList>* PrepareAsyncListNodeExecutionsForTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionGetDataResponse>* AsyncGetNodeExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionGetDataResponse>* PrepareAsyncGetNodeExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectRegisterResponse>* AsyncRegisterProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectRegisterResponse>* PrepareAsyncRegisterProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectUpdateResponse>* AsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectUpdateResponse>* PrepareAsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Projects>* AsyncListProjectsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::Projects>* PrepareAsyncListProjectsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionEventResponse>* AsyncCreateWorkflowEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionEventResponse>* PrepareAsyncCreateWorkflowEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionEventResponse>* AsyncCreateNodeEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NodeExecutionEventResponse>* PrepareAsyncCreateNodeEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionEventResponse>* AsyncCreateTaskEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionEventResponse>* PrepareAsyncCreateTaskEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecution>* AsyncGetTaskExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecution>* PrepareAsyncGetTaskExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionList>* AsyncListTaskExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionList>* PrepareAsyncListTaskExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionGetDataResponse>* AsyncGetTaskExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::TaskExecutionGetDataResponse>* PrepareAsyncGetTaskExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* AsyncUpdateProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* PrepareAsyncUpdateProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>* AsyncGetProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>* PrepareAsyncGetProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* AsyncDeleteProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* PrepareAsyncDeleteProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesUpdateResponse>* AsyncUpdateProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesUpdateResponse>* PrepareAsyncUpdateProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesGetResponse>* AsyncGetProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesGetResponse>* PrepareAsyncGetProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesDeleteResponse>* AsyncDeleteProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ProjectAttributesDeleteResponse>* PrepareAsyncDeleteProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>* AsyncUpdateWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>* PrepareAsyncUpdateWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesGetResponse>* AsyncGetWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesGetResponse>* PrepareAsyncGetWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>* AsyncDeleteWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>* PrepareAsyncDeleteWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ListMatchableAttributesResponse>* AsyncListMatchableAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::ListMatchableAttributesResponse>* PrepareAsyncListMatchableAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityList>* AsyncListNamedEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityList>* PrepareAsyncListNamedEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntity>* AsyncGetNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntity>* PrepareAsyncGetNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityUpdateResponse>* AsyncUpdateNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::NamedEntityUpdateResponse>* PrepareAsyncUpdateNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntity>* AsyncGetDescriptionEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntity>* PrepareAsyncGetDescriptionEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntityList>* AsyncListDescriptionEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::DescriptionEntityList>* PrepareAsyncListDescriptionEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* AsyncGetExecutionMetricsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* PrepareAsyncGetExecutionMetricsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::nebulaidl::admin::TaskCreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskCreateResponse>> AsyncCreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskCreateResponse>>(AsyncCreateTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskCreateResponse>> PrepareAsyncCreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskCreateResponse>>(PrepareAsyncCreateTaskRaw(context, request, cq));
    }
    ::grpc::Status GetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::Task* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Task>> AsyncGetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Task>>(AsyncGetTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Task>> PrepareAsyncGetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Task>>(PrepareAsyncGetTaskRaw(context, request, cq));
    }
    ::grpc::Status ListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>> AsyncListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>>(AsyncListTaskIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>> PrepareAsyncListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>>(PrepareAsyncListTaskIdsRaw(context, request, cq));
    }
    ::grpc::Status ListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::TaskList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskList>> AsyncListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskList>>(AsyncListTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskList>> PrepareAsyncListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskList>>(PrepareAsyncListTasksRaw(context, request, cq));
    }
    ::grpc::Status CreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::nebulaidl::admin::WorkflowCreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowCreateResponse>> AsyncCreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowCreateResponse>>(AsyncCreateWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowCreateResponse>> PrepareAsyncCreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowCreateResponse>>(PrepareAsyncCreateWorkflowRaw(context, request, cq));
    }
    ::grpc::Status GetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::Workflow* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Workflow>> AsyncGetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Workflow>>(AsyncGetWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Workflow>> PrepareAsyncGetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Workflow>>(PrepareAsyncGetWorkflowRaw(context, request, cq));
    }
    ::grpc::Status ListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>> AsyncListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>>(AsyncListWorkflowIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>> PrepareAsyncListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>>(PrepareAsyncListWorkflowIdsRaw(context, request, cq));
    }
    ::grpc::Status ListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::WorkflowList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowList>> AsyncListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowList>>(AsyncListWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowList>> PrepareAsyncListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowList>>(PrepareAsyncListWorkflowsRaw(context, request, cq));
    }
    ::grpc::Status CreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanCreateResponse>> AsyncCreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanCreateResponse>>(AsyncCreateLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanCreateResponse>> PrepareAsyncCreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanCreateResponse>>(PrepareAsyncCreateLaunchPlanRaw(context, request, cq));
    }
    ::grpc::Status GetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::LaunchPlan* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>> AsyncGetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>>(AsyncGetLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>> PrepareAsyncGetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>>(PrepareAsyncGetLaunchPlanRaw(context, request, cq));
    }
    ::grpc::Status GetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::nebulaidl::admin::LaunchPlan* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>> AsyncGetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>>(AsyncGetActiveLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>> PrepareAsyncGetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>>(PrepareAsyncGetActiveLaunchPlanRaw(context, request, cq));
    }
    ::grpc::Status ListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::nebulaidl::admin::LaunchPlanList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>> AsyncListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>>(AsyncListActiveLaunchPlansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>> PrepareAsyncListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>>(PrepareAsyncListActiveLaunchPlansRaw(context, request, cq));
    }
    ::grpc::Status ListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>> AsyncListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>>(AsyncListLaunchPlanIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>> PrepareAsyncListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>>(PrepareAsyncListLaunchPlanIdsRaw(context, request, cq));
    }
    ::grpc::Status ListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::LaunchPlanList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>> AsyncListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>>(AsyncListLaunchPlansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>> PrepareAsyncListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>>(PrepareAsyncListLaunchPlansRaw(context, request, cq));
    }
    ::grpc::Status UpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanUpdateResponse>> AsyncUpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanUpdateResponse>>(AsyncUpdateLaunchPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanUpdateResponse>> PrepareAsyncUpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanUpdateResponse>>(PrepareAsyncUpdateLaunchPlanRaw(context, request, cq));
    }
    ::grpc::Status CreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::nebulaidl::admin::ExecutionCreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>> AsyncCreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>>(AsyncCreateExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>> PrepareAsyncCreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>>(PrepareAsyncCreateExecutionRaw(context, request, cq));
    }
    ::grpc::Status RelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::nebulaidl::admin::ExecutionCreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>> AsyncRelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>>(AsyncRelaunchExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>> PrepareAsyncRelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>>(PrepareAsyncRelaunchExecutionRaw(context, request, cq));
    }
    ::grpc::Status RecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::nebulaidl::admin::ExecutionCreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>> AsyncRecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>>(AsyncRecoverExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>> PrepareAsyncRecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>>(PrepareAsyncRecoverExecutionRaw(context, request, cq));
    }
    ::grpc::Status GetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::nebulaidl::admin::Execution* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Execution>> AsyncGetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Execution>>(AsyncGetExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Execution>> PrepareAsyncGetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Execution>>(PrepareAsyncGetExecutionRaw(context, request, cq));
    }
    ::grpc::Status UpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionUpdateResponse>> AsyncUpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionUpdateResponse>>(AsyncUpdateExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionUpdateResponse>> PrepareAsyncUpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionUpdateResponse>>(PrepareAsyncUpdateExecutionRaw(context, request, cq));
    }
    ::grpc::Status GetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>> AsyncGetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>>(AsyncGetExecutionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>> PrepareAsyncGetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>>(PrepareAsyncGetExecutionDataRaw(context, request, cq));
    }
    ::grpc::Status ListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::nebulaidl::admin::ExecutionList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionList>> AsyncListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionList>>(AsyncListExecutionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionList>> PrepareAsyncListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionList>>(PrepareAsyncListExecutionsRaw(context, request, cq));
    }
    ::grpc::Status TerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionTerminateResponse>> AsyncTerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionTerminateResponse>>(AsyncTerminateExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionTerminateResponse>> PrepareAsyncTerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionTerminateResponse>>(PrepareAsyncTerminateExecutionRaw(context, request, cq));
    }
    ::grpc::Status GetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::nebulaidl::admin::NodeExecution* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecution>> AsyncGetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecution>>(AsyncGetNodeExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecution>> PrepareAsyncGetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecution>>(PrepareAsyncGetNodeExecutionRaw(context, request, cq));
    }
    ::grpc::Status ListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::nebulaidl::admin::NodeExecutionList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>> AsyncListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>>(AsyncListNodeExecutionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>> PrepareAsyncListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>>(PrepareAsyncListNodeExecutionsRaw(context, request, cq));
    }
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::nebulaidl::admin::NodeExecutionList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>> AsyncListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>>(AsyncListNodeExecutionsForTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>> PrepareAsyncListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>>(PrepareAsyncListNodeExecutionsForTaskRaw(context, request, cq));
    }
    ::grpc::Status GetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionGetDataResponse>> AsyncGetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionGetDataResponse>>(AsyncGetNodeExecutionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionGetDataResponse>> PrepareAsyncGetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionGetDataResponse>>(PrepareAsyncGetNodeExecutionDataRaw(context, request, cq));
    }
    ::grpc::Status RegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::nebulaidl::admin::ProjectRegisterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectRegisterResponse>> AsyncRegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectRegisterResponse>>(AsyncRegisterProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectRegisterResponse>> PrepareAsyncRegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectRegisterResponse>>(PrepareAsyncRegisterProjectRaw(context, request, cq));
    }
    ::grpc::Status UpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::nebulaidl::admin::ProjectUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectUpdateResponse>> AsyncUpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectUpdateResponse>>(AsyncUpdateProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectUpdateResponse>> PrepareAsyncUpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectUpdateResponse>>(PrepareAsyncUpdateProjectRaw(context, request, cq));
    }
    ::grpc::Status ListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::nebulaidl::admin::Projects* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Projects>> AsyncListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Projects>>(AsyncListProjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Projects>> PrepareAsyncListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Projects>>(PrepareAsyncListProjectsRaw(context, request, cq));
    }
    ::grpc::Status CreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionEventResponse>> AsyncCreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionEventResponse>>(AsyncCreateWorkflowEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionEventResponse>> PrepareAsyncCreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionEventResponse>>(PrepareAsyncCreateWorkflowEventRaw(context, request, cq));
    }
    ::grpc::Status CreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionEventResponse>> AsyncCreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionEventResponse>>(AsyncCreateNodeEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionEventResponse>> PrepareAsyncCreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionEventResponse>>(PrepareAsyncCreateNodeEventRaw(context, request, cq));
    }
    ::grpc::Status CreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionEventResponse>> AsyncCreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionEventResponse>>(AsyncCreateTaskEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionEventResponse>> PrepareAsyncCreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionEventResponse>>(PrepareAsyncCreateTaskEventRaw(context, request, cq));
    }
    ::grpc::Status GetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::nebulaidl::admin::TaskExecution* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecution>> AsyncGetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecution>>(AsyncGetTaskExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecution>> PrepareAsyncGetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecution>>(PrepareAsyncGetTaskExecutionRaw(context, request, cq));
    }
    ::grpc::Status ListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::nebulaidl::admin::TaskExecutionList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionList>> AsyncListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionList>>(AsyncListTaskExecutionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionList>> PrepareAsyncListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionList>>(PrepareAsyncListTaskExecutionsRaw(context, request, cq));
    }
    ::grpc::Status GetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionGetDataResponse>> AsyncGetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionGetDataResponse>>(AsyncGetTaskExecutionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionGetDataResponse>> PrepareAsyncGetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionGetDataResponse>>(PrepareAsyncGetTaskExecutionDataRaw(context, request, cq));
    }
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>> AsyncUpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>>(AsyncUpdateProjectDomainAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>> PrepareAsyncUpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>>(PrepareAsyncUpdateProjectDomainAttributesRaw(context, request, cq));
    }
    ::grpc::Status GetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>> AsyncGetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>>(AsyncGetProjectDomainAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>> PrepareAsyncGetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>>(PrepareAsyncGetProjectDomainAttributesRaw(context, request, cq));
    }
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>> AsyncDeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>>(AsyncDeleteProjectDomainAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>> PrepareAsyncDeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>>(PrepareAsyncDeleteProjectDomainAttributesRaw(context, request, cq));
    }
    ::grpc::Status UpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesUpdateResponse>> AsyncUpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesUpdateResponse>>(AsyncUpdateProjectAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesUpdateResponse>> PrepareAsyncUpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesUpdateResponse>>(PrepareAsyncUpdateProjectAttributesRaw(context, request, cq));
    }
    ::grpc::Status GetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesGetResponse>> AsyncGetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesGetResponse>>(AsyncGetProjectAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesGetResponse>> PrepareAsyncGetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesGetResponse>>(PrepareAsyncGetProjectAttributesRaw(context, request, cq));
    }
    ::grpc::Status DeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesDeleteResponse>> AsyncDeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesDeleteResponse>>(AsyncDeleteProjectAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesDeleteResponse>> PrepareAsyncDeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesDeleteResponse>>(PrepareAsyncDeleteProjectAttributesRaw(context, request, cq));
    }
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>> AsyncUpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>>(AsyncUpdateWorkflowAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>> PrepareAsyncUpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>>(PrepareAsyncUpdateWorkflowAttributesRaw(context, request, cq));
    }
    ::grpc::Status GetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesGetResponse>> AsyncGetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesGetResponse>>(AsyncGetWorkflowAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesGetResponse>> PrepareAsyncGetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesGetResponse>>(PrepareAsyncGetWorkflowAttributesRaw(context, request, cq));
    }
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>> AsyncDeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>>(AsyncDeleteWorkflowAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>> PrepareAsyncDeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>>(PrepareAsyncDeleteWorkflowAttributesRaw(context, request, cq));
    }
    ::grpc::Status ListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ListMatchableAttributesResponse>> AsyncListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ListMatchableAttributesResponse>>(AsyncListMatchableAttributesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ListMatchableAttributesResponse>> PrepareAsyncListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ListMatchableAttributesResponse>>(PrepareAsyncListMatchableAttributesRaw(context, request, cq));
    }
    ::grpc::Status ListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::nebulaidl::admin::NamedEntityList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityList>> AsyncListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityList>>(AsyncListNamedEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityList>> PrepareAsyncListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityList>>(PrepareAsyncListNamedEntitiesRaw(context, request, cq));
    }
    ::grpc::Status GetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::nebulaidl::admin::NamedEntity* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntity>> AsyncGetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntity>>(AsyncGetNamedEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntity>> PrepareAsyncGetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntity>>(PrepareAsyncGetNamedEntityRaw(context, request, cq));
    }
    ::grpc::Status UpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityUpdateResponse>> AsyncUpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityUpdateResponse>>(AsyncUpdateNamedEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityUpdateResponse>> PrepareAsyncUpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityUpdateResponse>>(PrepareAsyncUpdateNamedEntityRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::nebulaidl::admin::GetVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    ::grpc::Status GetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::nebulaidl::admin::DescriptionEntity* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntity>> AsyncGetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntity>>(AsyncGetDescriptionEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntity>> PrepareAsyncGetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntity>>(PrepareAsyncGetDescriptionEntityRaw(context, request, cq));
    }
    ::grpc::Status ListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::nebulaidl::admin::DescriptionEntityList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntityList>> AsyncListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntityList>>(AsyncListDescriptionEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntityList>> PrepareAsyncListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntityList>>(PrepareAsyncListDescriptionEntitiesRaw(context, request, cq));
    }
    ::grpc::Status GetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>> AsyncGetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>>(AsyncGetExecutionMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>> PrepareAsyncGetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>>(PrepareAsyncGetExecutionMetricsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateTask(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response, std::function<void(::grpc::Status)>) override;
      void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Task* response, std::function<void(::grpc::Status)>) override;
      void GetTask(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Task* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) override;
      void ListTaskIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) override;
      void ListTaskIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListTaskIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response, std::function<void(::grpc::Status)>) override;
      void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskList* response, std::function<void(::grpc::Status)>) override;
      void ListTasks(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response, std::function<void(::grpc::Status)>) override;
      void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Workflow* response, std::function<void(::grpc::Status)>) override;
      void GetWorkflow(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Workflow* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) override;
      void ListWorkflowIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) override;
      void ListWorkflowIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListWorkflowIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response, std::function<void(::grpc::Status)>) override;
      void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowList* response, std::function<void(::grpc::Status)>) override;
      void ListWorkflows(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) override;
      void GetLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) override;
      void GetLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) override;
      void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, std::function<void(::grpc::Status)>) override;
      void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetActiveLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) override;
      void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) override;
      void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListActiveLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) override;
      void ListLaunchPlanIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, std::function<void(::grpc::Status)>) override;
      void ListLaunchPlanIds(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListLaunchPlanIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) override;
      void ListLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, std::function<void(::grpc::Status)>) override;
      void ListLaunchPlans(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListLaunchPlans(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateLaunchPlan(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateLaunchPlan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void RelaunchExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void RelaunchExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RelaunchExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void RecoverExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, std::function<void(::grpc::Status)>) override;
      void RecoverExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RecoverExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response, std::function<void(::grpc::Status)>) override;
      void GetExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Execution* response, std::function<void(::grpc::Status)>) override;
      void GetExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Execution* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, std::function<void(::grpc::Status)>) override;
      void TerminateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, std::function<void(::grpc::Status)>) override;
      void TerminateExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TerminateExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response, std::function<void(::grpc::Status)>) override;
      void GetNodeExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecution* response, std::function<void(::grpc::Status)>) override;
      void GetNodeExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNodeExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListNodeExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListNodeExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListNodeExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListNodeExecutionsForTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNodeExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNodeExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNodeExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void RegisterProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectRegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void RegisterProject(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RegisterProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectRegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateProject(::grpc::ClientContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response, std::function<void(::grpc::Status)>) override;
      void ListProjects(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Projects* response, std::function<void(::grpc::Status)>) override;
      void ListProjects(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListProjects(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::Projects* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateWorkflowEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateWorkflowEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateWorkflowEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateNodeEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateNodeEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateNodeEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateTaskEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateTaskEvent(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateTaskEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response, std::function<void(::grpc::Status)>) override;
      void GetTaskExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecution* response, std::function<void(::grpc::Status)>) override;
      void GetTaskExecution(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTaskExecution(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecution* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListTaskExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionList* response, std::function<void(::grpc::Status)>) override;
      void ListTaskExecutions(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListTaskExecutions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTaskExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTaskExecutionData(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTaskExecutionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteProjectDomainAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteProjectAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteProjectAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteWorkflowAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMatchableAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMatchableAttributes(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListMatchableAttributes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response, std::function<void(::grpc::Status)>) override;
      void ListNamedEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityList* response, std::function<void(::grpc::Status)>) override;
      void ListNamedEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListNamedEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response, std::function<void(::grpc::Status)>) override;
      void GetNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntity* response, std::function<void(::grpc::Status)>) override;
      void GetNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateNamedEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateNamedEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response, std::function<void(::grpc::Status)>) override;
      void GetDescriptionEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntity* response, std::function<void(::grpc::Status)>) override;
      void GetDescriptionEntity(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDescriptionEntity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntity* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response, std::function<void(::grpc::Status)>) override;
      void ListDescriptionEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntityList* response, std::function<void(::grpc::Status)>) override;
      void ListDescriptionEntities(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListDescriptionEntities(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::DescriptionEntityList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetExecutionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetExecutionMetrics(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExecutionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskCreateResponse>* AsyncCreateTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskCreateResponse>* PrepareAsyncCreateTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Task>* AsyncGetTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Task>* PrepareAsyncGetTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>* AsyncListTaskIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>* PrepareAsyncListTaskIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskList>* AsyncListTasksRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskList>* PrepareAsyncListTasksRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowCreateResponse>* AsyncCreateWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowCreateResponse>* PrepareAsyncCreateWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Workflow>* AsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Workflow>* PrepareAsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>* AsyncListWorkflowIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>* PrepareAsyncListWorkflowIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowList>* AsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowList>* PrepareAsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanCreateResponse>* AsyncCreateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanCreateResponse>* PrepareAsyncCreateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>* AsyncGetLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>* PrepareAsyncGetLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>* AsyncGetActiveLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlan>* PrepareAsyncGetActiveLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>* AsyncListActiveLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>* PrepareAsyncListActiveLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>* AsyncListLaunchPlanIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityIdentifierList>* PrepareAsyncListLaunchPlanIdsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>* AsyncListLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanList>* PrepareAsyncListLaunchPlansRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanUpdateResponse>* AsyncUpdateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::LaunchPlanUpdateResponse>* PrepareAsyncUpdateLaunchPlanRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>* AsyncCreateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>* PrepareAsyncCreateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionCreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>* AsyncRelaunchExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>* PrepareAsyncRelaunchExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>* AsyncRecoverExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionCreateResponse>* PrepareAsyncRecoverExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Execution>* AsyncGetExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Execution>* PrepareAsyncGetExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionUpdateResponse>* AsyncUpdateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionUpdateResponse>* PrepareAsyncUpdateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>* AsyncGetExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>* PrepareAsyncGetExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionList>* AsyncListExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionList>* PrepareAsyncListExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ResourceListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionTerminateResponse>* AsyncTerminateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ExecutionTerminateResponse>* PrepareAsyncTerminateExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecution>* AsyncGetNodeExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecution>* PrepareAsyncGetNodeExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>* AsyncListNodeExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>* PrepareAsyncListNodeExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>* AsyncListNodeExecutionsForTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionList>* PrepareAsyncListNodeExecutionsForTaskRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionGetDataResponse>* AsyncGetNodeExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionGetDataResponse>* PrepareAsyncGetNodeExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectRegisterResponse>* AsyncRegisterProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectRegisterResponse>* PrepareAsyncRegisterProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectRegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectUpdateResponse>* AsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectUpdateResponse>* PrepareAsyncUpdateProjectRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::Project& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Projects>* AsyncListProjectsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::Projects>* PrepareAsyncListProjectsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionEventResponse>* AsyncCreateWorkflowEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionEventResponse>* PrepareAsyncCreateWorkflowEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionEventResponse>* AsyncCreateNodeEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NodeExecutionEventResponse>* PrepareAsyncCreateNodeEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionEventResponse>* AsyncCreateTaskEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionEventResponse>* PrepareAsyncCreateTaskEventRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecution>* AsyncGetTaskExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecution>* PrepareAsyncGetTaskExecutionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionList>* AsyncListTaskExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionList>* PrepareAsyncListTaskExecutionsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionGetDataResponse>* AsyncGetTaskExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::TaskExecutionGetDataResponse>* PrepareAsyncGetTaskExecutionDataRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* AsyncUpdateProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* PrepareAsyncUpdateProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>* AsyncGetProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>* PrepareAsyncGetProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* AsyncDeleteProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* PrepareAsyncDeleteProjectDomainAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesUpdateResponse>* AsyncUpdateProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesUpdateResponse>* PrepareAsyncUpdateProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesGetResponse>* AsyncGetProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesGetResponse>* PrepareAsyncGetProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesDeleteResponse>* AsyncDeleteProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ProjectAttributesDeleteResponse>* PrepareAsyncDeleteProjectAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>* AsyncUpdateWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>* PrepareAsyncUpdateWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesGetResponse>* AsyncGetWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesGetResponse>* PrepareAsyncGetWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>* AsyncDeleteWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>* PrepareAsyncDeleteWorkflowAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ListMatchableAttributesResponse>* AsyncListMatchableAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::ListMatchableAttributesResponse>* PrepareAsyncListMatchableAttributesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityList>* AsyncListNamedEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityList>* PrepareAsyncListNamedEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntity>* AsyncGetNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntity>* PrepareAsyncGetNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityUpdateResponse>* AsyncUpdateNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::NamedEntityUpdateResponse>* PrepareAsyncUpdateNamedEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntity>* AsyncGetDescriptionEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntity>* PrepareAsyncGetDescriptionEntityRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::ObjectGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntityList>* AsyncListDescriptionEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::DescriptionEntityList>* PrepareAsyncListDescriptionEntitiesRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* AsyncGetExecutionMetricsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* PrepareAsyncGetExecutionMetricsRaw(::grpc::ClientContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateTask_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTask_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTaskIds_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTasks_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateWorkflow_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkflow_;
    const ::grpc::internal::RpcMethod rpcmethod_ListWorkflowIds_;
    const ::grpc::internal::RpcMethod rpcmethod_ListWorkflows_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateLaunchPlan_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLaunchPlan_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActiveLaunchPlan_;
    const ::grpc::internal::RpcMethod rpcmethod_ListActiveLaunchPlans_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLaunchPlanIds_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLaunchPlans_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateLaunchPlan_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_RelaunchExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_RecoverExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExecutionData_;
    const ::grpc::internal::RpcMethod rpcmethod_ListExecutions_;
    const ::grpc::internal::RpcMethod rpcmethod_TerminateExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNodeExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_ListNodeExecutions_;
    const ::grpc::internal::RpcMethod rpcmethod_ListNodeExecutionsForTask_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNodeExecutionData_;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterProject_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateProject_;
    const ::grpc::internal::RpcMethod rpcmethod_ListProjects_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateWorkflowEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateNodeEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateTaskEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTaskExecution_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTaskExecutions_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTaskExecutionData_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateProjectDomainAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProjectDomainAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteProjectDomainAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateProjectAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProjectAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteProjectAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateWorkflowAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkflowAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteWorkflowAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMatchableAttributes_;
    const ::grpc::internal::RpcMethod rpcmethod_ListNamedEntities_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNamedEntity_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateNamedEntity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDescriptionEntity_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDescriptionEntities_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExecutionMetrics_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create and upload a :ref:`ref_nebulaidl.admin.Task` definition
    virtual ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response);
    // Fetch a :ref:`ref_nebulaidl.admin.Task` definition.
    virtual ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of task objects.
    virtual ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.Task` definitions.
    virtual ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response);
    // Create and upload a :ref:`ref_nebulaidl.admin.Workflow` definition
    virtual ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response);
    // Fetch a :ref:`ref_nebulaidl.admin.Workflow` definition.
    virtual ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of workflow objects.
    virtual ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.Workflow` definitions.
    virtual ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response);
    // Create and upload a :ref:`ref_nebulaidl.admin.LaunchPlan` definition
    virtual ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response);
    // Fetch a :ref:`ref_nebulaidl.admin.LaunchPlan` definition.
    virtual ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response);
    // Fetch the active version of a :ref:`ref_nebulaidl.admin.LaunchPlan`.
    virtual ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response);
    // List active versions of :ref:`ref_nebulaidl.admin.LaunchPlan`.
    virtual ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.NamedEntityIdentifier` of launch plan objects.
    virtual ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.LaunchPlan` definitions.
    virtual ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response);
    // Updates the status of a registered :ref:`ref_nebulaidl.admin.LaunchPlan`.
    virtual ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response);
    // Triggers the creation of a :ref:`ref_nebulaidl.admin.Execution`
    virtual ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response);
    // Triggers the creation of an identical :ref:`ref_nebulaidl.admin.Execution`
    virtual ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response);
    // Recreates a previously-run workflow execution that will only start executing from the last known failure point.
    // In Recover mode, users cannot change any input parameters or update the version of the execution.
    // This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures,
    // downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again.
    // See :ref:`ref_nebulaidl.admin.ExecutionRecoverRequest` for more details.
    virtual ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response);
    // Fetches a :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response);
    // Update execution belonging to project domain :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response);
    // Fetches input and output data for a :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response);
    // Terminates an in-progress :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response);
    // Fetches a :ref:`ref_nebulaidl.admin.NodeExecution`.
    virtual ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.NodeExecution`.
    virtual ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.NodeExecution` launched by the reference :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response);
    // Fetches input and output data for a :ref:`ref_nebulaidl.admin.NodeExecution`.
    virtual ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response);
    // Registers a :ref:`ref_nebulaidl.admin.Project` with the Nebula deployment.
    virtual ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response);
    // Updates an existing :ref:`ref_nebulaidl.admin.Project`
    // nebulaidl.admin.Project should be passed but the domains property should be empty;
    // it will be ignored in the handler as domains cannot be updated via this API.
    virtual ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response);
    // Fetches a list of :ref:`ref_nebulaidl.admin.Project`
    virtual ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response);
    // Indicates a :ref:`ref_nebulaidl.event.WorkflowExecutionEvent` has occurred.
    virtual ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response);
    // Indicates a :ref:`ref_nebulaidl.event.NodeExecutionEvent` has occurred.
    virtual ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response);
    // Indicates a :ref:`ref_nebulaidl.event.TaskExecutionEvent` has occurred.
    virtual ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response);
    // Fetches a :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response);
    // Fetches a list of :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response);
    // Fetches input and output data for a :ref:`ref_nebulaidl.admin.TaskExecution`.
    virtual ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response);
    // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response);
    // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response);
    // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response);
    // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` at the project level
    virtual ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response);
    // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response);
    // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project and domain.
    virtual ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response);
    // Creates or updates custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
    virtual ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response);
    // Fetches custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
    virtual ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response);
    // Deletes custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
    virtual ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response);
    // Lists custom :ref:`ref_nebulaidl.admin.MatchableAttributesConfiguration` for a specific resource type.
    virtual ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response);
    // Returns a list of :ref:`ref_nebulaidl.admin.NamedEntity` objects.
    virtual ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response);
    // Returns a :ref:`ref_nebulaidl.admin.NamedEntity` object.
    virtual ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response);
    // Updates a :ref:`ref_nebulaidl.admin.NamedEntity` object.
    virtual ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response);
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response);
    // Fetch a :ref:`ref_nebulaidl.admin.DescriptionEntity` object.
    virtual ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response);
    // Fetch a list of :ref:`ref_nebulaidl.admin.DescriptionEntity` definitions.
    virtual ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response);
    // Fetches runtime metrics for a :ref:`ref_nebulaidl.admin.Execution`.
    virtual ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateTask() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTask(::grpc::ServerContext* context, ::nebulaidl::admin::TaskCreateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::TaskCreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetTask() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTask(::grpc::ServerContext* context, ::nebulaidl::admin::ObjectGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::Task>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTaskIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListTaskIds() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ListTaskIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTaskIds(::grpc::ServerContext* context, ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NamedEntityIdentifierList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListTasks() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTasks(::grpc::ServerContext* context, ::nebulaidl::admin::ResourceListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::TaskList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateWorkflow() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CreateWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateWorkflow(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowCreateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowCreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkflow(::grpc::ServerContext* context, ::nebulaidl::admin::ObjectGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::Workflow>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListWorkflowIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListWorkflowIds() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ListWorkflowIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkflowIds(::grpc::ServerContext* context, ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NamedEntityIdentifierList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkflows(::grpc::ServerContext* context, ::nebulaidl::admin::ResourceListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateLaunchPlan() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateLaunchPlan(::grpc::ServerContext* context, ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::LaunchPlanCreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetLaunchPlan() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLaunchPlan(::grpc::ServerContext* context, ::nebulaidl::admin::ObjectGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::LaunchPlan>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActiveLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetActiveLaunchPlan() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetActiveLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveLaunchPlan(::grpc::ServerContext* context, ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::LaunchPlan>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListActiveLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListActiveLaunchPlans() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ListActiveLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListActiveLaunchPlans(::grpc::ServerContext* context, ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::LaunchPlanList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLaunchPlanIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListLaunchPlanIds() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ListLaunchPlanIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLaunchPlanIds(::grpc::ServerContext* context, ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NamedEntityIdentifierList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListLaunchPlans() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ListLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLaunchPlans(::grpc::ServerContext* context, ::nebulaidl::admin::ResourceListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::LaunchPlanList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateLaunchPlan() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_UpdateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateLaunchPlan(::grpc::ServerContext* context, ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::LaunchPlanUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateExecution() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_CreateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateExecution(::grpc::ServerContext* context, ::nebulaidl::admin::ExecutionCreateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ExecutionCreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RelaunchExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RelaunchExecution() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_RelaunchExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRelaunchExecution(::grpc::ServerContext* context, ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ExecutionCreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RecoverExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RecoverExecution() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_RecoverExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecoverExecution(::grpc::ServerContext* context, ::nebulaidl::admin::ExecutionRecoverRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ExecutionCreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExecution() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecution(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::Execution>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateExecution() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_UpdateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateExecution(::grpc::ServerContext* context, ::nebulaidl::admin::ExecutionUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ExecutionUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExecutionData() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionData(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowExecutionGetDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListExecutions() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_ListExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListExecutions(::grpc::ServerContext* context, ::nebulaidl::admin::ResourceListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ExecutionList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TerminateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TerminateExecution() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_TerminateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTerminateExecution(::grpc::ServerContext* context, ::nebulaidl::admin::ExecutionTerminateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ExecutionTerminateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNodeExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetNodeExecution() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetNodeExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeExecution(::grpc::ServerContext* context, ::nebulaidl::admin::NodeExecutionGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NodeExecution>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListNodeExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListNodeExecutions() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ListNodeExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNodeExecutions(::grpc::ServerContext* context, ::nebulaidl::admin::NodeExecutionListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NodeExecutionList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListNodeExecutionsForTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListNodeExecutionsForTask() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_ListNodeExecutionsForTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNodeExecutionsForTask(::grpc::ServerContext* context, ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NodeExecutionList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNodeExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetNodeExecutionData() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetNodeExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeExecutionData(::grpc::ServerContext* context, ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NodeExecutionGetDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RegisterProject() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_RegisterProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterProject(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectRegisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectRegisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateProject() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProject(::grpc::ServerContext* context, ::nebulaidl::admin::Project* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListProjects() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListProjects(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::Projects>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateWorkflowEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateWorkflowEvent() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_CreateWorkflowEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateWorkflowEvent(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowExecutionEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateNodeEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateNodeEvent() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_CreateNodeEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateNodeEvent(::grpc::ServerContext* context, ::nebulaidl::admin::NodeExecutionEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NodeExecutionEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateTaskEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateTaskEvent() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_CreateTaskEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTaskEvent(::grpc::ServerContext* context, ::nebulaidl::admin::TaskExecutionEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::TaskExecutionEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTaskExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetTaskExecution() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_GetTaskExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskExecution(::grpc::ServerContext* context, ::nebulaidl::admin::TaskExecutionGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::TaskExecution>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTaskExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListTaskExecutions() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_ListTaskExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTaskExecutions(::grpc::ServerContext* context, ::nebulaidl::admin::TaskExecutionListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::TaskExecutionList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTaskExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetTaskExecutionData() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_GetTaskExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskExecutionData(::grpc::ServerContext* context, ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::TaskExecutionGetDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateProjectDomainAttributes() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_UpdateProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProjectDomainAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetProjectDomainAttributes() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProjectDomainAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectDomainAttributesGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteProjectDomainAttributes() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_DeleteProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteProjectDomainAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateProjectAttributes() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_UpdateProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProjectAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectAttributesUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetProjectAttributes() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_GetProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProjectAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectAttributesGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteProjectAttributes() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_DeleteProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteProjectAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ProjectAttributesDeleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateWorkflowAttributes() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_UpdateWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateWorkflowAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowAttributesUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetWorkflowAttributes() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkflowAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowAttributesGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteWorkflowAttributes() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_DeleteWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorkflowAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowAttributesDeleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMatchableAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListMatchableAttributes() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_ListMatchableAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMatchableAttributes(::grpc::ServerContext* context, ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::ListMatchableAttributesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListNamedEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListNamedEntities() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_ListNamedEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNamedEntities(::grpc::ServerContext* context, ::nebulaidl::admin::NamedEntityListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NamedEntityList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetNamedEntity() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_GetNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNamedEntity(::grpc::ServerContext* context, ::nebulaidl::admin::NamedEntityGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NamedEntity>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateNamedEntity() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_UpdateNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateNamedEntity(::grpc::ServerContext* context, ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::NamedEntityUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::nebulaidl::admin::GetVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::GetVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDescriptionEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetDescriptionEntity() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetDescriptionEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDescriptionEntity(::grpc::ServerContext* context, ::nebulaidl::admin::ObjectGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::DescriptionEntity>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDescriptionEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListDescriptionEntities() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_ListDescriptionEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDescriptionEntities(::grpc::ServerContext* context, ::nebulaidl::admin::DescriptionEntityListRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::DescriptionEntityList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExecutionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExecutionMetrics() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_GetExecutionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionMetrics(::grpc::ServerContext* context, ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateTask<WithAsyncMethod_GetTask<WithAsyncMethod_ListTaskIds<WithAsyncMethod_ListTasks<WithAsyncMethod_CreateWorkflow<WithAsyncMethod_GetWorkflow<WithAsyncMethod_ListWorkflowIds<WithAsyncMethod_ListWorkflows<WithAsyncMethod_CreateLaunchPlan<WithAsyncMethod_GetLaunchPlan<WithAsyncMethod_GetActiveLaunchPlan<WithAsyncMethod_ListActiveLaunchPlans<WithAsyncMethod_ListLaunchPlanIds<WithAsyncMethod_ListLaunchPlans<WithAsyncMethod_UpdateLaunchPlan<WithAsyncMethod_CreateExecution<WithAsyncMethod_RelaunchExecution<WithAsyncMethod_RecoverExecution<WithAsyncMethod_GetExecution<WithAsyncMethod_UpdateExecution<WithAsyncMethod_GetExecutionData<WithAsyncMethod_ListExecutions<WithAsyncMethod_TerminateExecution<WithAsyncMethod_GetNodeExecution<WithAsyncMethod_ListNodeExecutions<WithAsyncMethod_ListNodeExecutionsForTask<WithAsyncMethod_GetNodeExecutionData<WithAsyncMethod_RegisterProject<WithAsyncMethod_UpdateProject<WithAsyncMethod_ListProjects<WithAsyncMethod_CreateWorkflowEvent<WithAsyncMethod_CreateNodeEvent<WithAsyncMethod_CreateTaskEvent<WithAsyncMethod_GetTaskExecution<WithAsyncMethod_ListTaskExecutions<WithAsyncMethod_GetTaskExecutionData<WithAsyncMethod_UpdateProjectDomainAttributes<WithAsyncMethod_GetProjectDomainAttributes<WithAsyncMethod_DeleteProjectDomainAttributes<WithAsyncMethod_UpdateProjectAttributes<WithAsyncMethod_GetProjectAttributes<WithAsyncMethod_DeleteProjectAttributes<WithAsyncMethod_UpdateWorkflowAttributes<WithAsyncMethod_GetWorkflowAttributes<WithAsyncMethod_DeleteWorkflowAttributes<WithAsyncMethod_ListMatchableAttributes<WithAsyncMethod_ListNamedEntities<WithAsyncMethod_GetNamedEntity<WithAsyncMethod_UpdateNamedEntity<WithAsyncMethod_GetVersion<WithAsyncMethod_GetDescriptionEntity<WithAsyncMethod_ListDescriptionEntities<WithAsyncMethod_GetExecutionMetrics<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateTask() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskCreateRequest, ::nebulaidl::admin::TaskCreateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::TaskCreateRequest* request,
                 ::nebulaidl::admin::TaskCreateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateTask(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateTask(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::TaskCreateRequest, ::nebulaidl::admin::TaskCreateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskCreateRequest, ::nebulaidl::admin::TaskCreateResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetTask() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Task>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ObjectGetRequest* request,
                 ::nebulaidl::admin::Task* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetTask(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetTask(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Task>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Task>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTaskIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListTaskIds() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request,
                 ::nebulaidl::admin::NamedEntityIdentifierList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListTaskIds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListTaskIds(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTaskIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListTasks() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::TaskList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ResourceListRequest* request,
                 ::nebulaidl::admin::TaskList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListTasks(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListTasks(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::TaskList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::TaskList>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateWorkflow() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowCreateRequest, ::nebulaidl::admin::WorkflowCreateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowCreateRequest* request,
                 ::nebulaidl::admin::WorkflowCreateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateWorkflow(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateWorkflow(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowCreateRequest, ::nebulaidl::admin::WorkflowCreateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowCreateRequest, ::nebulaidl::admin::WorkflowCreateResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetWorkflow() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Workflow>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ObjectGetRequest* request,
                 ::nebulaidl::admin::Workflow* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetWorkflow(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetWorkflow(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Workflow>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Workflow>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListWorkflowIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListWorkflowIds() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request,
                 ::nebulaidl::admin::NamedEntityIdentifierList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListWorkflowIds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListWorkflowIds(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListWorkflowIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListWorkflows() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::WorkflowList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ResourceListRequest* request,
                 ::nebulaidl::admin::WorkflowList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListWorkflows(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListWorkflows(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::WorkflowList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::WorkflowList>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::LaunchPlanCreateRequest, ::nebulaidl::admin::LaunchPlanCreateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::LaunchPlanCreateRequest* request,
                 ::nebulaidl::admin::LaunchPlanCreateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateLaunchPlan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateLaunchPlan(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::LaunchPlanCreateRequest, ::nebulaidl::admin::LaunchPlanCreateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::LaunchPlanCreateRequest, ::nebulaidl::admin::LaunchPlanCreateResponse>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::LaunchPlan>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ObjectGetRequest* request,
                 ::nebulaidl::admin::LaunchPlan* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetLaunchPlan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetLaunchPlan(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::LaunchPlan>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::LaunchPlan>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetActiveLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetActiveLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ActiveLaunchPlanRequest, ::nebulaidl::admin::LaunchPlan>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ActiveLaunchPlanRequest* request,
                 ::nebulaidl::admin::LaunchPlan* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetActiveLaunchPlan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetActiveLaunchPlan(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ActiveLaunchPlanRequest, ::nebulaidl::admin::LaunchPlan>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ActiveLaunchPlanRequest, ::nebulaidl::admin::LaunchPlan>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetActiveLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListActiveLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListActiveLaunchPlans() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ActiveLaunchPlanListRequest, ::nebulaidl::admin::LaunchPlanList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request,
                 ::nebulaidl::admin::LaunchPlanList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListActiveLaunchPlans(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListActiveLaunchPlans(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ActiveLaunchPlanListRequest, ::nebulaidl::admin::LaunchPlanList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ActiveLaunchPlanListRequest, ::nebulaidl::admin::LaunchPlanList>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListActiveLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLaunchPlanIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListLaunchPlanIds() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request,
                 ::nebulaidl::admin::NamedEntityIdentifierList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListLaunchPlanIds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListLaunchPlanIds(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListLaunchPlanIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListLaunchPlans() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::LaunchPlanList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ResourceListRequest* request,
                 ::nebulaidl::admin::LaunchPlanList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListLaunchPlans(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListLaunchPlans(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::LaunchPlanList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::LaunchPlanList>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::LaunchPlanUpdateRequest, ::nebulaidl::admin::LaunchPlanUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::LaunchPlanUpdateRequest* request,
                 ::nebulaidl::admin::LaunchPlanUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateLaunchPlan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateLaunchPlan(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::LaunchPlanUpdateRequest, ::nebulaidl::admin::LaunchPlanUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::LaunchPlanUpdateRequest, ::nebulaidl::admin::LaunchPlanUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionCreateRequest, ::nebulaidl::admin::ExecutionCreateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ExecutionCreateRequest* request,
                 ::nebulaidl::admin::ExecutionCreateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ExecutionCreateRequest, ::nebulaidl::admin::ExecutionCreateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionCreateRequest, ::nebulaidl::admin::ExecutionCreateResponse>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RelaunchExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RelaunchExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionRelaunchRequest, ::nebulaidl::admin::ExecutionCreateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ExecutionRelaunchRequest* request,
                 ::nebulaidl::admin::ExecutionCreateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RelaunchExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RelaunchExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ExecutionRelaunchRequest, ::nebulaidl::admin::ExecutionCreateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionRelaunchRequest, ::nebulaidl::admin::ExecutionCreateResponse>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RelaunchExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RecoverExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RecoverExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionRecoverRequest, ::nebulaidl::admin::ExecutionCreateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ExecutionRecoverRequest* request,
                 ::nebulaidl::admin::ExecutionCreateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RecoverExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RecoverExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ExecutionRecoverRequest, ::nebulaidl::admin::ExecutionCreateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionRecoverRequest, ::nebulaidl::admin::ExecutionCreateResponse>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RecoverExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetRequest, ::nebulaidl::admin::Execution>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowExecutionGetRequest* request,
                 ::nebulaidl::admin::Execution* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowExecutionGetRequest, ::nebulaidl::admin::Execution>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetRequest, ::nebulaidl::admin::Execution>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionUpdateRequest, ::nebulaidl::admin::ExecutionUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ExecutionUpdateRequest* request,
                 ::nebulaidl::admin::ExecutionUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ExecutionUpdateRequest, ::nebulaidl::admin::ExecutionUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionUpdateRequest, ::nebulaidl::admin::ExecutionUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExecutionData() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetDataRequest, ::nebulaidl::admin::WorkflowExecutionGetDataResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request,
                 ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExecutionData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExecutionData(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowExecutionGetDataRequest, ::nebulaidl::admin::WorkflowExecutionGetDataResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetDataRequest, ::nebulaidl::admin::WorkflowExecutionGetDataResponse>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListExecutions() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::ExecutionList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ResourceListRequest* request,
                 ::nebulaidl::admin::ExecutionList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListExecutions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListExecutions(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::ExecutionList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::ExecutionList>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TerminateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_TerminateExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionTerminateRequest, ::nebulaidl::admin::ExecutionTerminateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ExecutionTerminateRequest* request,
                 ::nebulaidl::admin::ExecutionTerminateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->TerminateExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_TerminateExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ExecutionTerminateRequest, ::nebulaidl::admin::ExecutionTerminateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ExecutionTerminateRequest, ::nebulaidl::admin::ExecutionTerminateResponse>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TerminateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNodeExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetNodeExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionGetRequest, ::nebulaidl::admin::NodeExecution>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NodeExecutionGetRequest* request,
                 ::nebulaidl::admin::NodeExecution* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetNodeExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetNodeExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NodeExecutionGetRequest, ::nebulaidl::admin::NodeExecution>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionGetRequest, ::nebulaidl::admin::NodeExecution>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNodeExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListNodeExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListNodeExecutions() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionListRequest, ::nebulaidl::admin::NodeExecutionList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NodeExecutionListRequest* request,
                 ::nebulaidl::admin::NodeExecutionList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListNodeExecutions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListNodeExecutions(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NodeExecutionListRequest, ::nebulaidl::admin::NodeExecutionList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionListRequest, ::nebulaidl::admin::NodeExecutionList>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListNodeExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListNodeExecutionsForTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListNodeExecutionsForTask() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionForTaskListRequest, ::nebulaidl::admin::NodeExecutionList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request,
                 ::nebulaidl::admin::NodeExecutionList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListNodeExecutionsForTask(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListNodeExecutionsForTask(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NodeExecutionForTaskListRequest, ::nebulaidl::admin::NodeExecutionList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionForTaskListRequest, ::nebulaidl::admin::NodeExecutionList>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListNodeExecutionsForTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNodeExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetNodeExecutionData() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionGetDataRequest, ::nebulaidl::admin::NodeExecutionGetDataResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NodeExecutionGetDataRequest* request,
                 ::nebulaidl::admin::NodeExecutionGetDataResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetNodeExecutionData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetNodeExecutionData(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NodeExecutionGetDataRequest, ::nebulaidl::admin::NodeExecutionGetDataResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionGetDataRequest, ::nebulaidl::admin::NodeExecutionGetDataResponse>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNodeExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RegisterProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RegisterProject() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectRegisterRequest, ::nebulaidl::admin::ProjectRegisterResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectRegisterRequest* request,
                 ::nebulaidl::admin::ProjectRegisterResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RegisterProject(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RegisterProject(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectRegisterRequest, ::nebulaidl::admin::ProjectRegisterResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectRegisterRequest, ::nebulaidl::admin::ProjectRegisterResponse>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RegisterProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateProject() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::Project, ::nebulaidl::admin::ProjectUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::Project* request,
                 ::nebulaidl::admin::ProjectUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateProject(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateProject(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::Project, ::nebulaidl::admin::ProjectUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::Project, ::nebulaidl::admin::ProjectUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListProjects() {
      ::grpc::Service::experimental().MarkMethodCallback(29,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectListRequest, ::nebulaidl::admin::Projects>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectListRequest* request,
                 ::nebulaidl::admin::Projects* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListProjects(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListProjects(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectListRequest, ::nebulaidl::admin::Projects>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectListRequest, ::nebulaidl::admin::Projects>*>(
          ::grpc::Service::experimental().GetHandler(29))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateWorkflowEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateWorkflowEvent() {
      ::grpc::Service::experimental().MarkMethodCallback(30,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionEventRequest, ::nebulaidl::admin::WorkflowExecutionEventResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowExecutionEventRequest* request,
                 ::nebulaidl::admin::WorkflowExecutionEventResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateWorkflowEvent(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateWorkflowEvent(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowExecutionEventRequest, ::nebulaidl::admin::WorkflowExecutionEventResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionEventRequest, ::nebulaidl::admin::WorkflowExecutionEventResponse>*>(
          ::grpc::Service::experimental().GetHandler(30))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateWorkflowEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateNodeEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateNodeEvent() {
      ::grpc::Service::experimental().MarkMethodCallback(31,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionEventRequest, ::nebulaidl::admin::NodeExecutionEventResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NodeExecutionEventRequest* request,
                 ::nebulaidl::admin::NodeExecutionEventResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateNodeEvent(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateNodeEvent(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NodeExecutionEventRequest, ::nebulaidl::admin::NodeExecutionEventResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NodeExecutionEventRequest, ::nebulaidl::admin::NodeExecutionEventResponse>*>(
          ::grpc::Service::experimental().GetHandler(31))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateNodeEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateTaskEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateTaskEvent() {
      ::grpc::Service::experimental().MarkMethodCallback(32,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionEventRequest, ::nebulaidl::admin::TaskExecutionEventResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::TaskExecutionEventRequest* request,
                 ::nebulaidl::admin::TaskExecutionEventResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateTaskEvent(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateTaskEvent(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::TaskExecutionEventRequest, ::nebulaidl::admin::TaskExecutionEventResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionEventRequest, ::nebulaidl::admin::TaskExecutionEventResponse>*>(
          ::grpc::Service::experimental().GetHandler(32))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateTaskEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTaskExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetTaskExecution() {
      ::grpc::Service::experimental().MarkMethodCallback(33,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionGetRequest, ::nebulaidl::admin::TaskExecution>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::TaskExecutionGetRequest* request,
                 ::nebulaidl::admin::TaskExecution* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetTaskExecution(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetTaskExecution(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::TaskExecutionGetRequest, ::nebulaidl::admin::TaskExecution>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionGetRequest, ::nebulaidl::admin::TaskExecution>*>(
          ::grpc::Service::experimental().GetHandler(33))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTaskExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTaskExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListTaskExecutions() {
      ::grpc::Service::experimental().MarkMethodCallback(34,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionListRequest, ::nebulaidl::admin::TaskExecutionList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::TaskExecutionListRequest* request,
                 ::nebulaidl::admin::TaskExecutionList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListTaskExecutions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListTaskExecutions(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::TaskExecutionListRequest, ::nebulaidl::admin::TaskExecutionList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionListRequest, ::nebulaidl::admin::TaskExecutionList>*>(
          ::grpc::Service::experimental().GetHandler(34))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTaskExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTaskExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetTaskExecutionData() {
      ::grpc::Service::experimental().MarkMethodCallback(35,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionGetDataRequest, ::nebulaidl::admin::TaskExecutionGetDataResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::TaskExecutionGetDataRequest* request,
                 ::nebulaidl::admin::TaskExecutionGetDataResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetTaskExecutionData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetTaskExecutionData(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::TaskExecutionGetDataRequest, ::nebulaidl::admin::TaskExecutionGetDataResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::TaskExecutionGetDataRequest, ::nebulaidl::admin::TaskExecutionGetDataResponse>*>(
          ::grpc::Service::experimental().GetHandler(35))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTaskExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateProjectDomainAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(36,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request,
                 ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateProjectDomainAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateProjectDomainAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(36))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetProjectDomainAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(37,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesGetRequest, ::nebulaidl::admin::ProjectDomainAttributesGetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request,
                 ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetProjectDomainAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetProjectDomainAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectDomainAttributesGetRequest, ::nebulaidl::admin::ProjectDomainAttributesGetResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesGetRequest, ::nebulaidl::admin::ProjectDomainAttributesGetResponse>*>(
          ::grpc::Service::experimental().GetHandler(37))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteProjectDomainAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(38,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request,
                 ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteProjectDomainAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteProjectDomainAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>*>(
          ::grpc::Service::experimental().GetHandler(38))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateProjectAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(39,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectAttributesUpdateRequest, ::nebulaidl::admin::ProjectAttributesUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request,
                 ::nebulaidl::admin::ProjectAttributesUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateProjectAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateProjectAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectAttributesUpdateRequest, ::nebulaidl::admin::ProjectAttributesUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectAttributesUpdateRequest, ::nebulaidl::admin::ProjectAttributesUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(39))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetProjectAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(40,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectAttributesGetRequest, ::nebulaidl::admin::ProjectAttributesGetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectAttributesGetRequest* request,
                 ::nebulaidl::admin::ProjectAttributesGetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetProjectAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetProjectAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectAttributesGetRequest, ::nebulaidl::admin::ProjectAttributesGetResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectAttributesGetRequest, ::nebulaidl::admin::ProjectAttributesGetResponse>*>(
          ::grpc::Service::experimental().GetHandler(40))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteProjectAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(41,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectAttributesDeleteRequest, ::nebulaidl::admin::ProjectAttributesDeleteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request,
                 ::nebulaidl::admin::ProjectAttributesDeleteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteProjectAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteProjectAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ProjectAttributesDeleteRequest, ::nebulaidl::admin::ProjectAttributesDeleteResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ProjectAttributesDeleteRequest, ::nebulaidl::admin::ProjectAttributesDeleteResponse>*>(
          ::grpc::Service::experimental().GetHandler(41))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateWorkflowAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(42,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowAttributesUpdateRequest, ::nebulaidl::admin::WorkflowAttributesUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request,
                 ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateWorkflowAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateWorkflowAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowAttributesUpdateRequest, ::nebulaidl::admin::WorkflowAttributesUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowAttributesUpdateRequest, ::nebulaidl::admin::WorkflowAttributesUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(42))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetWorkflowAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(43,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowAttributesGetRequest, ::nebulaidl::admin::WorkflowAttributesGetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowAttributesGetRequest* request,
                 ::nebulaidl::admin::WorkflowAttributesGetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetWorkflowAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetWorkflowAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowAttributesGetRequest, ::nebulaidl::admin::WorkflowAttributesGetResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowAttributesGetRequest, ::nebulaidl::admin::WorkflowAttributesGetResponse>*>(
          ::grpc::Service::experimental().GetHandler(43))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteWorkflowAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(44,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowAttributesDeleteRequest, ::nebulaidl::admin::WorkflowAttributesDeleteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request,
                 ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteWorkflowAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteWorkflowAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowAttributesDeleteRequest, ::nebulaidl::admin::WorkflowAttributesDeleteResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowAttributesDeleteRequest, ::nebulaidl::admin::WorkflowAttributesDeleteResponse>*>(
          ::grpc::Service::experimental().GetHandler(44))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListMatchableAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListMatchableAttributes() {
      ::grpc::Service::experimental().MarkMethodCallback(45,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ListMatchableAttributesRequest, ::nebulaidl::admin::ListMatchableAttributesResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ListMatchableAttributesRequest* request,
                 ::nebulaidl::admin::ListMatchableAttributesResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListMatchableAttributes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListMatchableAttributes(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ListMatchableAttributesRequest, ::nebulaidl::admin::ListMatchableAttributesResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ListMatchableAttributesRequest, ::nebulaidl::admin::ListMatchableAttributesResponse>*>(
          ::grpc::Service::experimental().GetHandler(45))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListMatchableAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListNamedEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListNamedEntities() {
      ::grpc::Service::experimental().MarkMethodCallback(46,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityListRequest, ::nebulaidl::admin::NamedEntityList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NamedEntityListRequest* request,
                 ::nebulaidl::admin::NamedEntityList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListNamedEntities(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListNamedEntities(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NamedEntityListRequest, ::nebulaidl::admin::NamedEntityList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityListRequest, ::nebulaidl::admin::NamedEntityList>*>(
          ::grpc::Service::experimental().GetHandler(46))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListNamedEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetNamedEntity() {
      ::grpc::Service::experimental().MarkMethodCallback(47,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityGetRequest, ::nebulaidl::admin::NamedEntity>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NamedEntityGetRequest* request,
                 ::nebulaidl::admin::NamedEntity* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetNamedEntity(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetNamedEntity(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NamedEntityGetRequest, ::nebulaidl::admin::NamedEntity>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityGetRequest, ::nebulaidl::admin::NamedEntity>*>(
          ::grpc::Service::experimental().GetHandler(47))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateNamedEntity() {
      ::grpc::Service::experimental().MarkMethodCallback(48,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityUpdateRequest, ::nebulaidl::admin::NamedEntityUpdateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::NamedEntityUpdateRequest* request,
                 ::nebulaidl::admin::NamedEntityUpdateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateNamedEntity(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateNamedEntity(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::NamedEntityUpdateRequest, ::nebulaidl::admin::NamedEntityUpdateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::NamedEntityUpdateRequest, ::nebulaidl::admin::NamedEntityUpdateResponse>*>(
          ::grpc::Service::experimental().GetHandler(48))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetVersion() {
      ::grpc::Service::experimental().MarkMethodCallback(49,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::GetVersionRequest, ::nebulaidl::admin::GetVersionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::GetVersionRequest* request,
                 ::nebulaidl::admin::GetVersionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetVersion(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetVersion(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::GetVersionRequest, ::nebulaidl::admin::GetVersionResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::GetVersionRequest, ::nebulaidl::admin::GetVersionResponse>*>(
          ::grpc::Service::experimental().GetHandler(49))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDescriptionEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetDescriptionEntity() {
      ::grpc::Service::experimental().MarkMethodCallback(50,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::DescriptionEntity>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::ObjectGetRequest* request,
                 ::nebulaidl::admin::DescriptionEntity* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetDescriptionEntity(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetDescriptionEntity(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::DescriptionEntity>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::DescriptionEntity>*>(
          ::grpc::Service::experimental().GetHandler(50))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDescriptionEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListDescriptionEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListDescriptionEntities() {
      ::grpc::Service::experimental().MarkMethodCallback(51,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::DescriptionEntityListRequest, ::nebulaidl::admin::DescriptionEntityList>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::DescriptionEntityListRequest* request,
                 ::nebulaidl::admin::DescriptionEntityList* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListDescriptionEntities(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListDescriptionEntities(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::DescriptionEntityListRequest, ::nebulaidl::admin::DescriptionEntityList>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::DescriptionEntityListRequest, ::nebulaidl::admin::DescriptionEntityList>*>(
          ::grpc::Service::experimental().GetHandler(51))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListDescriptionEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExecutionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExecutionMetrics() {
      ::grpc::Service::experimental().MarkMethodCallback(52,
        new ::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request,
                 ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExecutionMetrics(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExecutionMetrics(
        ::grpc::experimental::MessageAllocator< ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>*>(
          ::grpc::Service::experimental().GetHandler(52))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExecutionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_CreateTask<ExperimentalWithCallbackMethod_GetTask<ExperimentalWithCallbackMethod_ListTaskIds<ExperimentalWithCallbackMethod_ListTasks<ExperimentalWithCallbackMethod_CreateWorkflow<ExperimentalWithCallbackMethod_GetWorkflow<ExperimentalWithCallbackMethod_ListWorkflowIds<ExperimentalWithCallbackMethod_ListWorkflows<ExperimentalWithCallbackMethod_CreateLaunchPlan<ExperimentalWithCallbackMethod_GetLaunchPlan<ExperimentalWithCallbackMethod_GetActiveLaunchPlan<ExperimentalWithCallbackMethod_ListActiveLaunchPlans<ExperimentalWithCallbackMethod_ListLaunchPlanIds<ExperimentalWithCallbackMethod_ListLaunchPlans<ExperimentalWithCallbackMethod_UpdateLaunchPlan<ExperimentalWithCallbackMethod_CreateExecution<ExperimentalWithCallbackMethod_RelaunchExecution<ExperimentalWithCallbackMethod_RecoverExecution<ExperimentalWithCallbackMethod_GetExecution<ExperimentalWithCallbackMethod_UpdateExecution<ExperimentalWithCallbackMethod_GetExecutionData<ExperimentalWithCallbackMethod_ListExecutions<ExperimentalWithCallbackMethod_TerminateExecution<ExperimentalWithCallbackMethod_GetNodeExecution<ExperimentalWithCallbackMethod_ListNodeExecutions<ExperimentalWithCallbackMethod_ListNodeExecutionsForTask<ExperimentalWithCallbackMethod_GetNodeExecutionData<ExperimentalWithCallbackMethod_RegisterProject<ExperimentalWithCallbackMethod_UpdateProject<ExperimentalWithCallbackMethod_ListProjects<ExperimentalWithCallbackMethod_CreateWorkflowEvent<ExperimentalWithCallbackMethod_CreateNodeEvent<ExperimentalWithCallbackMethod_CreateTaskEvent<ExperimentalWithCallbackMethod_GetTaskExecution<ExperimentalWithCallbackMethod_ListTaskExecutions<ExperimentalWithCallbackMethod_GetTaskExecutionData<ExperimentalWithCallbackMethod_UpdateProjectDomainAttributes<ExperimentalWithCallbackMethod_GetProjectDomainAttributes<ExperimentalWithCallbackMethod_DeleteProjectDomainAttributes<ExperimentalWithCallbackMethod_UpdateProjectAttributes<ExperimentalWithCallbackMethod_GetProjectAttributes<ExperimentalWithCallbackMethod_DeleteProjectAttributes<ExperimentalWithCallbackMethod_UpdateWorkflowAttributes<ExperimentalWithCallbackMethod_GetWorkflowAttributes<ExperimentalWithCallbackMethod_DeleteWorkflowAttributes<ExperimentalWithCallbackMethod_ListMatchableAttributes<ExperimentalWithCallbackMethod_ListNamedEntities<ExperimentalWithCallbackMethod_GetNamedEntity<ExperimentalWithCallbackMethod_UpdateNamedEntity<ExperimentalWithCallbackMethod_GetVersion<ExperimentalWithCallbackMethod_GetDescriptionEntity<ExperimentalWithCallbackMethod_ListDescriptionEntities<ExperimentalWithCallbackMethod_GetExecutionMetrics<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateTask() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetTask() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTaskIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListTaskIds() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ListTaskIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListTasks() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateWorkflow() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CreateWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListWorkflowIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListWorkflowIds() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ListWorkflowIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateLaunchPlan() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetLaunchPlan() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActiveLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetActiveLaunchPlan() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetActiveLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListActiveLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListActiveLaunchPlans() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ListActiveLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLaunchPlanIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListLaunchPlanIds() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ListLaunchPlanIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListLaunchPlans() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ListLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateLaunchPlan() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_UpdateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateExecution() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_CreateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RelaunchExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RelaunchExecution() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_RelaunchExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RecoverExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RecoverExecution() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_RecoverExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExecution() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateExecution() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_UpdateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExecutionData() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListExecutions() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_ListExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TerminateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TerminateExecution() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_TerminateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNodeExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetNodeExecution() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetNodeExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListNodeExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListNodeExecutions() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ListNodeExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListNodeExecutionsForTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListNodeExecutionsForTask() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_ListNodeExecutionsForTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNodeExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetNodeExecutionData() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetNodeExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegisterProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RegisterProject() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_RegisterProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateProject() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListProjects() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateWorkflowEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateWorkflowEvent() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_CreateWorkflowEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateNodeEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateNodeEvent() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_CreateNodeEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateTaskEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateTaskEvent() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_CreateTaskEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTaskExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetTaskExecution() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_GetTaskExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTaskExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListTaskExecutions() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_ListTaskExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTaskExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetTaskExecutionData() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_GetTaskExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateProjectDomainAttributes() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_UpdateProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetProjectDomainAttributes() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteProjectDomainAttributes() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_DeleteProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateProjectAttributes() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_UpdateProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetProjectAttributes() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_GetProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteProjectAttributes() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_DeleteProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateWorkflowAttributes() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_UpdateWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetWorkflowAttributes() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteWorkflowAttributes() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_DeleteWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMatchableAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListMatchableAttributes() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_ListMatchableAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListNamedEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListNamedEntities() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_ListNamedEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetNamedEntity() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_GetNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateNamedEntity() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_UpdateNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDescriptionEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetDescriptionEntity() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetDescriptionEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDescriptionEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListDescriptionEntities() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_ListDescriptionEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExecutionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExecutionMetrics() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_GetExecutionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateTask() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetTask() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTaskIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListTaskIds() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ListTaskIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTaskIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListTasks() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTasks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateWorkflow() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CreateWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateWorkflow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkflow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListWorkflowIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListWorkflowIds() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ListWorkflowIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkflowIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkflows(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateLaunchPlan() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateLaunchPlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetLaunchPlan() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLaunchPlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActiveLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetActiveLaunchPlan() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetActiveLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveLaunchPlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListActiveLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListActiveLaunchPlans() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ListActiveLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListActiveLaunchPlans(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLaunchPlanIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListLaunchPlanIds() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ListLaunchPlanIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLaunchPlanIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListLaunchPlans() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ListLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLaunchPlans(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateLaunchPlan() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_UpdateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateLaunchPlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateExecution() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_CreateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RelaunchExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RelaunchExecution() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_RelaunchExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRelaunchExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RecoverExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RecoverExecution() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_RecoverExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecoverExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExecution() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateExecution() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_UpdateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExecutionData() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListExecutions() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_ListExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListExecutions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TerminateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TerminateExecution() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_TerminateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTerminateExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNodeExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetNodeExecution() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetNodeExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListNodeExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListNodeExecutions() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ListNodeExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNodeExecutions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListNodeExecutionsForTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListNodeExecutionsForTask() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_ListNodeExecutionsForTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNodeExecutionsForTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNodeExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetNodeExecutionData() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetNodeExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeExecutionData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RegisterProject() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_RegisterProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateProject() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListProjects() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListProjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateWorkflowEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateWorkflowEvent() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_CreateWorkflowEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateWorkflowEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateNodeEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateNodeEvent() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_CreateNodeEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateNodeEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateTaskEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateTaskEvent() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_CreateTaskEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTaskEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTaskExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetTaskExecution() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_GetTaskExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTaskExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListTaskExecutions() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_ListTaskExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTaskExecutions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTaskExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetTaskExecutionData() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_GetTaskExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskExecutionData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateProjectDomainAttributes() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_UpdateProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProjectDomainAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetProjectDomainAttributes() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProjectDomainAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteProjectDomainAttributes() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_DeleteProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteProjectDomainAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateProjectAttributes() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_UpdateProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateProjectAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetProjectAttributes() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_GetProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProjectAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteProjectAttributes() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_DeleteProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteProjectAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateWorkflowAttributes() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_UpdateWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateWorkflowAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetWorkflowAttributes() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkflowAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteWorkflowAttributes() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_DeleteWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorkflowAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMatchableAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListMatchableAttributes() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_ListMatchableAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMatchableAttributes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListNamedEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListNamedEntities() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_ListNamedEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNamedEntities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetNamedEntity() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_GetNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNamedEntity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateNamedEntity() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_UpdateNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateNamedEntity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDescriptionEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetDescriptionEntity() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetDescriptionEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDescriptionEntity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDescriptionEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListDescriptionEntities() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_ListDescriptionEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDescriptionEntities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExecutionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExecutionMetrics() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_GetExecutionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateTask() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateTask(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateTask(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTask() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetTask(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTask(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTaskIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTaskIds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListTaskIds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTaskIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListTaskIds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTasks() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListTasks(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListTasks(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateWorkflow() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateWorkflow(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateWorkflow(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorkflow() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetWorkflow(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetWorkflow(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListWorkflowIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListWorkflowIds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListWorkflowIds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListWorkflowIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListWorkflowIds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListWorkflows() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListWorkflows(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListWorkflows(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateLaunchPlan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateLaunchPlan(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetLaunchPlan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetLaunchPlan(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetActiveLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetActiveLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetActiveLaunchPlan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetActiveLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetActiveLaunchPlan(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListActiveLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListActiveLaunchPlans() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListActiveLaunchPlans(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListActiveLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListActiveLaunchPlans(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLaunchPlanIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLaunchPlanIds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListLaunchPlanIds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLaunchPlanIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListLaunchPlanIds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLaunchPlans() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListLaunchPlans(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListLaunchPlans(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateLaunchPlan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateLaunchPlan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateLaunchPlan(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RelaunchExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RelaunchExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RelaunchExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RelaunchExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RelaunchExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RecoverExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RecoverExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RecoverExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RecoverExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RecoverExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExecutionData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExecutionData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExecutionData(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListExecutions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListExecutions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListExecutions(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TerminateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_TerminateExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->TerminateExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_TerminateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TerminateExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNodeExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNodeExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetNodeExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNodeExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNodeExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListNodeExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListNodeExecutions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListNodeExecutions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListNodeExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListNodeExecutions(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListNodeExecutionsForTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListNodeExecutionsForTask() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListNodeExecutionsForTask(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListNodeExecutionsForTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNodeExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNodeExecutionData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetNodeExecutionData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNodeExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNodeExecutionData(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RegisterProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RegisterProject() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RegisterProject(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RegisterProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RegisterProject(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateProject() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateProject(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateProject(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListProjects() {
      ::grpc::Service::experimental().MarkMethodRawCallback(29,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListProjects(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListProjects(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateWorkflowEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateWorkflowEvent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(30,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateWorkflowEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateWorkflowEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateWorkflowEvent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateNodeEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateNodeEvent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(31,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateNodeEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateNodeEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateNodeEvent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateTaskEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateTaskEvent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(32,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateTaskEvent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateTaskEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateTaskEvent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTaskExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTaskExecution() {
      ::grpc::Service::experimental().MarkMethodRawCallback(33,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetTaskExecution(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTaskExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTaskExecution(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTaskExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTaskExecutions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(34,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListTaskExecutions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTaskExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListTaskExecutions(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTaskExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTaskExecutionData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(35,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetTaskExecutionData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTaskExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTaskExecutionData(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateProjectDomainAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(36,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateProjectDomainAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProjectDomainAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(37,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetProjectDomainAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetProjectDomainAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteProjectDomainAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(38,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteProjectDomainAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateProjectAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(39,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateProjectAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateProjectAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProjectAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(40,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetProjectAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetProjectAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteProjectAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(41,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteProjectAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteProjectAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateWorkflowAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(42,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateWorkflowAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorkflowAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(43,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetWorkflowAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetWorkflowAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteWorkflowAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(44,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteWorkflowAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListMatchableAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListMatchableAttributes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(45,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListMatchableAttributes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListMatchableAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListMatchableAttributes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListNamedEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListNamedEntities() {
      ::grpc::Service::experimental().MarkMethodRawCallback(46,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListNamedEntities(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListNamedEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListNamedEntities(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNamedEntity() {
      ::grpc::Service::experimental().MarkMethodRawCallback(47,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetNamedEntity(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNamedEntity(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateNamedEntity() {
      ::grpc::Service::experimental().MarkMethodRawCallback(48,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateNamedEntity(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateNamedEntity(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVersion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(49,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetVersion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVersion(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDescriptionEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDescriptionEntity() {
      ::grpc::Service::experimental().MarkMethodRawCallback(50,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetDescriptionEntity(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDescriptionEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDescriptionEntity(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListDescriptionEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListDescriptionEntities() {
      ::grpc::Service::experimental().MarkMethodRawCallback(51,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListDescriptionEntities(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListDescriptionEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListDescriptionEntities(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExecutionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExecutionMetrics() {
      ::grpc::Service::experimental().MarkMethodRawCallback(52,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExecutionMetrics(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExecutionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExecutionMetrics(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateTask() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::TaskCreateRequest, ::nebulaidl::admin::TaskCreateResponse>(std::bind(&WithStreamedUnaryMethod_CreateTask<BaseClass>::StreamedCreateTask, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateTask(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskCreateRequest* request, ::nebulaidl::admin::TaskCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::TaskCreateRequest,::nebulaidl::admin::TaskCreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetTask() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Task>(std::bind(&WithStreamedUnaryMethod_GetTask<BaseClass>::StreamedGetTask, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Task* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ObjectGetRequest,::nebulaidl::admin::Task>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTaskIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListTaskIds() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>(std::bind(&WithStreamedUnaryMethod_ListTaskIds<BaseClass>::StreamedListTaskIds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListTaskIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTaskIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTaskIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NamedEntityIdentifierListRequest,::nebulaidl::admin::NamedEntityIdentifierList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListTasks() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::TaskList>(std::bind(&WithStreamedUnaryMethod_ListTasks<BaseClass>::StreamedListTasks, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::TaskList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTasks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ResourceListRequest,::nebulaidl::admin::TaskList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateWorkflow() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowCreateRequest, ::nebulaidl::admin::WorkflowCreateResponse>(std::bind(&WithStreamedUnaryMethod_CreateWorkflow<BaseClass>::StreamedCreateWorkflow, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowCreateRequest* request, ::nebulaidl::admin::WorkflowCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateWorkflow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowCreateRequest,::nebulaidl::admin::WorkflowCreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::Workflow>(std::bind(&WithStreamedUnaryMethod_GetWorkflow<BaseClass>::StreamedGetWorkflow, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::Workflow* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkflow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ObjectGetRequest,::nebulaidl::admin::Workflow>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListWorkflowIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListWorkflowIds() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>(std::bind(&WithStreamedUnaryMethod_ListWorkflowIds<BaseClass>::StreamedListWorkflowIds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListWorkflowIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListWorkflowIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListWorkflowIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NamedEntityIdentifierListRequest,::nebulaidl::admin::NamedEntityIdentifierList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::WorkflowList>(std::bind(&WithStreamedUnaryMethod_ListWorkflows<BaseClass>::StreamedListWorkflows, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::WorkflowList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListWorkflows(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ResourceListRequest,::nebulaidl::admin::WorkflowList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateLaunchPlan() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::LaunchPlanCreateRequest, ::nebulaidl::admin::LaunchPlanCreateResponse>(std::bind(&WithStreamedUnaryMethod_CreateLaunchPlan<BaseClass>::StreamedCreateLaunchPlan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanCreateRequest* request, ::nebulaidl::admin::LaunchPlanCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateLaunchPlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::LaunchPlanCreateRequest,::nebulaidl::admin::LaunchPlanCreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetLaunchPlan() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::LaunchPlan>(std::bind(&WithStreamedUnaryMethod_GetLaunchPlan<BaseClass>::StreamedGetLaunchPlan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLaunchPlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ObjectGetRequest,::nebulaidl::admin::LaunchPlan>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActiveLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetActiveLaunchPlan() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ActiveLaunchPlanRequest, ::nebulaidl::admin::LaunchPlan>(std::bind(&WithStreamedUnaryMethod_GetActiveLaunchPlan<BaseClass>::StreamedGetActiveLaunchPlan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetActiveLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActiveLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanRequest* request, ::nebulaidl::admin::LaunchPlan* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActiveLaunchPlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ActiveLaunchPlanRequest,::nebulaidl::admin::LaunchPlan>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListActiveLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListActiveLaunchPlans() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ActiveLaunchPlanListRequest, ::nebulaidl::admin::LaunchPlanList>(std::bind(&WithStreamedUnaryMethod_ListActiveLaunchPlans<BaseClass>::StreamedListActiveLaunchPlans, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListActiveLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListActiveLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ActiveLaunchPlanListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListActiveLaunchPlans(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ActiveLaunchPlanListRequest,::nebulaidl::admin::LaunchPlanList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListLaunchPlanIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListLaunchPlanIds() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NamedEntityIdentifierListRequest, ::nebulaidl::admin::NamedEntityIdentifierList>(std::bind(&WithStreamedUnaryMethod_ListLaunchPlanIds<BaseClass>::StreamedListLaunchPlanIds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListLaunchPlanIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLaunchPlanIds(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityIdentifierListRequest* request, ::nebulaidl::admin::NamedEntityIdentifierList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListLaunchPlanIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NamedEntityIdentifierListRequest,::nebulaidl::admin::NamedEntityIdentifierList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListLaunchPlans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListLaunchPlans() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::LaunchPlanList>(std::bind(&WithStreamedUnaryMethod_ListLaunchPlans<BaseClass>::StreamedListLaunchPlans, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListLaunchPlans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLaunchPlans(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::LaunchPlanList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListLaunchPlans(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ResourceListRequest,::nebulaidl::admin::LaunchPlanList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateLaunchPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateLaunchPlan() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::LaunchPlanUpdateRequest, ::nebulaidl::admin::LaunchPlanUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateLaunchPlan<BaseClass>::StreamedUpdateLaunchPlan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateLaunchPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateLaunchPlan(::grpc::ServerContext* context, const ::nebulaidl::admin::LaunchPlanUpdateRequest* request, ::nebulaidl::admin::LaunchPlanUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateLaunchPlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::LaunchPlanUpdateRequest,::nebulaidl::admin::LaunchPlanUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateExecution() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ExecutionCreateRequest, ::nebulaidl::admin::ExecutionCreateResponse>(std::bind(&WithStreamedUnaryMethod_CreateExecution<BaseClass>::StreamedCreateExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionCreateRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ExecutionCreateRequest,::nebulaidl::admin::ExecutionCreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RelaunchExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RelaunchExecution() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ExecutionRelaunchRequest, ::nebulaidl::admin::ExecutionCreateResponse>(std::bind(&WithStreamedUnaryMethod_RelaunchExecution<BaseClass>::StreamedRelaunchExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RelaunchExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RelaunchExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRelaunchRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRelaunchExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ExecutionRelaunchRequest,::nebulaidl::admin::ExecutionCreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RecoverExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RecoverExecution() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ExecutionRecoverRequest, ::nebulaidl::admin::ExecutionCreateResponse>(std::bind(&WithStreamedUnaryMethod_RecoverExecution<BaseClass>::StreamedRecoverExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RecoverExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RecoverExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionRecoverRequest* request, ::nebulaidl::admin::ExecutionCreateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecoverExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ExecutionRecoverRequest,::nebulaidl::admin::ExecutionCreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExecution() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetRequest, ::nebulaidl::admin::Execution>(std::bind(&WithStreamedUnaryMethod_GetExecution<BaseClass>::StreamedGetExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetRequest* request, ::nebulaidl::admin::Execution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowExecutionGetRequest,::nebulaidl::admin::Execution>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateExecution() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ExecutionUpdateRequest, ::nebulaidl::admin::ExecutionUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateExecution<BaseClass>::StreamedUpdateExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionUpdateRequest* request, ::nebulaidl::admin::ExecutionUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ExecutionUpdateRequest,::nebulaidl::admin::ExecutionUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExecutionData() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetDataRequest, ::nebulaidl::admin::WorkflowExecutionGetDataResponse>(std::bind(&WithStreamedUnaryMethod_GetExecutionData<BaseClass>::StreamedGetExecutionData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetDataRequest* request, ::nebulaidl::admin::WorkflowExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExecutionData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowExecutionGetDataRequest,::nebulaidl::admin::WorkflowExecutionGetDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListExecutions() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ResourceListRequest, ::nebulaidl::admin::ExecutionList>(std::bind(&WithStreamedUnaryMethod_ListExecutions<BaseClass>::StreamedListExecutions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::ResourceListRequest* request, ::nebulaidl::admin::ExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListExecutions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ResourceListRequest,::nebulaidl::admin::ExecutionList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TerminateExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TerminateExecution() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ExecutionTerminateRequest, ::nebulaidl::admin::ExecutionTerminateResponse>(std::bind(&WithStreamedUnaryMethod_TerminateExecution<BaseClass>::StreamedTerminateExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TerminateExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TerminateExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::ExecutionTerminateRequest* request, ::nebulaidl::admin::ExecutionTerminateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTerminateExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ExecutionTerminateRequest,::nebulaidl::admin::ExecutionTerminateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNodeExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetNodeExecution() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NodeExecutionGetRequest, ::nebulaidl::admin::NodeExecution>(std::bind(&WithStreamedUnaryMethod_GetNodeExecution<BaseClass>::StreamedGetNodeExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNodeExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNodeExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetRequest* request, ::nebulaidl::admin::NodeExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNodeExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NodeExecutionGetRequest,::nebulaidl::admin::NodeExecution>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListNodeExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListNodeExecutions() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NodeExecutionListRequest, ::nebulaidl::admin::NodeExecutionList>(std::bind(&WithStreamedUnaryMethod_ListNodeExecutions<BaseClass>::StreamedListNodeExecutions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListNodeExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListNodeExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListNodeExecutions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NodeExecutionListRequest,::nebulaidl::admin::NodeExecutionList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListNodeExecutionsForTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListNodeExecutionsForTask() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NodeExecutionForTaskListRequest, ::nebulaidl::admin::NodeExecutionList>(std::bind(&WithStreamedUnaryMethod_ListNodeExecutionsForTask<BaseClass>::StreamedListNodeExecutionsForTask, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListNodeExecutionsForTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListNodeExecutionsForTask(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionForTaskListRequest* request, ::nebulaidl::admin::NodeExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListNodeExecutionsForTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NodeExecutionForTaskListRequest,::nebulaidl::admin::NodeExecutionList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNodeExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetNodeExecutionData() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NodeExecutionGetDataRequest, ::nebulaidl::admin::NodeExecutionGetDataResponse>(std::bind(&WithStreamedUnaryMethod_GetNodeExecutionData<BaseClass>::StreamedGetNodeExecutionData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNodeExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNodeExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionGetDataRequest* request, ::nebulaidl::admin::NodeExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNodeExecutionData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NodeExecutionGetDataRequest,::nebulaidl::admin::NodeExecutionGetDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RegisterProject() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectRegisterRequest, ::nebulaidl::admin::ProjectRegisterResponse>(std::bind(&WithStreamedUnaryMethod_RegisterProject<BaseClass>::StreamedRegisterProject, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RegisterProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterProject(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectRegisterRequest* request, ::nebulaidl::admin::ProjectRegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectRegisterRequest,::nebulaidl::admin::ProjectRegisterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateProject() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::Project, ::nebulaidl::admin::ProjectUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateProject<BaseClass>::StreamedUpdateProject, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateProject(::grpc::ServerContext* context, const ::nebulaidl::admin::Project* request, ::nebulaidl::admin::ProjectUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::Project,::nebulaidl::admin::ProjectUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListProjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListProjects() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectListRequest, ::nebulaidl::admin::Projects>(std::bind(&WithStreamedUnaryMethod_ListProjects<BaseClass>::StreamedListProjects, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListProjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListProjects(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectListRequest* request, ::nebulaidl::admin::Projects* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListProjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectListRequest,::nebulaidl::admin::Projects>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateWorkflowEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateWorkflowEvent() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowExecutionEventRequest, ::nebulaidl::admin::WorkflowExecutionEventResponse>(std::bind(&WithStreamedUnaryMethod_CreateWorkflowEvent<BaseClass>::StreamedCreateWorkflowEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateWorkflowEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateWorkflowEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionEventRequest* request, ::nebulaidl::admin::WorkflowExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateWorkflowEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowExecutionEventRequest,::nebulaidl::admin::WorkflowExecutionEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateNodeEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateNodeEvent() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NodeExecutionEventRequest, ::nebulaidl::admin::NodeExecutionEventResponse>(std::bind(&WithStreamedUnaryMethod_CreateNodeEvent<BaseClass>::StreamedCreateNodeEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateNodeEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateNodeEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::NodeExecutionEventRequest* request, ::nebulaidl::admin::NodeExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateNodeEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NodeExecutionEventRequest,::nebulaidl::admin::NodeExecutionEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateTaskEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateTaskEvent() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::TaskExecutionEventRequest, ::nebulaidl::admin::TaskExecutionEventResponse>(std::bind(&WithStreamedUnaryMethod_CreateTaskEvent<BaseClass>::StreamedCreateTaskEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateTaskEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateTaskEvent(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionEventRequest* request, ::nebulaidl::admin::TaskExecutionEventResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateTaskEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::TaskExecutionEventRequest,::nebulaidl::admin::TaskExecutionEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTaskExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetTaskExecution() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::TaskExecutionGetRequest, ::nebulaidl::admin::TaskExecution>(std::bind(&WithStreamedUnaryMethod_GetTaskExecution<BaseClass>::StreamedGetTaskExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTaskExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTaskExecution(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetRequest* request, ::nebulaidl::admin::TaskExecution* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTaskExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::TaskExecutionGetRequest,::nebulaidl::admin::TaskExecution>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTaskExecutions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListTaskExecutions() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::TaskExecutionListRequest, ::nebulaidl::admin::TaskExecutionList>(std::bind(&WithStreamedUnaryMethod_ListTaskExecutions<BaseClass>::StreamedListTaskExecutions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListTaskExecutions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTaskExecutions(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionListRequest* request, ::nebulaidl::admin::TaskExecutionList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTaskExecutions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::TaskExecutionListRequest,::nebulaidl::admin::TaskExecutionList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTaskExecutionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetTaskExecutionData() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::TaskExecutionGetDataRequest, ::nebulaidl::admin::TaskExecutionGetDataResponse>(std::bind(&WithStreamedUnaryMethod_GetTaskExecutionData<BaseClass>::StreamedGetTaskExecutionData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTaskExecutionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTaskExecutionData(::grpc::ServerContext* context, const ::nebulaidl::admin::TaskExecutionGetDataRequest* request, ::nebulaidl::admin::TaskExecutionGetDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTaskExecutionData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::TaskExecutionGetDataRequest,::nebulaidl::admin::TaskExecutionGetDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateProjectDomainAttributes() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateProjectDomainAttributes<BaseClass>::StreamedUpdateProjectDomainAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectDomainAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateProjectDomainAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectDomainAttributesUpdateRequest,::nebulaidl::admin::ProjectDomainAttributesUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetProjectDomainAttributes() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesGetRequest, ::nebulaidl::admin::ProjectDomainAttributesGetResponse>(std::bind(&WithStreamedUnaryMethod_GetProjectDomainAttributes<BaseClass>::StreamedGetProjectDomainAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesGetRequest* request, ::nebulaidl::admin::ProjectDomainAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProjectDomainAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectDomainAttributesGetRequest,::nebulaidl::admin::ProjectDomainAttributesGetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteProjectDomainAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteProjectDomainAttributes() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>(std::bind(&WithStreamedUnaryMethod_DeleteProjectDomainAttributes<BaseClass>::StreamedDeleteProjectDomainAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteProjectDomainAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteProjectDomainAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectDomainAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteProjectDomainAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectDomainAttributesDeleteRequest,::nebulaidl::admin::ProjectDomainAttributesDeleteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateProjectAttributes() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectAttributesUpdateRequest, ::nebulaidl::admin::ProjectAttributesUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateProjectAttributes<BaseClass>::StreamedUpdateProjectAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesUpdateRequest* request, ::nebulaidl::admin::ProjectAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateProjectAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectAttributesUpdateRequest,::nebulaidl::admin::ProjectAttributesUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetProjectAttributes() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectAttributesGetRequest, ::nebulaidl::admin::ProjectAttributesGetResponse>(std::bind(&WithStreamedUnaryMethod_GetProjectAttributes<BaseClass>::StreamedGetProjectAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesGetRequest* request, ::nebulaidl::admin::ProjectAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProjectAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectAttributesGetRequest,::nebulaidl::admin::ProjectAttributesGetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteProjectAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteProjectAttributes() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ProjectAttributesDeleteRequest, ::nebulaidl::admin::ProjectAttributesDeleteResponse>(std::bind(&WithStreamedUnaryMethod_DeleteProjectAttributes<BaseClass>::StreamedDeleteProjectAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteProjectAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteProjectAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ProjectAttributesDeleteRequest* request, ::nebulaidl::admin::ProjectAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteProjectAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ProjectAttributesDeleteRequest,::nebulaidl::admin::ProjectAttributesDeleteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateWorkflowAttributes() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowAttributesUpdateRequest, ::nebulaidl::admin::WorkflowAttributesUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateWorkflowAttributes<BaseClass>::StreamedUpdateWorkflowAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesUpdateRequest* request, ::nebulaidl::admin::WorkflowAttributesUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateWorkflowAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowAttributesUpdateRequest,::nebulaidl::admin::WorkflowAttributesUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetWorkflowAttributes() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowAttributesGetRequest, ::nebulaidl::admin::WorkflowAttributesGetResponse>(std::bind(&WithStreamedUnaryMethod_GetWorkflowAttributes<BaseClass>::StreamedGetWorkflowAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesGetRequest* request, ::nebulaidl::admin::WorkflowAttributesGetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkflowAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowAttributesGetRequest,::nebulaidl::admin::WorkflowAttributesGetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteWorkflowAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteWorkflowAttributes() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowAttributesDeleteRequest, ::nebulaidl::admin::WorkflowAttributesDeleteResponse>(std::bind(&WithStreamedUnaryMethod_DeleteWorkflowAttributes<BaseClass>::StreamedDeleteWorkflowAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteWorkflowAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteWorkflowAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowAttributesDeleteRequest* request, ::nebulaidl::admin::WorkflowAttributesDeleteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteWorkflowAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowAttributesDeleteRequest,::nebulaidl::admin::WorkflowAttributesDeleteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMatchableAttributes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListMatchableAttributes() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ListMatchableAttributesRequest, ::nebulaidl::admin::ListMatchableAttributesResponse>(std::bind(&WithStreamedUnaryMethod_ListMatchableAttributes<BaseClass>::StreamedListMatchableAttributes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListMatchableAttributes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMatchableAttributes(::grpc::ServerContext* context, const ::nebulaidl::admin::ListMatchableAttributesRequest* request, ::nebulaidl::admin::ListMatchableAttributesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMatchableAttributes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ListMatchableAttributesRequest,::nebulaidl::admin::ListMatchableAttributesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListNamedEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListNamedEntities() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NamedEntityListRequest, ::nebulaidl::admin::NamedEntityList>(std::bind(&WithStreamedUnaryMethod_ListNamedEntities<BaseClass>::StreamedListNamedEntities, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListNamedEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListNamedEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityListRequest* request, ::nebulaidl::admin::NamedEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListNamedEntities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NamedEntityListRequest,::nebulaidl::admin::NamedEntityList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetNamedEntity() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NamedEntityGetRequest, ::nebulaidl::admin::NamedEntity>(std::bind(&WithStreamedUnaryMethod_GetNamedEntity<BaseClass>::StreamedGetNamedEntity, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityGetRequest* request, ::nebulaidl::admin::NamedEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNamedEntity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NamedEntityGetRequest,::nebulaidl::admin::NamedEntity>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateNamedEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateNamedEntity() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::NamedEntityUpdateRequest, ::nebulaidl::admin::NamedEntityUpdateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateNamedEntity<BaseClass>::StreamedUpdateNamedEntity, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateNamedEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateNamedEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::NamedEntityUpdateRequest* request, ::nebulaidl::admin::NamedEntityUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateNamedEntity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::NamedEntityUpdateRequest,::nebulaidl::admin::NamedEntityUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::GetVersionRequest, ::nebulaidl::admin::GetVersionResponse>(std::bind(&WithStreamedUnaryMethod_GetVersion<BaseClass>::StreamedGetVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::nebulaidl::admin::GetVersionRequest* request, ::nebulaidl::admin::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::GetVersionRequest,::nebulaidl::admin::GetVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDescriptionEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetDescriptionEntity() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::ObjectGetRequest, ::nebulaidl::admin::DescriptionEntity>(std::bind(&WithStreamedUnaryMethod_GetDescriptionEntity<BaseClass>::StreamedGetDescriptionEntity, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDescriptionEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDescriptionEntity(::grpc::ServerContext* context, const ::nebulaidl::admin::ObjectGetRequest* request, ::nebulaidl::admin::DescriptionEntity* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDescriptionEntity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::ObjectGetRequest,::nebulaidl::admin::DescriptionEntity>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDescriptionEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListDescriptionEntities() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::DescriptionEntityListRequest, ::nebulaidl::admin::DescriptionEntityList>(std::bind(&WithStreamedUnaryMethod_ListDescriptionEntities<BaseClass>::StreamedListDescriptionEntities, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListDescriptionEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDescriptionEntities(::grpc::ServerContext* context, const ::nebulaidl::admin::DescriptionEntityListRequest* request, ::nebulaidl::admin::DescriptionEntityList* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDescriptionEntities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::DescriptionEntityListRequest,::nebulaidl::admin::DescriptionEntityList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExecutionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExecutionMetrics() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler< ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>(std::bind(&WithStreamedUnaryMethod_GetExecutionMetrics<BaseClass>::StreamedGetExecutionMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExecutionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExecutionMetrics(::grpc::ServerContext* context, const ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest* request, ::nebulaidl::admin::WorkflowExecutionGetMetricsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExecutionMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nebulaidl::admin::WorkflowExecutionGetMetricsRequest,::nebulaidl::admin::WorkflowExecutionGetMetricsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateTask<WithStreamedUnaryMethod_GetTask<WithStreamedUnaryMethod_ListTaskIds<WithStreamedUnaryMethod_ListTasks<WithStreamedUnaryMethod_CreateWorkflow<WithStreamedUnaryMethod_GetWorkflow<WithStreamedUnaryMethod_ListWorkflowIds<WithStreamedUnaryMethod_ListWorkflows<WithStreamedUnaryMethod_CreateLaunchPlan<WithStreamedUnaryMethod_GetLaunchPlan<WithStreamedUnaryMethod_GetActiveLaunchPlan<WithStreamedUnaryMethod_ListActiveLaunchPlans<WithStreamedUnaryMethod_ListLaunchPlanIds<WithStreamedUnaryMethod_ListLaunchPlans<WithStreamedUnaryMethod_UpdateLaunchPlan<WithStreamedUnaryMethod_CreateExecution<WithStreamedUnaryMethod_RelaunchExecution<WithStreamedUnaryMethod_RecoverExecution<WithStreamedUnaryMethod_GetExecution<WithStreamedUnaryMethod_UpdateExecution<WithStreamedUnaryMethod_GetExecutionData<WithStreamedUnaryMethod_ListExecutions<WithStreamedUnaryMethod_TerminateExecution<WithStreamedUnaryMethod_GetNodeExecution<WithStreamedUnaryMethod_ListNodeExecutions<WithStreamedUnaryMethod_ListNodeExecutionsForTask<WithStreamedUnaryMethod_GetNodeExecutionData<WithStreamedUnaryMethod_RegisterProject<WithStreamedUnaryMethod_UpdateProject<WithStreamedUnaryMethod_ListProjects<WithStreamedUnaryMethod_CreateWorkflowEvent<WithStreamedUnaryMethod_CreateNodeEvent<WithStreamedUnaryMethod_CreateTaskEvent<WithStreamedUnaryMethod_GetTaskExecution<WithStreamedUnaryMethod_ListTaskExecutions<WithStreamedUnaryMethod_GetTaskExecutionData<WithStreamedUnaryMethod_UpdateProjectDomainAttributes<WithStreamedUnaryMethod_GetProjectDomainAttributes<WithStreamedUnaryMethod_DeleteProjectDomainAttributes<WithStreamedUnaryMethod_UpdateProjectAttributes<WithStreamedUnaryMethod_GetProjectAttributes<WithStreamedUnaryMethod_DeleteProjectAttributes<WithStreamedUnaryMethod_UpdateWorkflowAttributes<WithStreamedUnaryMethod_GetWorkflowAttributes<WithStreamedUnaryMethod_DeleteWorkflowAttributes<WithStreamedUnaryMethod_ListMatchableAttributes<WithStreamedUnaryMethod_ListNamedEntities<WithStreamedUnaryMethod_GetNamedEntity<WithStreamedUnaryMethod_UpdateNamedEntity<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetDescriptionEntity<WithStreamedUnaryMethod_ListDescriptionEntities<WithStreamedUnaryMethod_GetExecutionMetrics<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateTask<WithStreamedUnaryMethod_GetTask<WithStreamedUnaryMethod_ListTaskIds<WithStreamedUnaryMethod_ListTasks<WithStreamedUnaryMethod_CreateWorkflow<WithStreamedUnaryMethod_GetWorkflow<WithStreamedUnaryMethod_ListWorkflowIds<WithStreamedUnaryMethod_ListWorkflows<WithStreamedUnaryMethod_CreateLaunchPlan<WithStreamedUnaryMethod_GetLaunchPlan<WithStreamedUnaryMethod_GetActiveLaunchPlan<WithStreamedUnaryMethod_ListActiveLaunchPlans<WithStreamedUnaryMethod_ListLaunchPlanIds<WithStreamedUnaryMethod_ListLaunchPlans<WithStreamedUnaryMethod_UpdateLaunchPlan<WithStreamedUnaryMethod_CreateExecution<WithStreamedUnaryMethod_RelaunchExecution<WithStreamedUnaryMethod_RecoverExecution<WithStreamedUnaryMethod_GetExecution<WithStreamedUnaryMethod_UpdateExecution<WithStreamedUnaryMethod_GetExecutionData<WithStreamedUnaryMethod_ListExecutions<WithStreamedUnaryMethod_TerminateExecution<WithStreamedUnaryMethod_GetNodeExecution<WithStreamedUnaryMethod_ListNodeExecutions<WithStreamedUnaryMethod_ListNodeExecutionsForTask<WithStreamedUnaryMethod_GetNodeExecutionData<WithStreamedUnaryMethod_RegisterProject<WithStreamedUnaryMethod_UpdateProject<WithStreamedUnaryMethod_ListProjects<WithStreamedUnaryMethod_CreateWorkflowEvent<WithStreamedUnaryMethod_CreateNodeEvent<WithStreamedUnaryMethod_CreateTaskEvent<WithStreamedUnaryMethod_GetTaskExecution<WithStreamedUnaryMethod_ListTaskExecutions<WithStreamedUnaryMethod_GetTaskExecutionData<WithStreamedUnaryMethod_UpdateProjectDomainAttributes<WithStreamedUnaryMethod_GetProjectDomainAttributes<WithStreamedUnaryMethod_DeleteProjectDomainAttributes<WithStreamedUnaryMethod_UpdateProjectAttributes<WithStreamedUnaryMethod_GetProjectAttributes<WithStreamedUnaryMethod_DeleteProjectAttributes<WithStreamedUnaryMethod_UpdateWorkflowAttributes<WithStreamedUnaryMethod_GetWorkflowAttributes<WithStreamedUnaryMethod_DeleteWorkflowAttributes<WithStreamedUnaryMethod_ListMatchableAttributes<WithStreamedUnaryMethod_ListNamedEntities<WithStreamedUnaryMethod_GetNamedEntity<WithStreamedUnaryMethod_UpdateNamedEntity<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetDescriptionEntity<WithStreamedUnaryMethod_ListDescriptionEntities<WithStreamedUnaryMethod_GetExecutionMetrics<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace service
}  // namespace nebulaidl


#endif  // GRPC_nebulaidl_2fservice_2fadmin_2eproto__INCLUDED
