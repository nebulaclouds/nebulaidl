// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nebulaidl/admin/workflow.proto

#ifndef PROTOBUF_INCLUDED_nebulaidl_2fadmin_2fworkflow_2eproto
#define PROTOBUF_INCLUDED_nebulaidl_2fadmin_2fworkflow_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "nebulaidl/core/compiler.pb.h"
#include "nebulaidl/core/identifier.pb.h"
#include "nebulaidl/core/workflow.pb.h"
#include "nebulaidl/admin/description_entity.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nebulaidl_2fadmin_2fworkflow_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_nebulaidl_2fadmin_2fworkflow_2eproto();
namespace nebulaidl {
namespace admin {
class CreateWorkflowFailureReason;
class CreateWorkflowFailureReasonDefaultTypeInternal;
extern CreateWorkflowFailureReasonDefaultTypeInternal _CreateWorkflowFailureReason_default_instance_;
class Workflow;
class WorkflowDefaultTypeInternal;
extern WorkflowDefaultTypeInternal _Workflow_default_instance_;
class WorkflowClosure;
class WorkflowClosureDefaultTypeInternal;
extern WorkflowClosureDefaultTypeInternal _WorkflowClosure_default_instance_;
class WorkflowCreateRequest;
class WorkflowCreateRequestDefaultTypeInternal;
extern WorkflowCreateRequestDefaultTypeInternal _WorkflowCreateRequest_default_instance_;
class WorkflowCreateResponse;
class WorkflowCreateResponseDefaultTypeInternal;
extern WorkflowCreateResponseDefaultTypeInternal _WorkflowCreateResponse_default_instance_;
class WorkflowErrorExistsDifferentStructure;
class WorkflowErrorExistsDifferentStructureDefaultTypeInternal;
extern WorkflowErrorExistsDifferentStructureDefaultTypeInternal _WorkflowErrorExistsDifferentStructure_default_instance_;
class WorkflowErrorExistsIdenticalStructure;
class WorkflowErrorExistsIdenticalStructureDefaultTypeInternal;
extern WorkflowErrorExistsIdenticalStructureDefaultTypeInternal _WorkflowErrorExistsIdenticalStructure_default_instance_;
class WorkflowList;
class WorkflowListDefaultTypeInternal;
extern WorkflowListDefaultTypeInternal _WorkflowList_default_instance_;
class WorkflowSpec;
class WorkflowSpecDefaultTypeInternal;
extern WorkflowSpecDefaultTypeInternal _WorkflowSpec_default_instance_;
}  // namespace admin
}  // namespace nebulaidl
namespace google {
namespace protobuf {
template<> ::nebulaidl::admin::CreateWorkflowFailureReason* Arena::CreateMaybeMessage<::nebulaidl::admin::CreateWorkflowFailureReason>(Arena*);
template<> ::nebulaidl::admin::Workflow* Arena::CreateMaybeMessage<::nebulaidl::admin::Workflow>(Arena*);
template<> ::nebulaidl::admin::WorkflowClosure* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowClosure>(Arena*);
template<> ::nebulaidl::admin::WorkflowCreateRequest* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowCreateRequest>(Arena*);
template<> ::nebulaidl::admin::WorkflowCreateResponse* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowCreateResponse>(Arena*);
template<> ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowErrorExistsDifferentStructure>(Arena*);
template<> ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure>(Arena*);
template<> ::nebulaidl::admin::WorkflowList* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowList>(Arena*);
template<> ::nebulaidl::admin::WorkflowSpec* Arena::CreateMaybeMessage<::nebulaidl::admin::WorkflowSpec>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nebulaidl {
namespace admin {

// ===================================================================

class WorkflowCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowCreateRequest) */ {
 public:
  WorkflowCreateRequest();
  virtual ~WorkflowCreateRequest();

  WorkflowCreateRequest(const WorkflowCreateRequest& from);

  inline WorkflowCreateRequest& operator=(const WorkflowCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowCreateRequest(WorkflowCreateRequest&& from) noexcept
    : WorkflowCreateRequest() {
    *this = ::std::move(from);
  }

  inline WorkflowCreateRequest& operator=(WorkflowCreateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowCreateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowCreateRequest* internal_default_instance() {
    return reinterpret_cast<const WorkflowCreateRequest*>(
               &_WorkflowCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(WorkflowCreateRequest* other);
  friend void swap(WorkflowCreateRequest& a, WorkflowCreateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowCreateRequest* New() const final {
    return CreateMaybeMessage<WorkflowCreateRequest>(nullptr);
  }

  WorkflowCreateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowCreateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowCreateRequest& from);
  void MergeFrom(const WorkflowCreateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowCreateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::nebulaidl::core::Identifier& id() const;
  ::nebulaidl::core::Identifier* release_id();
  ::nebulaidl::core::Identifier* mutable_id();
  void set_allocated_id(::nebulaidl::core::Identifier* id);

  // .nebulaidl.admin.WorkflowSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::nebulaidl::admin::WorkflowSpec& spec() const;
  ::nebulaidl::admin::WorkflowSpec* release_spec();
  ::nebulaidl::admin::WorkflowSpec* mutable_spec();
  void set_allocated_spec(::nebulaidl::admin::WorkflowSpec* spec);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowCreateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::Identifier* id_;
  ::nebulaidl::admin::WorkflowSpec* spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class WorkflowCreateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowCreateResponse) */ {
 public:
  WorkflowCreateResponse();
  virtual ~WorkflowCreateResponse();

  WorkflowCreateResponse(const WorkflowCreateResponse& from);

  inline WorkflowCreateResponse& operator=(const WorkflowCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowCreateResponse(WorkflowCreateResponse&& from) noexcept
    : WorkflowCreateResponse() {
    *this = ::std::move(from);
  }

  inline WorkflowCreateResponse& operator=(WorkflowCreateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowCreateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowCreateResponse* internal_default_instance() {
    return reinterpret_cast<const WorkflowCreateResponse*>(
               &_WorkflowCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WorkflowCreateResponse* other);
  friend void swap(WorkflowCreateResponse& a, WorkflowCreateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowCreateResponse* New() const final {
    return CreateMaybeMessage<WorkflowCreateResponse>(nullptr);
  }

  WorkflowCreateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowCreateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowCreateResponse& from);
  void MergeFrom(const WorkflowCreateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowCreateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowCreateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class Workflow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.Workflow) */ {
 public:
  Workflow();
  virtual ~Workflow();

  Workflow(const Workflow& from);

  inline Workflow& operator=(const Workflow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Workflow(Workflow&& from) noexcept
    : Workflow() {
    *this = ::std::move(from);
  }

  inline Workflow& operator=(Workflow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Workflow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Workflow* internal_default_instance() {
    return reinterpret_cast<const Workflow*>(
               &_Workflow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Workflow* other);
  friend void swap(Workflow& a, Workflow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Workflow* New() const final {
    return CreateMaybeMessage<Workflow>(nullptr);
  }

  Workflow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Workflow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Workflow& from);
  void MergeFrom(const Workflow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Workflow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string short_description = 3;
  void clear_short_description();
  static const int kShortDescriptionFieldNumber = 3;
  const ::std::string& short_description() const;
  void set_short_description(const ::std::string& value);
  #if LANG_CXX11
  void set_short_description(::std::string&& value);
  #endif
  void set_short_description(const char* value);
  void set_short_description(const char* value, size_t size);
  ::std::string* mutable_short_description();
  ::std::string* release_short_description();
  void set_allocated_short_description(::std::string* short_description);

  // .nebulaidl.core.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::nebulaidl::core::Identifier& id() const;
  ::nebulaidl::core::Identifier* release_id();
  ::nebulaidl::core::Identifier* mutable_id();
  void set_allocated_id(::nebulaidl::core::Identifier* id);

  // .nebulaidl.admin.WorkflowClosure closure = 2;
  bool has_closure() const;
  void clear_closure();
  static const int kClosureFieldNumber = 2;
  const ::nebulaidl::admin::WorkflowClosure& closure() const;
  ::nebulaidl::admin::WorkflowClosure* release_closure();
  ::nebulaidl::admin::WorkflowClosure* mutable_closure();
  void set_allocated_closure(::nebulaidl::admin::WorkflowClosure* closure);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.Workflow)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr short_description_;
  ::nebulaidl::core::Identifier* id_;
  ::nebulaidl::admin::WorkflowClosure* closure_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class WorkflowList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowList) */ {
 public:
  WorkflowList();
  virtual ~WorkflowList();

  WorkflowList(const WorkflowList& from);

  inline WorkflowList& operator=(const WorkflowList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowList(WorkflowList&& from) noexcept
    : WorkflowList() {
    *this = ::std::move(from);
  }

  inline WorkflowList& operator=(WorkflowList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowList* internal_default_instance() {
    return reinterpret_cast<const WorkflowList*>(
               &_WorkflowList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(WorkflowList* other);
  friend void swap(WorkflowList& a, WorkflowList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowList* New() const final {
    return CreateMaybeMessage<WorkflowList>(nullptr);
  }

  WorkflowList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowList& from);
  void MergeFrom(const WorkflowList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.admin.Workflow workflows = 1;
  int workflows_size() const;
  void clear_workflows();
  static const int kWorkflowsFieldNumber = 1;
  ::nebulaidl::admin::Workflow* mutable_workflows(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::admin::Workflow >*
      mutable_workflows();
  const ::nebulaidl::admin::Workflow& workflows(int index) const;
  ::nebulaidl::admin::Workflow* add_workflows();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::admin::Workflow >&
      workflows() const;

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::admin::Workflow > workflows_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class WorkflowSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowSpec) */ {
 public:
  WorkflowSpec();
  virtual ~WorkflowSpec();

  WorkflowSpec(const WorkflowSpec& from);

  inline WorkflowSpec& operator=(const WorkflowSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowSpec(WorkflowSpec&& from) noexcept
    : WorkflowSpec() {
    *this = ::std::move(from);
  }

  inline WorkflowSpec& operator=(WorkflowSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowSpec* internal_default_instance() {
    return reinterpret_cast<const WorkflowSpec*>(
               &_WorkflowSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WorkflowSpec* other);
  friend void swap(WorkflowSpec& a, WorkflowSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowSpec* New() const final {
    return CreateMaybeMessage<WorkflowSpec>(nullptr);
  }

  WorkflowSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowSpec& from);
  void MergeFrom(const WorkflowSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.WorkflowTemplate sub_workflows = 2;
  int sub_workflows_size() const;
  void clear_sub_workflows();
  static const int kSubWorkflowsFieldNumber = 2;
  ::nebulaidl::core::WorkflowTemplate* mutable_sub_workflows(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::WorkflowTemplate >*
      mutable_sub_workflows();
  const ::nebulaidl::core::WorkflowTemplate& sub_workflows(int index) const;
  ::nebulaidl::core::WorkflowTemplate* add_sub_workflows();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::WorkflowTemplate >&
      sub_workflows() const;

  // .nebulaidl.core.WorkflowTemplate template = 1;
  bool has_template_() const;
  void clear_template_();
  static const int kTemplateFieldNumber = 1;
  const ::nebulaidl::core::WorkflowTemplate& template_() const;
  ::nebulaidl::core::WorkflowTemplate* release_template_();
  ::nebulaidl::core::WorkflowTemplate* mutable_template_();
  void set_allocated_template_(::nebulaidl::core::WorkflowTemplate* template_);

  // .nebulaidl.admin.DescriptionEntity description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::nebulaidl::admin::DescriptionEntity& description() const;
  ::nebulaidl::admin::DescriptionEntity* release_description();
  ::nebulaidl::admin::DescriptionEntity* mutable_description();
  void set_allocated_description(::nebulaidl::admin::DescriptionEntity* description);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::WorkflowTemplate > sub_workflows_;
  ::nebulaidl::core::WorkflowTemplate* template__;
  ::nebulaidl::admin::DescriptionEntity* description_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class WorkflowClosure final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowClosure) */ {
 public:
  WorkflowClosure();
  virtual ~WorkflowClosure();

  WorkflowClosure(const WorkflowClosure& from);

  inline WorkflowClosure& operator=(const WorkflowClosure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowClosure(WorkflowClosure&& from) noexcept
    : WorkflowClosure() {
    *this = ::std::move(from);
  }

  inline WorkflowClosure& operator=(WorkflowClosure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowClosure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowClosure* internal_default_instance() {
    return reinterpret_cast<const WorkflowClosure*>(
               &_WorkflowClosure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(WorkflowClosure* other);
  friend void swap(WorkflowClosure& a, WorkflowClosure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowClosure* New() const final {
    return CreateMaybeMessage<WorkflowClosure>(nullptr);
  }

  WorkflowClosure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowClosure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowClosure& from);
  void MergeFrom(const WorkflowClosure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowClosure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.CompiledWorkflowClosure compiled_workflow = 1;
  bool has_compiled_workflow() const;
  void clear_compiled_workflow();
  static const int kCompiledWorkflowFieldNumber = 1;
  const ::nebulaidl::core::CompiledWorkflowClosure& compiled_workflow() const;
  ::nebulaidl::core::CompiledWorkflowClosure* release_compiled_workflow();
  ::nebulaidl::core::CompiledWorkflowClosure* mutable_compiled_workflow();
  void set_allocated_compiled_workflow(::nebulaidl::core::CompiledWorkflowClosure* compiled_workflow);

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 2;
  const ::google::protobuf::Timestamp& created_at() const;
  ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* created_at);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowClosure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::CompiledWorkflowClosure* compiled_workflow_;
  ::google::protobuf::Timestamp* created_at_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class WorkflowErrorExistsDifferentStructure final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowErrorExistsDifferentStructure) */ {
 public:
  WorkflowErrorExistsDifferentStructure();
  virtual ~WorkflowErrorExistsDifferentStructure();

  WorkflowErrorExistsDifferentStructure(const WorkflowErrorExistsDifferentStructure& from);

  inline WorkflowErrorExistsDifferentStructure& operator=(const WorkflowErrorExistsDifferentStructure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowErrorExistsDifferentStructure(WorkflowErrorExistsDifferentStructure&& from) noexcept
    : WorkflowErrorExistsDifferentStructure() {
    *this = ::std::move(from);
  }

  inline WorkflowErrorExistsDifferentStructure& operator=(WorkflowErrorExistsDifferentStructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowErrorExistsDifferentStructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowErrorExistsDifferentStructure* internal_default_instance() {
    return reinterpret_cast<const WorkflowErrorExistsDifferentStructure*>(
               &_WorkflowErrorExistsDifferentStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WorkflowErrorExistsDifferentStructure* other);
  friend void swap(WorkflowErrorExistsDifferentStructure& a, WorkflowErrorExistsDifferentStructure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowErrorExistsDifferentStructure* New() const final {
    return CreateMaybeMessage<WorkflowErrorExistsDifferentStructure>(nullptr);
  }

  WorkflowErrorExistsDifferentStructure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowErrorExistsDifferentStructure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowErrorExistsDifferentStructure& from);
  void MergeFrom(const WorkflowErrorExistsDifferentStructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowErrorExistsDifferentStructure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::nebulaidl::core::Identifier& id() const;
  ::nebulaidl::core::Identifier* release_id();
  ::nebulaidl::core::Identifier* mutable_id();
  void set_allocated_id(::nebulaidl::core::Identifier* id);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowErrorExistsDifferentStructure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::Identifier* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class WorkflowErrorExistsIdenticalStructure final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.WorkflowErrorExistsIdenticalStructure) */ {
 public:
  WorkflowErrorExistsIdenticalStructure();
  virtual ~WorkflowErrorExistsIdenticalStructure();

  WorkflowErrorExistsIdenticalStructure(const WorkflowErrorExistsIdenticalStructure& from);

  inline WorkflowErrorExistsIdenticalStructure& operator=(const WorkflowErrorExistsIdenticalStructure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowErrorExistsIdenticalStructure(WorkflowErrorExistsIdenticalStructure&& from) noexcept
    : WorkflowErrorExistsIdenticalStructure() {
    *this = ::std::move(from);
  }

  inline WorkflowErrorExistsIdenticalStructure& operator=(WorkflowErrorExistsIdenticalStructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowErrorExistsIdenticalStructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowErrorExistsIdenticalStructure* internal_default_instance() {
    return reinterpret_cast<const WorkflowErrorExistsIdenticalStructure*>(
               &_WorkflowErrorExistsIdenticalStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WorkflowErrorExistsIdenticalStructure* other);
  friend void swap(WorkflowErrorExistsIdenticalStructure& a, WorkflowErrorExistsIdenticalStructure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowErrorExistsIdenticalStructure* New() const final {
    return CreateMaybeMessage<WorkflowErrorExistsIdenticalStructure>(nullptr);
  }

  WorkflowErrorExistsIdenticalStructure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowErrorExistsIdenticalStructure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowErrorExistsIdenticalStructure& from);
  void MergeFrom(const WorkflowErrorExistsIdenticalStructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowErrorExistsIdenticalStructure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.Identifier id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::nebulaidl::core::Identifier& id() const;
  ::nebulaidl::core::Identifier* release_id();
  ::nebulaidl::core::Identifier* mutable_id();
  void set_allocated_id(::nebulaidl::core::Identifier* id);

  // @@protoc_insertion_point(class_scope:nebulaidl.admin.WorkflowErrorExistsIdenticalStructure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::Identifier* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// -------------------------------------------------------------------

class CreateWorkflowFailureReason final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.admin.CreateWorkflowFailureReason) */ {
 public:
  CreateWorkflowFailureReason();
  virtual ~CreateWorkflowFailureReason();

  CreateWorkflowFailureReason(const CreateWorkflowFailureReason& from);

  inline CreateWorkflowFailureReason& operator=(const CreateWorkflowFailureReason& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateWorkflowFailureReason(CreateWorkflowFailureReason&& from) noexcept
    : CreateWorkflowFailureReason() {
    *this = ::std::move(from);
  }

  inline CreateWorkflowFailureReason& operator=(CreateWorkflowFailureReason&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateWorkflowFailureReason& default_instance();

  enum ReasonCase {
    kExistsDifferentStructure = 1,
    kExistsIdenticalStructure = 2,
    REASON_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateWorkflowFailureReason* internal_default_instance() {
    return reinterpret_cast<const CreateWorkflowFailureReason*>(
               &_CreateWorkflowFailureReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CreateWorkflowFailureReason* other);
  friend void swap(CreateWorkflowFailureReason& a, CreateWorkflowFailureReason& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateWorkflowFailureReason* New() const final {
    return CreateMaybeMessage<CreateWorkflowFailureReason>(nullptr);
  }

  CreateWorkflowFailureReason* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateWorkflowFailureReason>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateWorkflowFailureReason& from);
  void MergeFrom(const CreateWorkflowFailureReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateWorkflowFailureReason* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.admin.WorkflowErrorExistsDifferentStructure exists_different_structure = 1;
  bool has_exists_different_structure() const;
  void clear_exists_different_structure();
  static const int kExistsDifferentStructureFieldNumber = 1;
  const ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure& exists_different_structure() const;
  ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* release_exists_different_structure();
  ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* mutable_exists_different_structure();
  void set_allocated_exists_different_structure(::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* exists_different_structure);

  // .nebulaidl.admin.WorkflowErrorExistsIdenticalStructure exists_identical_structure = 2;
  bool has_exists_identical_structure() const;
  void clear_exists_identical_structure();
  static const int kExistsIdenticalStructureFieldNumber = 2;
  const ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure& exists_identical_structure() const;
  ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* release_exists_identical_structure();
  ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* mutable_exists_identical_structure();
  void set_allocated_exists_identical_structure(::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* exists_identical_structure);

  void clear_reason();
  ReasonCase reason_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.admin.CreateWorkflowFailureReason)
 private:
  class HasBitSetters;
  void set_has_exists_different_structure();
  void set_has_exists_identical_structure();

  inline bool has_reason() const;
  inline void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ReasonUnion {
    ReasonUnion() {}
    ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* exists_different_structure_;
    ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* exists_identical_structure_;
  } reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fadmin_2fworkflow_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WorkflowCreateRequest

// .nebulaidl.core.Identifier id = 1;
inline bool WorkflowCreateRequest::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::nebulaidl::core::Identifier& WorkflowCreateRequest::id() const {
  const ::nebulaidl::core::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowCreateRequest.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::Identifier*>(
      &::nebulaidl::core::_Identifier_default_instance_);
}
inline ::nebulaidl::core::Identifier* WorkflowCreateRequest::release_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowCreateRequest.id)
  
  ::nebulaidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::Identifier* WorkflowCreateRequest::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowCreateRequest.id)
  return id_;
}
inline void WorkflowCreateRequest::set_allocated_id(::nebulaidl::core::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowCreateRequest.id)
}

// .nebulaidl.admin.WorkflowSpec spec = 2;
inline bool WorkflowCreateRequest::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void WorkflowCreateRequest::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::nebulaidl::admin::WorkflowSpec& WorkflowCreateRequest::spec() const {
  const ::nebulaidl::admin::WorkflowSpec* p = spec_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowCreateRequest.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::admin::WorkflowSpec*>(
      &::nebulaidl::admin::_WorkflowSpec_default_instance_);
}
inline ::nebulaidl::admin::WorkflowSpec* WorkflowCreateRequest::release_spec() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowCreateRequest.spec)
  
  ::nebulaidl::admin::WorkflowSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::nebulaidl::admin::WorkflowSpec* WorkflowCreateRequest::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::admin::WorkflowSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowCreateRequest.spec)
  return spec_;
}
inline void WorkflowCreateRequest::set_allocated_spec(::nebulaidl::admin::WorkflowSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowCreateRequest.spec)
}

// -------------------------------------------------------------------

// WorkflowCreateResponse

// -------------------------------------------------------------------

// Workflow

// .nebulaidl.core.Identifier id = 1;
inline bool Workflow::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::nebulaidl::core::Identifier& Workflow::id() const {
  const ::nebulaidl::core::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.Workflow.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::Identifier*>(
      &::nebulaidl::core::_Identifier_default_instance_);
}
inline ::nebulaidl::core::Identifier* Workflow::release_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.Workflow.id)
  
  ::nebulaidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::Identifier* Workflow::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.Workflow.id)
  return id_;
}
inline void Workflow::set_allocated_id(::nebulaidl::core::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.Workflow.id)
}

// .nebulaidl.admin.WorkflowClosure closure = 2;
inline bool Workflow::has_closure() const {
  return this != internal_default_instance() && closure_ != nullptr;
}
inline void Workflow::clear_closure() {
  if (GetArenaNoVirtual() == nullptr && closure_ != nullptr) {
    delete closure_;
  }
  closure_ = nullptr;
}
inline const ::nebulaidl::admin::WorkflowClosure& Workflow::closure() const {
  const ::nebulaidl::admin::WorkflowClosure* p = closure_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.Workflow.closure)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::admin::WorkflowClosure*>(
      &::nebulaidl::admin::_WorkflowClosure_default_instance_);
}
inline ::nebulaidl::admin::WorkflowClosure* Workflow::release_closure() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.Workflow.closure)
  
  ::nebulaidl::admin::WorkflowClosure* temp = closure_;
  closure_ = nullptr;
  return temp;
}
inline ::nebulaidl::admin::WorkflowClosure* Workflow::mutable_closure() {
  
  if (closure_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::admin::WorkflowClosure>(GetArenaNoVirtual());
    closure_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.Workflow.closure)
  return closure_;
}
inline void Workflow::set_allocated_closure(::nebulaidl::admin::WorkflowClosure* closure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete closure_;
  }
  if (closure) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      closure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, closure, submessage_arena);
    }
    
  } else {
    
  }
  closure_ = closure;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.Workflow.closure)
}

// string short_description = 3;
inline void Workflow::clear_short_description() {
  short_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Workflow::short_description() const {
  // @@protoc_insertion_point(field_get:nebulaidl.admin.Workflow.short_description)
  return short_description_.GetNoArena();
}
inline void Workflow::set_short_description(const ::std::string& value) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.admin.Workflow.short_description)
}
#if LANG_CXX11
inline void Workflow::set_short_description(::std::string&& value) {
  
  short_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.admin.Workflow.short_description)
}
#endif
inline void Workflow::set_short_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.admin.Workflow.short_description)
}
inline void Workflow::set_short_description(const char* value, size_t size) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.admin.Workflow.short_description)
}
inline ::std::string* Workflow::mutable_short_description() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.Workflow.short_description)
  return short_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Workflow::release_short_description() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.Workflow.short_description)
  
  return short_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Workflow::set_allocated_short_description(::std::string* short_description) {
  if (short_description != nullptr) {
    
  } else {
    
  }
  short_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), short_description);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.Workflow.short_description)
}

// -------------------------------------------------------------------

// WorkflowList

// repeated .nebulaidl.admin.Workflow workflows = 1;
inline int WorkflowList::workflows_size() const {
  return workflows_.size();
}
inline void WorkflowList::clear_workflows() {
  workflows_.Clear();
}
inline ::nebulaidl::admin::Workflow* WorkflowList::mutable_workflows(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowList.workflows)
  return workflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::admin::Workflow >*
WorkflowList::mutable_workflows() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.admin.WorkflowList.workflows)
  return &workflows_;
}
inline const ::nebulaidl::admin::Workflow& WorkflowList::workflows(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowList.workflows)
  return workflows_.Get(index);
}
inline ::nebulaidl::admin::Workflow* WorkflowList::add_workflows() {
  // @@protoc_insertion_point(field_add:nebulaidl.admin.WorkflowList.workflows)
  return workflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::admin::Workflow >&
WorkflowList::workflows() const {
  // @@protoc_insertion_point(field_list:nebulaidl.admin.WorkflowList.workflows)
  return workflows_;
}

// string token = 2;
inline void WorkflowList::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowList::token() const {
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowList.token)
  return token_.GetNoArena();
}
inline void WorkflowList::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.admin.WorkflowList.token)
}
#if LANG_CXX11
inline void WorkflowList::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.admin.WorkflowList.token)
}
#endif
inline void WorkflowList::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.admin.WorkflowList.token)
}
inline void WorkflowList::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.admin.WorkflowList.token)
}
inline ::std::string* WorkflowList::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowList.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowList::release_token() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowList.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowList::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowList.token)
}

// -------------------------------------------------------------------

// WorkflowSpec

// .nebulaidl.core.WorkflowTemplate template = 1;
inline bool WorkflowSpec::has_template_() const {
  return this != internal_default_instance() && template__ != nullptr;
}
inline const ::nebulaidl::core::WorkflowTemplate& WorkflowSpec::template_() const {
  const ::nebulaidl::core::WorkflowTemplate* p = template__;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowSpec.template)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::WorkflowTemplate*>(
      &::nebulaidl::core::_WorkflowTemplate_default_instance_);
}
inline ::nebulaidl::core::WorkflowTemplate* WorkflowSpec::release_template_() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowSpec.template)
  
  ::nebulaidl::core::WorkflowTemplate* temp = template__;
  template__ = nullptr;
  return temp;
}
inline ::nebulaidl::core::WorkflowTemplate* WorkflowSpec::mutable_template_() {
  
  if (template__ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::WorkflowTemplate>(GetArenaNoVirtual());
    template__ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowSpec.template)
  return template__;
}
inline void WorkflowSpec::set_allocated_template_(::nebulaidl::core::WorkflowTemplate* template_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(template__);
  }
  if (template_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      template_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, template_, submessage_arena);
    }
    
  } else {
    
  }
  template__ = template_;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowSpec.template)
}

// repeated .nebulaidl.core.WorkflowTemplate sub_workflows = 2;
inline int WorkflowSpec::sub_workflows_size() const {
  return sub_workflows_.size();
}
inline ::nebulaidl::core::WorkflowTemplate* WorkflowSpec::mutable_sub_workflows(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowSpec.sub_workflows)
  return sub_workflows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::WorkflowTemplate >*
WorkflowSpec::mutable_sub_workflows() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.admin.WorkflowSpec.sub_workflows)
  return &sub_workflows_;
}
inline const ::nebulaidl::core::WorkflowTemplate& WorkflowSpec::sub_workflows(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowSpec.sub_workflows)
  return sub_workflows_.Get(index);
}
inline ::nebulaidl::core::WorkflowTemplate* WorkflowSpec::add_sub_workflows() {
  // @@protoc_insertion_point(field_add:nebulaidl.admin.WorkflowSpec.sub_workflows)
  return sub_workflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::WorkflowTemplate >&
WorkflowSpec::sub_workflows() const {
  // @@protoc_insertion_point(field_list:nebulaidl.admin.WorkflowSpec.sub_workflows)
  return sub_workflows_;
}

// .nebulaidl.admin.DescriptionEntity description = 3;
inline bool WorkflowSpec::has_description() const {
  return this != internal_default_instance() && description_ != nullptr;
}
inline const ::nebulaidl::admin::DescriptionEntity& WorkflowSpec::description() const {
  const ::nebulaidl::admin::DescriptionEntity* p = description_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowSpec.description)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::admin::DescriptionEntity*>(
      &::nebulaidl::admin::_DescriptionEntity_default_instance_);
}
inline ::nebulaidl::admin::DescriptionEntity* WorkflowSpec::release_description() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowSpec.description)
  
  ::nebulaidl::admin::DescriptionEntity* temp = description_;
  description_ = nullptr;
  return temp;
}
inline ::nebulaidl::admin::DescriptionEntity* WorkflowSpec::mutable_description() {
  
  if (description_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::admin::DescriptionEntity>(GetArenaNoVirtual());
    description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowSpec.description)
  return description_;
}
inline void WorkflowSpec::set_allocated_description(::nebulaidl::admin::DescriptionEntity* description) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(description_);
  }
  if (description) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      description = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  description_ = description;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowSpec.description)
}

// -------------------------------------------------------------------

// WorkflowClosure

// .nebulaidl.core.CompiledWorkflowClosure compiled_workflow = 1;
inline bool WorkflowClosure::has_compiled_workflow() const {
  return this != internal_default_instance() && compiled_workflow_ != nullptr;
}
inline const ::nebulaidl::core::CompiledWorkflowClosure& WorkflowClosure::compiled_workflow() const {
  const ::nebulaidl::core::CompiledWorkflowClosure* p = compiled_workflow_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowClosure.compiled_workflow)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::CompiledWorkflowClosure*>(
      &::nebulaidl::core::_CompiledWorkflowClosure_default_instance_);
}
inline ::nebulaidl::core::CompiledWorkflowClosure* WorkflowClosure::release_compiled_workflow() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowClosure.compiled_workflow)
  
  ::nebulaidl::core::CompiledWorkflowClosure* temp = compiled_workflow_;
  compiled_workflow_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::CompiledWorkflowClosure* WorkflowClosure::mutable_compiled_workflow() {
  
  if (compiled_workflow_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::CompiledWorkflowClosure>(GetArenaNoVirtual());
    compiled_workflow_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowClosure.compiled_workflow)
  return compiled_workflow_;
}
inline void WorkflowClosure::set_allocated_compiled_workflow(::nebulaidl::core::CompiledWorkflowClosure* compiled_workflow) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(compiled_workflow_);
  }
  if (compiled_workflow) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compiled_workflow = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, compiled_workflow, submessage_arena);
    }
    
  } else {
    
  }
  compiled_workflow_ = compiled_workflow;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowClosure.compiled_workflow)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool WorkflowClosure::has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline const ::google::protobuf::Timestamp& WorkflowClosure::created_at() const {
  const ::google::protobuf::Timestamp* p = created_at_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowClosure.created_at)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* WorkflowClosure::release_created_at() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowClosure.created_at)
  
  ::google::protobuf::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* WorkflowClosure::mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_at_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowClosure.created_at)
  return created_at_;
}
inline void WorkflowClosure::set_allocated_created_at(::google::protobuf::Timestamp* created_at) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created_at)->GetArena();
    if (message_arena != submessage_arena) {
      created_at = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowClosure.created_at)
}

// -------------------------------------------------------------------

// WorkflowErrorExistsDifferentStructure

// .nebulaidl.core.Identifier id = 1;
inline bool WorkflowErrorExistsDifferentStructure::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::nebulaidl::core::Identifier& WorkflowErrorExistsDifferentStructure::id() const {
  const ::nebulaidl::core::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowErrorExistsDifferentStructure.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::Identifier*>(
      &::nebulaidl::core::_Identifier_default_instance_);
}
inline ::nebulaidl::core::Identifier* WorkflowErrorExistsDifferentStructure::release_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowErrorExistsDifferentStructure.id)
  
  ::nebulaidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::Identifier* WorkflowErrorExistsDifferentStructure::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowErrorExistsDifferentStructure.id)
  return id_;
}
inline void WorkflowErrorExistsDifferentStructure::set_allocated_id(::nebulaidl::core::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowErrorExistsDifferentStructure.id)
}

// -------------------------------------------------------------------

// WorkflowErrorExistsIdenticalStructure

// .nebulaidl.core.Identifier id = 1;
inline bool WorkflowErrorExistsIdenticalStructure::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::nebulaidl::core::Identifier& WorkflowErrorExistsIdenticalStructure::id() const {
  const ::nebulaidl::core::Identifier* p = id_;
  // @@protoc_insertion_point(field_get:nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::Identifier*>(
      &::nebulaidl::core::_Identifier_default_instance_);
}
inline ::nebulaidl::core::Identifier* WorkflowErrorExistsIdenticalStructure::release_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.id)
  
  ::nebulaidl::core::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::Identifier* WorkflowErrorExistsIdenticalStructure::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.id)
  return id_;
}
inline void WorkflowErrorExistsIdenticalStructure::set_allocated_id(::nebulaidl::core::Identifier* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.id)
}

// -------------------------------------------------------------------

// CreateWorkflowFailureReason

// .nebulaidl.admin.WorkflowErrorExistsDifferentStructure exists_different_structure = 1;
inline bool CreateWorkflowFailureReason::has_exists_different_structure() const {
  return reason_case() == kExistsDifferentStructure;
}
inline void CreateWorkflowFailureReason::set_has_exists_different_structure() {
  _oneof_case_[0] = kExistsDifferentStructure;
}
inline void CreateWorkflowFailureReason::clear_exists_different_structure() {
  if (has_exists_different_structure()) {
    delete reason_.exists_different_structure_;
    clear_has_reason();
  }
}
inline ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* CreateWorkflowFailureReason::release_exists_different_structure() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.CreateWorkflowFailureReason.exists_different_structure)
  if (has_exists_different_structure()) {
    clear_has_reason();
      ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* temp = reason_.exists_different_structure_;
    reason_.exists_different_structure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure& CreateWorkflowFailureReason::exists_different_structure() const {
  // @@protoc_insertion_point(field_get:nebulaidl.admin.CreateWorkflowFailureReason.exists_different_structure)
  return has_exists_different_structure()
      ? *reason_.exists_different_structure_
      : *reinterpret_cast< ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure*>(&::nebulaidl::admin::_WorkflowErrorExistsDifferentStructure_default_instance_);
}
inline ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure* CreateWorkflowFailureReason::mutable_exists_different_structure() {
  if (!has_exists_different_structure()) {
    clear_reason();
    set_has_exists_different_structure();
    reason_.exists_different_structure_ = CreateMaybeMessage< ::nebulaidl::admin::WorkflowErrorExistsDifferentStructure >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.CreateWorkflowFailureReason.exists_different_structure)
  return reason_.exists_different_structure_;
}

// .nebulaidl.admin.WorkflowErrorExistsIdenticalStructure exists_identical_structure = 2;
inline bool CreateWorkflowFailureReason::has_exists_identical_structure() const {
  return reason_case() == kExistsIdenticalStructure;
}
inline void CreateWorkflowFailureReason::set_has_exists_identical_structure() {
  _oneof_case_[0] = kExistsIdenticalStructure;
}
inline void CreateWorkflowFailureReason::clear_exists_identical_structure() {
  if (has_exists_identical_structure()) {
    delete reason_.exists_identical_structure_;
    clear_has_reason();
  }
}
inline ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* CreateWorkflowFailureReason::release_exists_identical_structure() {
  // @@protoc_insertion_point(field_release:nebulaidl.admin.CreateWorkflowFailureReason.exists_identical_structure)
  if (has_exists_identical_structure()) {
    clear_has_reason();
      ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* temp = reason_.exists_identical_structure_;
    reason_.exists_identical_structure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure& CreateWorkflowFailureReason::exists_identical_structure() const {
  // @@protoc_insertion_point(field_get:nebulaidl.admin.CreateWorkflowFailureReason.exists_identical_structure)
  return has_exists_identical_structure()
      ? *reason_.exists_identical_structure_
      : *reinterpret_cast< ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure*>(&::nebulaidl::admin::_WorkflowErrorExistsIdenticalStructure_default_instance_);
}
inline ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure* CreateWorkflowFailureReason::mutable_exists_identical_structure() {
  if (!has_exists_identical_structure()) {
    clear_reason();
    set_has_exists_identical_structure();
    reason_.exists_identical_structure_ = CreateMaybeMessage< ::nebulaidl::admin::WorkflowErrorExistsIdenticalStructure >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.admin.CreateWorkflowFailureReason.exists_identical_structure)
  return reason_.exists_identical_structure_;
}

inline bool CreateWorkflowFailureReason::has_reason() const {
  return reason_case() != REASON_NOT_SET;
}
inline void CreateWorkflowFailureReason::clear_has_reason() {
  _oneof_case_[0] = REASON_NOT_SET;
}
inline CreateWorkflowFailureReason::ReasonCase CreateWorkflowFailureReason::reason_case() const {
  return CreateWorkflowFailureReason::ReasonCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace nebulaidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_nebulaidl_2fadmin_2fworkflow_2eproto
