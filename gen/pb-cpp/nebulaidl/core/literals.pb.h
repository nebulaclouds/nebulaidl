// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nebulaidl/core/literals.proto

#ifndef PROTOBUF_INCLUDED_nebulaidl_2fcore_2fliterals_2eproto
#define PROTOBUF_INCLUDED_nebulaidl_2fcore_2fliterals_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include "nebulaidl/core/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nebulaidl_2fcore_2fliterals_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_nebulaidl_2fcore_2fliterals_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_nebulaidl_2fcore_2fliterals_2eproto();
namespace nebulaidl {
namespace core {
class Binary;
class BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Binding;
class BindingDefaultTypeInternal;
extern BindingDefaultTypeInternal _Binding_default_instance_;
class BindingData;
class BindingDataDefaultTypeInternal;
extern BindingDataDefaultTypeInternal _BindingData_default_instance_;
class BindingDataCollection;
class BindingDataCollectionDefaultTypeInternal;
extern BindingDataCollectionDefaultTypeInternal _BindingDataCollection_default_instance_;
class BindingDataMap;
class BindingDataMapDefaultTypeInternal;
extern BindingDataMapDefaultTypeInternal _BindingDataMap_default_instance_;
class BindingDataMap_BindingsEntry_DoNotUse;
class BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal;
extern BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal _BindingDataMap_BindingsEntry_DoNotUse_default_instance_;
class Blob;
class BlobDefaultTypeInternal;
extern BlobDefaultTypeInternal _Blob_default_instance_;
class BlobMetadata;
class BlobMetadataDefaultTypeInternal;
extern BlobMetadataDefaultTypeInternal _BlobMetadata_default_instance_;
class KeyValuePair;
class KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class Literal;
class LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class LiteralCollection;
class LiteralCollectionDefaultTypeInternal;
extern LiteralCollectionDefaultTypeInternal _LiteralCollection_default_instance_;
class LiteralMap;
class LiteralMapDefaultTypeInternal;
extern LiteralMapDefaultTypeInternal _LiteralMap_default_instance_;
class LiteralMap_LiteralsEntry_DoNotUse;
class LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal;
extern LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal _LiteralMap_LiteralsEntry_DoNotUse_default_instance_;
class Primitive;
class PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class RetryStrategy;
class RetryStrategyDefaultTypeInternal;
extern RetryStrategyDefaultTypeInternal _RetryStrategy_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class StructuredDataset;
class StructuredDatasetDefaultTypeInternal;
extern StructuredDatasetDefaultTypeInternal _StructuredDataset_default_instance_;
class StructuredDatasetMetadata;
class StructuredDatasetMetadataDefaultTypeInternal;
extern StructuredDatasetMetadataDefaultTypeInternal _StructuredDatasetMetadata_default_instance_;
class Union;
class UnionDefaultTypeInternal;
extern UnionDefaultTypeInternal _Union_default_instance_;
class UnionInfo;
class UnionInfoDefaultTypeInternal;
extern UnionInfoDefaultTypeInternal _UnionInfo_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace core
}  // namespace nebulaidl
namespace google {
namespace protobuf {
template<> ::nebulaidl::core::Binary* Arena::CreateMaybeMessage<::nebulaidl::core::Binary>(Arena*);
template<> ::nebulaidl::core::Binding* Arena::CreateMaybeMessage<::nebulaidl::core::Binding>(Arena*);
template<> ::nebulaidl::core::BindingData* Arena::CreateMaybeMessage<::nebulaidl::core::BindingData>(Arena*);
template<> ::nebulaidl::core::BindingDataCollection* Arena::CreateMaybeMessage<::nebulaidl::core::BindingDataCollection>(Arena*);
template<> ::nebulaidl::core::BindingDataMap* Arena::CreateMaybeMessage<::nebulaidl::core::BindingDataMap>(Arena*);
template<> ::nebulaidl::core::BindingDataMap_BindingsEntry_DoNotUse* Arena::CreateMaybeMessage<::nebulaidl::core::BindingDataMap_BindingsEntry_DoNotUse>(Arena*);
template<> ::nebulaidl::core::Blob* Arena::CreateMaybeMessage<::nebulaidl::core::Blob>(Arena*);
template<> ::nebulaidl::core::BlobMetadata* Arena::CreateMaybeMessage<::nebulaidl::core::BlobMetadata>(Arena*);
template<> ::nebulaidl::core::KeyValuePair* Arena::CreateMaybeMessage<::nebulaidl::core::KeyValuePair>(Arena*);
template<> ::nebulaidl::core::Literal* Arena::CreateMaybeMessage<::nebulaidl::core::Literal>(Arena*);
template<> ::nebulaidl::core::LiteralCollection* Arena::CreateMaybeMessage<::nebulaidl::core::LiteralCollection>(Arena*);
template<> ::nebulaidl::core::LiteralMap* Arena::CreateMaybeMessage<::nebulaidl::core::LiteralMap>(Arena*);
template<> ::nebulaidl::core::LiteralMap_LiteralsEntry_DoNotUse* Arena::CreateMaybeMessage<::nebulaidl::core::LiteralMap_LiteralsEntry_DoNotUse>(Arena*);
template<> ::nebulaidl::core::Primitive* Arena::CreateMaybeMessage<::nebulaidl::core::Primitive>(Arena*);
template<> ::nebulaidl::core::RetryStrategy* Arena::CreateMaybeMessage<::nebulaidl::core::RetryStrategy>(Arena*);
template<> ::nebulaidl::core::Scalar* Arena::CreateMaybeMessage<::nebulaidl::core::Scalar>(Arena*);
template<> ::nebulaidl::core::Schema* Arena::CreateMaybeMessage<::nebulaidl::core::Schema>(Arena*);
template<> ::nebulaidl::core::StructuredDataset* Arena::CreateMaybeMessage<::nebulaidl::core::StructuredDataset>(Arena*);
template<> ::nebulaidl::core::StructuredDatasetMetadata* Arena::CreateMaybeMessage<::nebulaidl::core::StructuredDatasetMetadata>(Arena*);
template<> ::nebulaidl::core::Union* Arena::CreateMaybeMessage<::nebulaidl::core::Union>(Arena*);
template<> ::nebulaidl::core::UnionInfo* Arena::CreateMaybeMessage<::nebulaidl::core::UnionInfo>(Arena*);
template<> ::nebulaidl::core::Void* Arena::CreateMaybeMessage<::nebulaidl::core::Void>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nebulaidl {
namespace core {

// ===================================================================

class Primitive final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Primitive) */ {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(Primitive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Primitive& default_instance();

  enum ValueCase {
    kInteger = 1,
    kFloatValue = 2,
    kStringValue = 3,
    kBoolean = 4,
    kDatetime = 5,
    kDuration = 6,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Primitive* other);
  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Primitive* New() const final {
    return CreateMaybeMessage<Primitive>(nullptr);
  }

  Primitive* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 integer = 1;
  private:
  bool has_integer() const;
  public:
  void clear_integer();
  static const int kIntegerFieldNumber = 1;
  ::google::protobuf::int64 integer() const;
  void set_integer(::google::protobuf::int64 value);

  // double float_value = 2;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  static const int kFloatValueFieldNumber = 2;
  double float_value() const;
  void set_float_value(double value);

  // string string_value = 3;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 3;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // bool boolean = 4;
  private:
  bool has_boolean() const;
  public:
  void clear_boolean();
  static const int kBooleanFieldNumber = 4;
  bool boolean() const;
  void set_boolean(bool value);

  // .google.protobuf.Timestamp datetime = 5;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 5;
  const ::google::protobuf::Timestamp& datetime() const;
  ::google::protobuf::Timestamp* release_datetime();
  ::google::protobuf::Timestamp* mutable_datetime();
  void set_allocated_datetime(::google::protobuf::Timestamp* datetime);

  // .google.protobuf.Duration duration = 6;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 6;
  const ::google::protobuf::Duration& duration() const;
  ::google::protobuf::Duration* release_duration();
  ::google::protobuf::Duration* mutable_duration();
  void set_allocated_duration(::google::protobuf::Duration* duration);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.core.Primitive)
 private:
  class HasBitSetters;
  void set_has_integer();
  void set_has_float_value();
  void set_has_string_value();
  void set_has_boolean();
  void set_has_datetime();
  void set_has_duration();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int64 integer_;
    double float_value_;
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    bool boolean_;
    ::google::protobuf::Timestamp* datetime_;
    ::google::protobuf::Duration* duration_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Void final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Void) */ {
 public:
  Void();
  virtual ~Void();

  Void(const Void& from);

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Void* other);
  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const final {
    return CreateMaybeMessage<Void>(nullptr);
  }

  Void* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Void)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Blob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Blob) */ {
 public:
  Blob();
  virtual ~Blob();

  Blob(const Blob& from);

  inline Blob& operator=(const Blob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Blob(Blob&& from) noexcept
    : Blob() {
    *this = ::std::move(from);
  }

  inline Blob& operator=(Blob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Blob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Blob* internal_default_instance() {
    return reinterpret_cast<const Blob*>(
               &_Blob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Blob* other);
  friend void swap(Blob& a, Blob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Blob* New() const final {
    return CreateMaybeMessage<Blob>(nullptr);
  }

  Blob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Blob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Blob& from);
  void MergeFrom(const Blob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Blob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 3;
  void clear_uri();
  static const int kUriFieldNumber = 3;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .nebulaidl.core.BlobMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::nebulaidl::core::BlobMetadata& metadata() const;
  ::nebulaidl::core::BlobMetadata* release_metadata();
  ::nebulaidl::core::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::nebulaidl::core::BlobMetadata* metadata);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Blob)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::nebulaidl::core::BlobMetadata* metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BlobMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.BlobMetadata) */ {
 public:
  BlobMetadata();
  virtual ~BlobMetadata();

  BlobMetadata(const BlobMetadata& from);

  inline BlobMetadata& operator=(const BlobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobMetadata(BlobMetadata&& from) noexcept
    : BlobMetadata() {
    *this = ::std::move(from);
  }

  inline BlobMetadata& operator=(BlobMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlobMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobMetadata* internal_default_instance() {
    return reinterpret_cast<const BlobMetadata*>(
               &_BlobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BlobMetadata* other);
  friend void swap(BlobMetadata& a, BlobMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobMetadata* New() const final {
    return CreateMaybeMessage<BlobMetadata>(nullptr);
  }

  BlobMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlobMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlobMetadata& from);
  void MergeFrom(const BlobMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.BlobType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::nebulaidl::core::BlobType& type() const;
  ::nebulaidl::core::BlobType* release_type();
  ::nebulaidl::core::BlobType* mutable_type();
  void set_allocated_type(::nebulaidl::core::BlobType* type);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.BlobMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::BlobType* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Binary final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Binary) */ {
 public:
  Binary();
  virtual ~Binary();

  Binary(const Binary& from);

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(Binary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Binary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Binary* other);
  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Binary* New() const final {
    return CreateMaybeMessage<Binary>(nullptr);
  }

  Binary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Binary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Binary& from);
  void MergeFrom(const Binary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string tag = 2;
  void clear_tag();
  static const int kTagFieldNumber = 2;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Binary)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Schema) */ {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Schema* other);
  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return CreateMaybeMessage<Schema>(nullptr);
  }

  Schema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .nebulaidl.core.SchemaType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::nebulaidl::core::SchemaType& type() const;
  ::nebulaidl::core::SchemaType* release_type();
  ::nebulaidl::core::SchemaType* mutable_type();
  void set_allocated_type(::nebulaidl::core::SchemaType* type);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Schema)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::nebulaidl::core::SchemaType* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Union final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Union) */ {
 public:
  Union();
  virtual ~Union();

  Union(const Union& from);

  inline Union& operator=(const Union& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Union(Union&& from) noexcept
    : Union() {
    *this = ::std::move(from);
  }

  inline Union& operator=(Union&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Union& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Union* internal_default_instance() {
    return reinterpret_cast<const Union*>(
               &_Union_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Union* other);
  friend void swap(Union& a, Union& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Union* New() const final {
    return CreateMaybeMessage<Union>(nullptr);
  }

  Union* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Union>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Union& from);
  void MergeFrom(const Union& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Union* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.Literal value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::nebulaidl::core::Literal& value() const;
  ::nebulaidl::core::Literal* release_value();
  ::nebulaidl::core::Literal* mutable_value();
  void set_allocated_value(::nebulaidl::core::Literal* value);

  // .nebulaidl.core.LiteralType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::nebulaidl::core::LiteralType& type() const;
  ::nebulaidl::core::LiteralType* release_type();
  ::nebulaidl::core::LiteralType* mutable_type();
  void set_allocated_type(::nebulaidl::core::LiteralType* type);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Union)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::Literal* value_;
  ::nebulaidl::core::LiteralType* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class StructuredDatasetMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.StructuredDatasetMetadata) */ {
 public:
  StructuredDatasetMetadata();
  virtual ~StructuredDatasetMetadata();

  StructuredDatasetMetadata(const StructuredDatasetMetadata& from);

  inline StructuredDatasetMetadata& operator=(const StructuredDatasetMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StructuredDatasetMetadata(StructuredDatasetMetadata&& from) noexcept
    : StructuredDatasetMetadata() {
    *this = ::std::move(from);
  }

  inline StructuredDatasetMetadata& operator=(StructuredDatasetMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StructuredDatasetMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StructuredDatasetMetadata* internal_default_instance() {
    return reinterpret_cast<const StructuredDatasetMetadata*>(
               &_StructuredDatasetMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(StructuredDatasetMetadata* other);
  friend void swap(StructuredDatasetMetadata& a, StructuredDatasetMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StructuredDatasetMetadata* New() const final {
    return CreateMaybeMessage<StructuredDatasetMetadata>(nullptr);
  }

  StructuredDatasetMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StructuredDatasetMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StructuredDatasetMetadata& from);
  void MergeFrom(const StructuredDatasetMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDatasetMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.StructuredDatasetType structured_dataset_type = 1;
  bool has_structured_dataset_type() const;
  void clear_structured_dataset_type();
  static const int kStructuredDatasetTypeFieldNumber = 1;
  const ::nebulaidl::core::StructuredDatasetType& structured_dataset_type() const;
  ::nebulaidl::core::StructuredDatasetType* release_structured_dataset_type();
  ::nebulaidl::core::StructuredDatasetType* mutable_structured_dataset_type();
  void set_allocated_structured_dataset_type(::nebulaidl::core::StructuredDatasetType* structured_dataset_type);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.StructuredDatasetMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::StructuredDatasetType* structured_dataset_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class StructuredDataset final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.StructuredDataset) */ {
 public:
  StructuredDataset();
  virtual ~StructuredDataset();

  StructuredDataset(const StructuredDataset& from);

  inline StructuredDataset& operator=(const StructuredDataset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StructuredDataset(StructuredDataset&& from) noexcept
    : StructuredDataset() {
    *this = ::std::move(from);
  }

  inline StructuredDataset& operator=(StructuredDataset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StructuredDataset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StructuredDataset* internal_default_instance() {
    return reinterpret_cast<const StructuredDataset*>(
               &_StructuredDataset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StructuredDataset* other);
  friend void swap(StructuredDataset& a, StructuredDataset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StructuredDataset* New() const final {
    return CreateMaybeMessage<StructuredDataset>(nullptr);
  }

  StructuredDataset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StructuredDataset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StructuredDataset& from);
  void MergeFrom(const StructuredDataset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDataset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .nebulaidl.core.StructuredDatasetMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::nebulaidl::core::StructuredDatasetMetadata& metadata() const;
  ::nebulaidl::core::StructuredDatasetMetadata* release_metadata();
  ::nebulaidl::core::StructuredDatasetMetadata* mutable_metadata();
  void set_allocated_metadata(::nebulaidl::core::StructuredDatasetMetadata* metadata);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.StructuredDataset)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::nebulaidl::core::StructuredDatasetMetadata* metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Scalar final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Scalar) */ {
 public:
  Scalar();
  virtual ~Scalar();

  Scalar(const Scalar& from);

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Scalar& default_instance();

  enum ValueCase {
    kPrimitive = 1,
    kBlob = 2,
    kBinary = 3,
    kSchema = 4,
    kNoneType = 5,
    kError = 6,
    kGeneric = 7,
    kStructuredDataset = 8,
    kUnion = 9,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Scalar* other);
  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scalar* New() const final {
    return CreateMaybeMessage<Scalar>(nullptr);
  }

  Scalar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scalar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.Primitive primitive = 1;
  bool has_primitive() const;
  void clear_primitive();
  static const int kPrimitiveFieldNumber = 1;
  const ::nebulaidl::core::Primitive& primitive() const;
  ::nebulaidl::core::Primitive* release_primitive();
  ::nebulaidl::core::Primitive* mutable_primitive();
  void set_allocated_primitive(::nebulaidl::core::Primitive* primitive);

  // .nebulaidl.core.Blob blob = 2;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 2;
  const ::nebulaidl::core::Blob& blob() const;
  ::nebulaidl::core::Blob* release_blob();
  ::nebulaidl::core::Blob* mutable_blob();
  void set_allocated_blob(::nebulaidl::core::Blob* blob);

  // .nebulaidl.core.Binary binary = 3;
  bool has_binary() const;
  void clear_binary();
  static const int kBinaryFieldNumber = 3;
  const ::nebulaidl::core::Binary& binary() const;
  ::nebulaidl::core::Binary* release_binary();
  ::nebulaidl::core::Binary* mutable_binary();
  void set_allocated_binary(::nebulaidl::core::Binary* binary);

  // .nebulaidl.core.Schema schema = 4;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 4;
  const ::nebulaidl::core::Schema& schema() const;
  ::nebulaidl::core::Schema* release_schema();
  ::nebulaidl::core::Schema* mutable_schema();
  void set_allocated_schema(::nebulaidl::core::Schema* schema);

  // .nebulaidl.core.Void none_type = 5;
  bool has_none_type() const;
  void clear_none_type();
  static const int kNoneTypeFieldNumber = 5;
  const ::nebulaidl::core::Void& none_type() const;
  ::nebulaidl::core::Void* release_none_type();
  ::nebulaidl::core::Void* mutable_none_type();
  void set_allocated_none_type(::nebulaidl::core::Void* none_type);

  // .nebulaidl.core.Error error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  const ::nebulaidl::core::Error& error() const;
  ::nebulaidl::core::Error* release_error();
  ::nebulaidl::core::Error* mutable_error();
  void set_allocated_error(::nebulaidl::core::Error* error);

  // .google.protobuf.Struct generic = 7;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 7;
  const ::google::protobuf::Struct& generic() const;
  ::google::protobuf::Struct* release_generic();
  ::google::protobuf::Struct* mutable_generic();
  void set_allocated_generic(::google::protobuf::Struct* generic);

  // .nebulaidl.core.StructuredDataset structured_dataset = 8;
  bool has_structured_dataset() const;
  void clear_structured_dataset();
  static const int kStructuredDatasetFieldNumber = 8;
  const ::nebulaidl::core::StructuredDataset& structured_dataset() const;
  ::nebulaidl::core::StructuredDataset* release_structured_dataset();
  ::nebulaidl::core::StructuredDataset* mutable_structured_dataset();
  void set_allocated_structured_dataset(::nebulaidl::core::StructuredDataset* structured_dataset);

  // .nebulaidl.core.Union union = 9;
  bool has_union_() const;
  void clear_union_();
  static const int kUnionFieldNumber = 9;
  const ::nebulaidl::core::Union& union_() const;
  ::nebulaidl::core::Union* release_union_();
  ::nebulaidl::core::Union* mutable_union_();
  void set_allocated_union_(::nebulaidl::core::Union* union_);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.core.Scalar)
 private:
  class HasBitSetters;
  void set_has_primitive();
  void set_has_blob();
  void set_has_binary();
  void set_has_schema();
  void set_has_none_type();
  void set_has_error();
  void set_has_generic();
  void set_has_structured_dataset();
  void set_has_union_();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::nebulaidl::core::Primitive* primitive_;
    ::nebulaidl::core::Blob* blob_;
    ::nebulaidl::core::Binary* binary_;
    ::nebulaidl::core::Schema* schema_;
    ::nebulaidl::core::Void* none_type_;
    ::nebulaidl::core::Error* error_;
    ::google::protobuf::Struct* generic_;
    ::nebulaidl::core::StructuredDataset* structured_dataset_;
    ::nebulaidl::core::Union* union__;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Literal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Literal) */ {
 public:
  Literal();
  virtual ~Literal();

  Literal(const Literal& from);

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(Literal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Literal& default_instance();

  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kMap = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Literal* other);
  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Literal* New() const final {
    return CreateMaybeMessage<Literal>(nullptr);
  }

  Literal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Literal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Literal& from);
  void MergeFrom(const Literal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Literal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 4;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .nebulaidl.core.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  const ::nebulaidl::core::Scalar& scalar() const;
  ::nebulaidl::core::Scalar* release_scalar();
  ::nebulaidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::nebulaidl::core::Scalar* scalar);

  // .nebulaidl.core.LiteralCollection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::nebulaidl::core::LiteralCollection& collection() const;
  ::nebulaidl::core::LiteralCollection* release_collection();
  ::nebulaidl::core::LiteralCollection* mutable_collection();
  void set_allocated_collection(::nebulaidl::core::LiteralCollection* collection);

  // .nebulaidl.core.LiteralMap map = 3;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 3;
  const ::nebulaidl::core::LiteralMap& map() const;
  ::nebulaidl::core::LiteralMap* release_map();
  ::nebulaidl::core::LiteralMap* mutable_map();
  void set_allocated_map(::nebulaidl::core::LiteralMap* map);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.core.Literal)
 private:
  class HasBitSetters;
  void set_has_scalar();
  void set_has_collection();
  void set_has_map();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  union ValueUnion {
    ValueUnion() {}
    ::nebulaidl::core::Scalar* scalar_;
    ::nebulaidl::core::LiteralCollection* collection_;
    ::nebulaidl::core::LiteralMap* map_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class LiteralCollection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.LiteralCollection) */ {
 public:
  LiteralCollection();
  virtual ~LiteralCollection();

  LiteralCollection(const LiteralCollection& from);

  inline LiteralCollection& operator=(const LiteralCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralCollection(LiteralCollection&& from) noexcept
    : LiteralCollection() {
    *this = ::std::move(from);
  }

  inline LiteralCollection& operator=(LiteralCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiteralCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralCollection* internal_default_instance() {
    return reinterpret_cast<const LiteralCollection*>(
               &_LiteralCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(LiteralCollection* other);
  friend void swap(LiteralCollection& a, LiteralCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralCollection* New() const final {
    return CreateMaybeMessage<LiteralCollection>(nullptr);
  }

  LiteralCollection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiteralCollection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiteralCollection& from);
  void MergeFrom(const LiteralCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.Literal literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  ::nebulaidl::core::Literal* mutable_literals(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::Literal >*
      mutable_literals();
  const ::nebulaidl::core::Literal& literals(int index) const;
  ::nebulaidl::core::Literal* add_literals();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::Literal >&
      literals() const;

  // @@protoc_insertion_point(class_scope:nebulaidl.core.LiteralCollection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::Literal > literals_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class LiteralMap_LiteralsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    ::std::string, ::nebulaidl::core::Literal,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    ::std::string, ::nebulaidl::core::Literal,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  LiteralMap_LiteralsEntry_DoNotUse();
  LiteralMap_LiteralsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LiteralMap_LiteralsEntry_DoNotUse& other);
  static const LiteralMap_LiteralsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LiteralMap_LiteralsEntry_DoNotUse*>(&_LiteralMap_LiteralsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LiteralMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.LiteralMap) */ {
 public:
  LiteralMap();
  virtual ~LiteralMap();

  LiteralMap(const LiteralMap& from);

  inline LiteralMap& operator=(const LiteralMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralMap(LiteralMap&& from) noexcept
    : LiteralMap() {
    *this = ::std::move(from);
  }

  inline LiteralMap& operator=(LiteralMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiteralMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralMap* internal_default_instance() {
    return reinterpret_cast<const LiteralMap*>(
               &_LiteralMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(LiteralMap* other);
  friend void swap(LiteralMap& a, LiteralMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralMap* New() const final {
    return CreateMaybeMessage<LiteralMap>(nullptr);
  }

  LiteralMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiteralMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiteralMap& from);
  void MergeFrom(const LiteralMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .nebulaidl.core.Literal> literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::nebulaidl::core::Literal >&
      literals() const;
  ::google::protobuf::Map< ::std::string, ::nebulaidl::core::Literal >*
      mutable_literals();

  // @@protoc_insertion_point(class_scope:nebulaidl.core.LiteralMap)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      LiteralMap_LiteralsEntry_DoNotUse,
      ::std::string, ::nebulaidl::core::Literal,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > literals_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingDataCollection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.BindingDataCollection) */ {
 public:
  BindingDataCollection();
  virtual ~BindingDataCollection();

  BindingDataCollection(const BindingDataCollection& from);

  inline BindingDataCollection& operator=(const BindingDataCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingDataCollection(BindingDataCollection&& from) noexcept
    : BindingDataCollection() {
    *this = ::std::move(from);
  }

  inline BindingDataCollection& operator=(BindingDataCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BindingDataCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingDataCollection* internal_default_instance() {
    return reinterpret_cast<const BindingDataCollection*>(
               &_BindingDataCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(BindingDataCollection* other);
  friend void swap(BindingDataCollection& a, BindingDataCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingDataCollection* New() const final {
    return CreateMaybeMessage<BindingDataCollection>(nullptr);
  }

  BindingDataCollection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BindingDataCollection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BindingDataCollection& from);
  void MergeFrom(const BindingDataCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingDataCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.BindingData bindings = 1;
  int bindings_size() const;
  void clear_bindings();
  static const int kBindingsFieldNumber = 1;
  ::nebulaidl::core::BindingData* mutable_bindings(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::BindingData >*
      mutable_bindings();
  const ::nebulaidl::core::BindingData& bindings(int index) const;
  ::nebulaidl::core::BindingData* add_bindings();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::BindingData >&
      bindings() const;

  // @@protoc_insertion_point(class_scope:nebulaidl.core.BindingDataCollection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::BindingData > bindings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingDataMap_BindingsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    ::std::string, ::nebulaidl::core::BindingData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    ::std::string, ::nebulaidl::core::BindingData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  BindingDataMap_BindingsEntry_DoNotUse();
  BindingDataMap_BindingsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const BindingDataMap_BindingsEntry_DoNotUse& other);
  static const BindingDataMap_BindingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BindingDataMap_BindingsEntry_DoNotUse*>(&_BindingDataMap_BindingsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class BindingDataMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.BindingDataMap) */ {
 public:
  BindingDataMap();
  virtual ~BindingDataMap();

  BindingDataMap(const BindingDataMap& from);

  inline BindingDataMap& operator=(const BindingDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingDataMap(BindingDataMap&& from) noexcept
    : BindingDataMap() {
    *this = ::std::move(from);
  }

  inline BindingDataMap& operator=(BindingDataMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BindingDataMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingDataMap* internal_default_instance() {
    return reinterpret_cast<const BindingDataMap*>(
               &_BindingDataMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(BindingDataMap* other);
  friend void swap(BindingDataMap& a, BindingDataMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingDataMap* New() const final {
    return CreateMaybeMessage<BindingDataMap>(nullptr);
  }

  BindingDataMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BindingDataMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BindingDataMap& from);
  void MergeFrom(const BindingDataMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingDataMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .nebulaidl.core.BindingData> bindings = 1;
  int bindings_size() const;
  void clear_bindings();
  static const int kBindingsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::nebulaidl::core::BindingData >&
      bindings() const;
  ::google::protobuf::Map< ::std::string, ::nebulaidl::core::BindingData >*
      mutable_bindings();

  // @@protoc_insertion_point(class_scope:nebulaidl.core.BindingDataMap)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      BindingDataMap_BindingsEntry_DoNotUse,
      ::std::string, ::nebulaidl::core::BindingData,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > bindings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class UnionInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.UnionInfo) */ {
 public:
  UnionInfo();
  virtual ~UnionInfo();

  UnionInfo(const UnionInfo& from);

  inline UnionInfo& operator=(const UnionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnionInfo(UnionInfo&& from) noexcept
    : UnionInfo() {
    *this = ::std::move(from);
  }

  inline UnionInfo& operator=(UnionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UnionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnionInfo* internal_default_instance() {
    return reinterpret_cast<const UnionInfo*>(
               &_UnionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(UnionInfo* other);
  friend void swap(UnionInfo& a, UnionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnionInfo* New() const final {
    return CreateMaybeMessage<UnionInfo>(nullptr);
  }

  UnionInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnionInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnionInfo& from);
  void MergeFrom(const UnionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.LiteralType targetType = 1;
  bool has_targettype() const;
  void clear_targettype();
  static const int kTargetTypeFieldNumber = 1;
  const ::nebulaidl::core::LiteralType& targettype() const;
  ::nebulaidl::core::LiteralType* release_targettype();
  ::nebulaidl::core::LiteralType* mutable_targettype();
  void set_allocated_targettype(::nebulaidl::core::LiteralType* targettype);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.UnionInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::LiteralType* targettype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class BindingData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.BindingData) */ {
 public:
  BindingData();
  virtual ~BindingData();

  BindingData(const BindingData& from);

  inline BindingData& operator=(const BindingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingData(BindingData&& from) noexcept
    : BindingData() {
    *this = ::std::move(from);
  }

  inline BindingData& operator=(BindingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BindingData& default_instance();

  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kPromise = 3,
    kMap = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingData* internal_default_instance() {
    return reinterpret_cast<const BindingData*>(
               &_BindingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(BindingData* other);
  friend void swap(BindingData& a, BindingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingData* New() const final {
    return CreateMaybeMessage<BindingData>(nullptr);
  }

  BindingData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BindingData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BindingData& from);
  void MergeFrom(const BindingData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.UnionInfo union = 5;
  bool has_union_() const;
  void clear_union_();
  static const int kUnionFieldNumber = 5;
  const ::nebulaidl::core::UnionInfo& union_() const;
  ::nebulaidl::core::UnionInfo* release_union_();
  ::nebulaidl::core::UnionInfo* mutable_union_();
  void set_allocated_union_(::nebulaidl::core::UnionInfo* union_);

  // .nebulaidl.core.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  const ::nebulaidl::core::Scalar& scalar() const;
  ::nebulaidl::core::Scalar* release_scalar();
  ::nebulaidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::nebulaidl::core::Scalar* scalar);

  // .nebulaidl.core.BindingDataCollection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::nebulaidl::core::BindingDataCollection& collection() const;
  ::nebulaidl::core::BindingDataCollection* release_collection();
  ::nebulaidl::core::BindingDataCollection* mutable_collection();
  void set_allocated_collection(::nebulaidl::core::BindingDataCollection* collection);

  // .nebulaidl.core.OutputReference promise = 3;
  bool has_promise() const;
  void clear_promise();
  static const int kPromiseFieldNumber = 3;
  const ::nebulaidl::core::OutputReference& promise() const;
  ::nebulaidl::core::OutputReference* release_promise();
  ::nebulaidl::core::OutputReference* mutable_promise();
  void set_allocated_promise(::nebulaidl::core::OutputReference* promise);

  // .nebulaidl.core.BindingDataMap map = 4;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 4;
  const ::nebulaidl::core::BindingDataMap& map() const;
  ::nebulaidl::core::BindingDataMap* release_map();
  ::nebulaidl::core::BindingDataMap* mutable_map();
  void set_allocated_map(::nebulaidl::core::BindingDataMap* map);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.core.BindingData)
 private:
  class HasBitSetters;
  void set_has_scalar();
  void set_has_collection();
  void set_has_promise();
  void set_has_map();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::UnionInfo* union__;
  union ValueUnion {
    ValueUnion() {}
    ::nebulaidl::core::Scalar* scalar_;
    ::nebulaidl::core::BindingDataCollection* collection_;
    ::nebulaidl::core::OutputReference* promise_;
    ::nebulaidl::core::BindingDataMap* map_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class Binding final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Binding) */ {
 public:
  Binding();
  virtual ~Binding();

  Binding(const Binding& from);

  inline Binding& operator=(const Binding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Binding(Binding&& from) noexcept
    : Binding() {
    *this = ::std::move(from);
  }

  inline Binding& operator=(Binding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Binding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Binding* internal_default_instance() {
    return reinterpret_cast<const Binding*>(
               &_Binding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Binding* other);
  friend void swap(Binding& a, Binding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Binding* New() const final {
    return CreateMaybeMessage<Binding>(nullptr);
  }

  Binding* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Binding>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Binding& from);
  void MergeFrom(const Binding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string var = 1;
  void clear_var();
  static const int kVarFieldNumber = 1;
  const ::std::string& var() const;
  void set_var(const ::std::string& value);
  #if LANG_CXX11
  void set_var(::std::string&& value);
  #endif
  void set_var(const char* value);
  void set_var(const char* value, size_t size);
  ::std::string* mutable_var();
  ::std::string* release_var();
  void set_allocated_var(::std::string* var);

  // .nebulaidl.core.BindingData binding = 2;
  bool has_binding() const;
  void clear_binding();
  static const int kBindingFieldNumber = 2;
  const ::nebulaidl::core::BindingData& binding() const;
  ::nebulaidl::core::BindingData* release_binding();
  ::nebulaidl::core::BindingData* mutable_binding();
  void set_allocated_binding(::nebulaidl::core::BindingData* binding);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Binding)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr var_;
  ::nebulaidl::core::BindingData* binding_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class KeyValuePair final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.KeyValuePair) */ {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();

  KeyValuePair(const KeyValuePair& from);

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const KeyValuePair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(KeyValuePair* other);
  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValuePair* New() const final {
    return CreateMaybeMessage<KeyValuePair>(nullptr);
  }

  KeyValuePair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValuePair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValuePair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.KeyValuePair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// -------------------------------------------------------------------

class RetryStrategy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.RetryStrategy) */ {
 public:
  RetryStrategy();
  virtual ~RetryStrategy();

  RetryStrategy(const RetryStrategy& from);

  inline RetryStrategy& operator=(const RetryStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RetryStrategy(RetryStrategy&& from) noexcept
    : RetryStrategy() {
    *this = ::std::move(from);
  }

  inline RetryStrategy& operator=(RetryStrategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RetryStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetryStrategy* internal_default_instance() {
    return reinterpret_cast<const RetryStrategy*>(
               &_RetryStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(RetryStrategy* other);
  friend void swap(RetryStrategy& a, RetryStrategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RetryStrategy* New() const final {
    return CreateMaybeMessage<RetryStrategy>(nullptr);
  }

  RetryStrategy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RetryStrategy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RetryStrategy& from);
  void MergeFrom(const RetryStrategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetryStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 retries = 5;
  void clear_retries();
  static const int kRetriesFieldNumber = 5;
  ::google::protobuf::uint32 retries() const;
  void set_retries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.RetryStrategy)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 retries_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fliterals_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Primitive

// int64 integer = 1;
inline bool Primitive::has_integer() const {
  return value_case() == kInteger;
}
inline void Primitive::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void Primitive::clear_integer() {
  if (has_integer()) {
    value_.integer_ = PROTOBUF_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 Primitive::integer() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Primitive.integer)
  if (has_integer()) {
    return value_.integer_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Primitive::set_integer(::google::protobuf::int64 value) {
  if (!has_integer()) {
    clear_value();
    set_has_integer();
  }
  value_.integer_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.Primitive.integer)
}

// double float_value = 2;
inline bool Primitive::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Primitive::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Primitive::clear_float_value() {
  if (has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline double Primitive::float_value() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Primitive.float_value)
  if (has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Primitive::set_float_value(double value) {
  if (!has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.Primitive.float_value)
}

// string string_value = 3;
inline bool Primitive::has_string_value() const {
  return value_case() == kStringValue;
}
inline void Primitive::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Primitive::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& Primitive::string_value() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Primitive.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Primitive::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nebulaidl.core.Primitive.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Primitive.string_value)
}
#if LANG_CXX11
inline void Primitive::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:nebulaidl.core.Primitive.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Primitive.string_value)
}
#endif
inline void Primitive::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Primitive.string_value)
}
inline void Primitive::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Primitive.string_value)
}
inline ::std::string* Primitive::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Primitive.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Primitive::release_string_value() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Primitive.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Primitive::set_allocated_string_value(::std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Primitive.string_value)
}

// bool boolean = 4;
inline bool Primitive::has_boolean() const {
  return value_case() == kBoolean;
}
inline void Primitive::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Primitive::clear_boolean() {
  if (has_boolean()) {
    value_.boolean_ = false;
    clear_has_value();
  }
}
inline bool Primitive::boolean() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Primitive.boolean)
  if (has_boolean()) {
    return value_.boolean_;
  }
  return false;
}
inline void Primitive::set_boolean(bool value) {
  if (!has_boolean()) {
    clear_value();
    set_has_boolean();
  }
  value_.boolean_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.Primitive.boolean)
}

// .google.protobuf.Timestamp datetime = 5;
inline bool Primitive::has_datetime() const {
  return value_case() == kDatetime;
}
inline void Primitive::set_has_datetime() {
  _oneof_case_[0] = kDatetime;
}
inline ::google::protobuf::Timestamp* Primitive::release_datetime() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Primitive.datetime)
  if (has_datetime()) {
    clear_has_value();
      ::google::protobuf::Timestamp* temp = value_.datetime_;
    value_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& Primitive::datetime() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Primitive.datetime)
  return has_datetime()
      ? *value_.datetime_
      : *reinterpret_cast< ::google::protobuf::Timestamp*>(&::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Primitive::mutable_datetime() {
  if (!has_datetime()) {
    clear_value();
    set_has_datetime();
    value_.datetime_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Primitive.datetime)
  return value_.datetime_;
}

// .google.protobuf.Duration duration = 6;
inline bool Primitive::has_duration() const {
  return value_case() == kDuration;
}
inline void Primitive::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline ::google::protobuf::Duration* Primitive::release_duration() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Primitive.duration)
  if (has_duration()) {
    clear_has_value();
      ::google::protobuf::Duration* temp = value_.duration_;
    value_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& Primitive::duration() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Primitive.duration)
  return has_duration()
      ? *value_.duration_
      : *reinterpret_cast< ::google::protobuf::Duration*>(&::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Primitive::mutable_duration() {
  if (!has_duration()) {
    clear_value();
    set_has_duration();
    value_.duration_ = CreateMaybeMessage< ::google::protobuf::Duration >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Primitive.duration)
  return value_.duration_;
}

inline bool Primitive::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Primitive::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Primitive::ValueCase Primitive::value_case() const {
  return Primitive::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// Blob

// .nebulaidl.core.BlobMetadata metadata = 1;
inline bool Blob::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void Blob::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::nebulaidl::core::BlobMetadata& Blob::metadata() const {
  const ::nebulaidl::core::BlobMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.Blob.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::BlobMetadata*>(
      &::nebulaidl::core::_BlobMetadata_default_instance_);
}
inline ::nebulaidl::core::BlobMetadata* Blob::release_metadata() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Blob.metadata)
  
  ::nebulaidl::core::BlobMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::BlobMetadata* Blob::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::BlobMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Blob.metadata)
  return metadata_;
}
inline void Blob::set_allocated_metadata(::nebulaidl::core::BlobMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Blob.metadata)
}

// string uri = 3;
inline void Blob::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Blob::uri() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Blob.uri)
  return uri_.GetNoArena();
}
inline void Blob::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Blob.uri)
}
#if LANG_CXX11
inline void Blob::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Blob.uri)
}
#endif
inline void Blob::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Blob.uri)
}
inline void Blob::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Blob.uri)
}
inline ::std::string* Blob::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Blob.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Blob::release_uri() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Blob.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Blob.uri)
}

// -------------------------------------------------------------------

// BlobMetadata

// .nebulaidl.core.BlobType type = 1;
inline bool BlobMetadata::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::nebulaidl::core::BlobType& BlobMetadata::type() const {
  const ::nebulaidl::core::BlobType* p = type_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.BlobMetadata.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::BlobType*>(
      &::nebulaidl::core::_BlobType_default_instance_);
}
inline ::nebulaidl::core::BlobType* BlobMetadata::release_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BlobMetadata.type)
  
  ::nebulaidl::core::BlobType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::BlobType* BlobMetadata::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::BlobType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BlobMetadata.type)
  return type_;
}
inline void BlobMetadata::set_allocated_type(::nebulaidl::core::BlobType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.BlobMetadata.type)
}

// -------------------------------------------------------------------

// Binary

// bytes value = 1;
inline void Binary::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binary::value() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Binary.value)
  return value_.GetNoArena();
}
inline void Binary::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Binary.value)
}
#if LANG_CXX11
inline void Binary::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Binary.value)
}
#endif
inline void Binary::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Binary.value)
}
inline void Binary::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Binary.value)
}
inline ::std::string* Binary::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Binary.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binary::release_value() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Binary.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binary::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Binary.value)
}

// string tag = 2;
inline void Binary::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binary::tag() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Binary.tag)
  return tag_.GetNoArena();
}
inline void Binary::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Binary.tag)
}
#if LANG_CXX11
inline void Binary::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Binary.tag)
}
#endif
inline void Binary::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Binary.tag)
}
inline void Binary::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Binary.tag)
}
inline ::std::string* Binary::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Binary.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binary::release_tag() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Binary.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binary::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Binary.tag)
}

// -------------------------------------------------------------------

// Schema

// string uri = 1;
inline void Schema::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Schema::uri() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Schema.uri)
  return uri_.GetNoArena();
}
inline void Schema::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Schema.uri)
}
#if LANG_CXX11
inline void Schema::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Schema.uri)
}
#endif
inline void Schema::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Schema.uri)
}
inline void Schema::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Schema.uri)
}
inline ::std::string* Schema::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Schema.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Schema::release_uri() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Schema.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Schema::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Schema.uri)
}

// .nebulaidl.core.SchemaType type = 3;
inline bool Schema::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::nebulaidl::core::SchemaType& Schema::type() const {
  const ::nebulaidl::core::SchemaType* p = type_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.Schema.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::SchemaType*>(
      &::nebulaidl::core::_SchemaType_default_instance_);
}
inline ::nebulaidl::core::SchemaType* Schema::release_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Schema.type)
  
  ::nebulaidl::core::SchemaType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::SchemaType* Schema::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::SchemaType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Schema.type)
  return type_;
}
inline void Schema::set_allocated_type(::nebulaidl::core::SchemaType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Schema.type)
}

// -------------------------------------------------------------------

// Union

// .nebulaidl.core.Literal value = 1;
inline bool Union::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline void Union::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::nebulaidl::core::Literal& Union::value() const {
  const ::nebulaidl::core::Literal* p = value_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.Union.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::Literal*>(
      &::nebulaidl::core::_Literal_default_instance_);
}
inline ::nebulaidl::core::Literal* Union::release_value() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Union.value)
  
  ::nebulaidl::core::Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::Literal* Union::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::Literal>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Union.value)
  return value_;
}
inline void Union::set_allocated_value(::nebulaidl::core::Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Union.value)
}

// .nebulaidl.core.LiteralType type = 2;
inline bool Union::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::nebulaidl::core::LiteralType& Union::type() const {
  const ::nebulaidl::core::LiteralType* p = type_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.Union.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::LiteralType*>(
      &::nebulaidl::core::_LiteralType_default_instance_);
}
inline ::nebulaidl::core::LiteralType* Union::release_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Union.type)
  
  ::nebulaidl::core::LiteralType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::LiteralType* Union::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::LiteralType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Union.type)
  return type_;
}
inline void Union::set_allocated_type(::nebulaidl::core::LiteralType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Union.type)
}

// -------------------------------------------------------------------

// StructuredDatasetMetadata

// .nebulaidl.core.StructuredDatasetType structured_dataset_type = 1;
inline bool StructuredDatasetMetadata::has_structured_dataset_type() const {
  return this != internal_default_instance() && structured_dataset_type_ != nullptr;
}
inline const ::nebulaidl::core::StructuredDatasetType& StructuredDatasetMetadata::structured_dataset_type() const {
  const ::nebulaidl::core::StructuredDatasetType* p = structured_dataset_type_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetMetadata.structured_dataset_type)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::StructuredDatasetType*>(
      &::nebulaidl::core::_StructuredDatasetType_default_instance_);
}
inline ::nebulaidl::core::StructuredDatasetType* StructuredDatasetMetadata::release_structured_dataset_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDatasetMetadata.structured_dataset_type)
  
  ::nebulaidl::core::StructuredDatasetType* temp = structured_dataset_type_;
  structured_dataset_type_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::StructuredDatasetType* StructuredDatasetMetadata::mutable_structured_dataset_type() {
  
  if (structured_dataset_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::StructuredDatasetType>(GetArenaNoVirtual());
    structured_dataset_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetMetadata.structured_dataset_type)
  return structured_dataset_type_;
}
inline void StructuredDatasetMetadata::set_allocated_structured_dataset_type(::nebulaidl::core::StructuredDatasetType* structured_dataset_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(structured_dataset_type_);
  }
  if (structured_dataset_type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      structured_dataset_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, structured_dataset_type, submessage_arena);
    }
    
  } else {
    
  }
  structured_dataset_type_ = structured_dataset_type;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDatasetMetadata.structured_dataset_type)
}

// -------------------------------------------------------------------

// StructuredDataset

// string uri = 1;
inline void StructuredDataset::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StructuredDataset::uri() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDataset.uri)
  return uri_.GetNoArena();
}
inline void StructuredDataset::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.StructuredDataset.uri)
}
#if LANG_CXX11
inline void StructuredDataset::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.StructuredDataset.uri)
}
#endif
inline void StructuredDataset::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.StructuredDataset.uri)
}
inline void StructuredDataset::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.StructuredDataset.uri)
}
inline ::std::string* StructuredDataset::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDataset.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructuredDataset::release_uri() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDataset.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructuredDataset::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDataset.uri)
}

// .nebulaidl.core.StructuredDatasetMetadata metadata = 2;
inline bool StructuredDataset::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline void StructuredDataset::clear_metadata() {
  if (GetArenaNoVirtual() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::nebulaidl::core::StructuredDatasetMetadata& StructuredDataset::metadata() const {
  const ::nebulaidl::core::StructuredDatasetMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDataset.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::StructuredDatasetMetadata*>(
      &::nebulaidl::core::_StructuredDatasetMetadata_default_instance_);
}
inline ::nebulaidl::core::StructuredDatasetMetadata* StructuredDataset::release_metadata() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDataset.metadata)
  
  ::nebulaidl::core::StructuredDatasetMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::StructuredDatasetMetadata* StructuredDataset::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::StructuredDatasetMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDataset.metadata)
  return metadata_;
}
inline void StructuredDataset::set_allocated_metadata(::nebulaidl::core::StructuredDatasetMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDataset.metadata)
}

// -------------------------------------------------------------------

// Scalar

// .nebulaidl.core.Primitive primitive = 1;
inline bool Scalar::has_primitive() const {
  return value_case() == kPrimitive;
}
inline void Scalar::set_has_primitive() {
  _oneof_case_[0] = kPrimitive;
}
inline void Scalar::clear_primitive() {
  if (has_primitive()) {
    delete value_.primitive_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Primitive* Scalar::release_primitive() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.primitive)
  if (has_primitive()) {
    clear_has_value();
      ::nebulaidl::core::Primitive* temp = value_.primitive_;
    value_.primitive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Primitive& Scalar::primitive() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.primitive)
  return has_primitive()
      ? *value_.primitive_
      : *reinterpret_cast< ::nebulaidl::core::Primitive*>(&::nebulaidl::core::_Primitive_default_instance_);
}
inline ::nebulaidl::core::Primitive* Scalar::mutable_primitive() {
  if (!has_primitive()) {
    clear_value();
    set_has_primitive();
    value_.primitive_ = CreateMaybeMessage< ::nebulaidl::core::Primitive >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.primitive)
  return value_.primitive_;
}

// .nebulaidl.core.Blob blob = 2;
inline bool Scalar::has_blob() const {
  return value_case() == kBlob;
}
inline void Scalar::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void Scalar::clear_blob() {
  if (has_blob()) {
    delete value_.blob_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Blob* Scalar::release_blob() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.blob)
  if (has_blob()) {
    clear_has_value();
      ::nebulaidl::core::Blob* temp = value_.blob_;
    value_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Blob& Scalar::blob() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.blob)
  return has_blob()
      ? *value_.blob_
      : *reinterpret_cast< ::nebulaidl::core::Blob*>(&::nebulaidl::core::_Blob_default_instance_);
}
inline ::nebulaidl::core::Blob* Scalar::mutable_blob() {
  if (!has_blob()) {
    clear_value();
    set_has_blob();
    value_.blob_ = CreateMaybeMessage< ::nebulaidl::core::Blob >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.blob)
  return value_.blob_;
}

// .nebulaidl.core.Binary binary = 3;
inline bool Scalar::has_binary() const {
  return value_case() == kBinary;
}
inline void Scalar::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Scalar::clear_binary() {
  if (has_binary()) {
    delete value_.binary_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Binary* Scalar::release_binary() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.binary)
  if (has_binary()) {
    clear_has_value();
      ::nebulaidl::core::Binary* temp = value_.binary_;
    value_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Binary& Scalar::binary() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.binary)
  return has_binary()
      ? *value_.binary_
      : *reinterpret_cast< ::nebulaidl::core::Binary*>(&::nebulaidl::core::_Binary_default_instance_);
}
inline ::nebulaidl::core::Binary* Scalar::mutable_binary() {
  if (!has_binary()) {
    clear_value();
    set_has_binary();
    value_.binary_ = CreateMaybeMessage< ::nebulaidl::core::Binary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.binary)
  return value_.binary_;
}

// .nebulaidl.core.Schema schema = 4;
inline bool Scalar::has_schema() const {
  return value_case() == kSchema;
}
inline void Scalar::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void Scalar::clear_schema() {
  if (has_schema()) {
    delete value_.schema_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Schema* Scalar::release_schema() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.schema)
  if (has_schema()) {
    clear_has_value();
      ::nebulaidl::core::Schema* temp = value_.schema_;
    value_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Schema& Scalar::schema() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.schema)
  return has_schema()
      ? *value_.schema_
      : *reinterpret_cast< ::nebulaidl::core::Schema*>(&::nebulaidl::core::_Schema_default_instance_);
}
inline ::nebulaidl::core::Schema* Scalar::mutable_schema() {
  if (!has_schema()) {
    clear_value();
    set_has_schema();
    value_.schema_ = CreateMaybeMessage< ::nebulaidl::core::Schema >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.schema)
  return value_.schema_;
}

// .nebulaidl.core.Void none_type = 5;
inline bool Scalar::has_none_type() const {
  return value_case() == kNoneType;
}
inline void Scalar::set_has_none_type() {
  _oneof_case_[0] = kNoneType;
}
inline void Scalar::clear_none_type() {
  if (has_none_type()) {
    delete value_.none_type_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Void* Scalar::release_none_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.none_type)
  if (has_none_type()) {
    clear_has_value();
      ::nebulaidl::core::Void* temp = value_.none_type_;
    value_.none_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Void& Scalar::none_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.none_type)
  return has_none_type()
      ? *value_.none_type_
      : *reinterpret_cast< ::nebulaidl::core::Void*>(&::nebulaidl::core::_Void_default_instance_);
}
inline ::nebulaidl::core::Void* Scalar::mutable_none_type() {
  if (!has_none_type()) {
    clear_value();
    set_has_none_type();
    value_.none_type_ = CreateMaybeMessage< ::nebulaidl::core::Void >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.none_type)
  return value_.none_type_;
}

// .nebulaidl.core.Error error = 6;
inline bool Scalar::has_error() const {
  return value_case() == kError;
}
inline void Scalar::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::nebulaidl::core::Error* Scalar::release_error() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.error)
  if (has_error()) {
    clear_has_value();
      ::nebulaidl::core::Error* temp = value_.error_;
    value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Error& Scalar::error() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.error)
  return has_error()
      ? *value_.error_
      : *reinterpret_cast< ::nebulaidl::core::Error*>(&::nebulaidl::core::_Error_default_instance_);
}
inline ::nebulaidl::core::Error* Scalar::mutable_error() {
  if (!has_error()) {
    clear_value();
    set_has_error();
    value_.error_ = CreateMaybeMessage< ::nebulaidl::core::Error >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.error)
  return value_.error_;
}

// .google.protobuf.Struct generic = 7;
inline bool Scalar::has_generic() const {
  return value_case() == kGeneric;
}
inline void Scalar::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline ::google::protobuf::Struct* Scalar::release_generic() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.generic)
  if (has_generic()) {
    clear_has_value();
      ::google::protobuf::Struct* temp = value_.generic_;
    value_.generic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Struct& Scalar::generic() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.generic)
  return has_generic()
      ? *value_.generic_
      : *reinterpret_cast< ::google::protobuf::Struct*>(&::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Scalar::mutable_generic() {
  if (!has_generic()) {
    clear_value();
    set_has_generic();
    value_.generic_ = CreateMaybeMessage< ::google::protobuf::Struct >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.generic)
  return value_.generic_;
}

// .nebulaidl.core.StructuredDataset structured_dataset = 8;
inline bool Scalar::has_structured_dataset() const {
  return value_case() == kStructuredDataset;
}
inline void Scalar::set_has_structured_dataset() {
  _oneof_case_[0] = kStructuredDataset;
}
inline void Scalar::clear_structured_dataset() {
  if (has_structured_dataset()) {
    delete value_.structured_dataset_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::StructuredDataset* Scalar::release_structured_dataset() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.structured_dataset)
  if (has_structured_dataset()) {
    clear_has_value();
      ::nebulaidl::core::StructuredDataset* temp = value_.structured_dataset_;
    value_.structured_dataset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::StructuredDataset& Scalar::structured_dataset() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.structured_dataset)
  return has_structured_dataset()
      ? *value_.structured_dataset_
      : *reinterpret_cast< ::nebulaidl::core::StructuredDataset*>(&::nebulaidl::core::_StructuredDataset_default_instance_);
}
inline ::nebulaidl::core::StructuredDataset* Scalar::mutable_structured_dataset() {
  if (!has_structured_dataset()) {
    clear_value();
    set_has_structured_dataset();
    value_.structured_dataset_ = CreateMaybeMessage< ::nebulaidl::core::StructuredDataset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.structured_dataset)
  return value_.structured_dataset_;
}

// .nebulaidl.core.Union union = 9;
inline bool Scalar::has_union_() const {
  return value_case() == kUnion;
}
inline void Scalar::set_has_union_() {
  _oneof_case_[0] = kUnion;
}
inline void Scalar::clear_union_() {
  if (has_union_()) {
    delete value_.union__;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Union* Scalar::release_union_() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Scalar.union)
  if (has_union_()) {
    clear_has_value();
      ::nebulaidl::core::Union* temp = value_.union__;
    value_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Union& Scalar::union_() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Scalar.union)
  return has_union_()
      ? *value_.union__
      : *reinterpret_cast< ::nebulaidl::core::Union*>(&::nebulaidl::core::_Union_default_instance_);
}
inline ::nebulaidl::core::Union* Scalar::mutable_union_() {
  if (!has_union_()) {
    clear_value();
    set_has_union_();
    value_.union__ = CreateMaybeMessage< ::nebulaidl::core::Union >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Scalar.union)
  return value_.union__;
}

inline bool Scalar::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Scalar::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Scalar::ValueCase Scalar::value_case() const {
  return Scalar::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Literal

// .nebulaidl.core.Scalar scalar = 1;
inline bool Literal::has_scalar() const {
  return value_case() == kScalar;
}
inline void Literal::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Literal::clear_scalar() {
  if (has_scalar()) {
    delete value_.scalar_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Scalar* Literal::release_scalar() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Literal.scalar)
  if (has_scalar()) {
    clear_has_value();
      ::nebulaidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Scalar& Literal::scalar() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Literal.scalar)
  return has_scalar()
      ? *value_.scalar_
      : *reinterpret_cast< ::nebulaidl::core::Scalar*>(&::nebulaidl::core::_Scalar_default_instance_);
}
inline ::nebulaidl::core::Scalar* Literal::mutable_scalar() {
  if (!has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = CreateMaybeMessage< ::nebulaidl::core::Scalar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Literal.scalar)
  return value_.scalar_;
}

// .nebulaidl.core.LiteralCollection collection = 2;
inline bool Literal::has_collection() const {
  return value_case() == kCollection;
}
inline void Literal::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Literal::clear_collection() {
  if (has_collection()) {
    delete value_.collection_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::LiteralCollection* Literal::release_collection() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Literal.collection)
  if (has_collection()) {
    clear_has_value();
      ::nebulaidl::core::LiteralCollection* temp = value_.collection_;
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::LiteralCollection& Literal::collection() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Literal.collection)
  return has_collection()
      ? *value_.collection_
      : *reinterpret_cast< ::nebulaidl::core::LiteralCollection*>(&::nebulaidl::core::_LiteralCollection_default_instance_);
}
inline ::nebulaidl::core::LiteralCollection* Literal::mutable_collection() {
  if (!has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = CreateMaybeMessage< ::nebulaidl::core::LiteralCollection >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Literal.collection)
  return value_.collection_;
}

// .nebulaidl.core.LiteralMap map = 3;
inline bool Literal::has_map() const {
  return value_case() == kMap;
}
inline void Literal::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Literal::clear_map() {
  if (has_map()) {
    delete value_.map_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::LiteralMap* Literal::release_map() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Literal.map)
  if (has_map()) {
    clear_has_value();
      ::nebulaidl::core::LiteralMap* temp = value_.map_;
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::LiteralMap& Literal::map() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Literal.map)
  return has_map()
      ? *value_.map_
      : *reinterpret_cast< ::nebulaidl::core::LiteralMap*>(&::nebulaidl::core::_LiteralMap_default_instance_);
}
inline ::nebulaidl::core::LiteralMap* Literal::mutable_map() {
  if (!has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = CreateMaybeMessage< ::nebulaidl::core::LiteralMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Literal.map)
  return value_.map_;
}

// string hash = 4;
inline void Literal::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Literal::hash() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Literal.hash)
  return hash_.GetNoArena();
}
inline void Literal::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Literal.hash)
}
#if LANG_CXX11
inline void Literal::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Literal.hash)
}
#endif
inline void Literal::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Literal.hash)
}
inline void Literal::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Literal.hash)
}
inline ::std::string* Literal::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Literal.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Literal::release_hash() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Literal.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Literal::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Literal.hash)
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LiteralCollection

// repeated .nebulaidl.core.Literal literals = 1;
inline int LiteralCollection::literals_size() const {
  return literals_.size();
}
inline void LiteralCollection::clear_literals() {
  literals_.Clear();
}
inline ::nebulaidl::core::Literal* LiteralCollection::mutable_literals(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralCollection.literals)
  return literals_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::Literal >*
LiteralCollection::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.LiteralCollection.literals)
  return &literals_;
}
inline const ::nebulaidl::core::Literal& LiteralCollection::literals(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralCollection.literals)
  return literals_.Get(index);
}
inline ::nebulaidl::core::Literal* LiteralCollection::add_literals() {
  // @@protoc_insertion_point(field_add:nebulaidl.core.LiteralCollection.literals)
  return literals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::Literal >&
LiteralCollection::literals() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.LiteralCollection.literals)
  return literals_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LiteralMap

// map<string, .nebulaidl.core.Literal> literals = 1;
inline int LiteralMap::literals_size() const {
  return literals_.size();
}
inline void LiteralMap::clear_literals() {
  literals_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::nebulaidl::core::Literal >&
LiteralMap::literals() const {
  // @@protoc_insertion_point(field_map:nebulaidl.core.LiteralMap.literals)
  return literals_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::nebulaidl::core::Literal >*
LiteralMap::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_map:nebulaidl.core.LiteralMap.literals)
  return literals_.MutableMap();
}

// -------------------------------------------------------------------

// BindingDataCollection

// repeated .nebulaidl.core.BindingData bindings = 1;
inline int BindingDataCollection::bindings_size() const {
  return bindings_.size();
}
inline void BindingDataCollection::clear_bindings() {
  bindings_.Clear();
}
inline ::nebulaidl::core::BindingData* BindingDataCollection::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BindingDataCollection.bindings)
  return bindings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::BindingData >*
BindingDataCollection::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.BindingDataCollection.bindings)
  return &bindings_;
}
inline const ::nebulaidl::core::BindingData& BindingDataCollection::bindings(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BindingDataCollection.bindings)
  return bindings_.Get(index);
}
inline ::nebulaidl::core::BindingData* BindingDataCollection::add_bindings() {
  // @@protoc_insertion_point(field_add:nebulaidl.core.BindingDataCollection.bindings)
  return bindings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::BindingData >&
BindingDataCollection::bindings() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.BindingDataCollection.bindings)
  return bindings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BindingDataMap

// map<string, .nebulaidl.core.BindingData> bindings = 1;
inline int BindingDataMap::bindings_size() const {
  return bindings_.size();
}
inline void BindingDataMap::clear_bindings() {
  bindings_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::nebulaidl::core::BindingData >&
BindingDataMap::bindings() const {
  // @@protoc_insertion_point(field_map:nebulaidl.core.BindingDataMap.bindings)
  return bindings_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::nebulaidl::core::BindingData >*
BindingDataMap::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_map:nebulaidl.core.BindingDataMap.bindings)
  return bindings_.MutableMap();
}

// -------------------------------------------------------------------

// UnionInfo

// .nebulaidl.core.LiteralType targetType = 1;
inline bool UnionInfo::has_targettype() const {
  return this != internal_default_instance() && targettype_ != nullptr;
}
inline const ::nebulaidl::core::LiteralType& UnionInfo::targettype() const {
  const ::nebulaidl::core::LiteralType* p = targettype_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.UnionInfo.targetType)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::LiteralType*>(
      &::nebulaidl::core::_LiteralType_default_instance_);
}
inline ::nebulaidl::core::LiteralType* UnionInfo::release_targettype() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.UnionInfo.targetType)
  
  ::nebulaidl::core::LiteralType* temp = targettype_;
  targettype_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::LiteralType* UnionInfo::mutable_targettype() {
  
  if (targettype_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::LiteralType>(GetArenaNoVirtual());
    targettype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.UnionInfo.targetType)
  return targettype_;
}
inline void UnionInfo::set_allocated_targettype(::nebulaidl::core::LiteralType* targettype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(targettype_);
  }
  if (targettype) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      targettype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, targettype, submessage_arena);
    }
    
  } else {
    
  }
  targettype_ = targettype;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.UnionInfo.targetType)
}

// -------------------------------------------------------------------

// BindingData

// .nebulaidl.core.Scalar scalar = 1;
inline bool BindingData::has_scalar() const {
  return value_case() == kScalar;
}
inline void BindingData::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void BindingData::clear_scalar() {
  if (has_scalar()) {
    delete value_.scalar_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::Scalar* BindingData::release_scalar() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BindingData.scalar)
  if (has_scalar()) {
    clear_has_value();
      ::nebulaidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::Scalar& BindingData::scalar() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BindingData.scalar)
  return has_scalar()
      ? *value_.scalar_
      : *reinterpret_cast< ::nebulaidl::core::Scalar*>(&::nebulaidl::core::_Scalar_default_instance_);
}
inline ::nebulaidl::core::Scalar* BindingData::mutable_scalar() {
  if (!has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = CreateMaybeMessage< ::nebulaidl::core::Scalar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BindingData.scalar)
  return value_.scalar_;
}

// .nebulaidl.core.BindingDataCollection collection = 2;
inline bool BindingData::has_collection() const {
  return value_case() == kCollection;
}
inline void BindingData::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void BindingData::clear_collection() {
  if (has_collection()) {
    delete value_.collection_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::BindingDataCollection* BindingData::release_collection() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BindingData.collection)
  if (has_collection()) {
    clear_has_value();
      ::nebulaidl::core::BindingDataCollection* temp = value_.collection_;
    value_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::BindingDataCollection& BindingData::collection() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BindingData.collection)
  return has_collection()
      ? *value_.collection_
      : *reinterpret_cast< ::nebulaidl::core::BindingDataCollection*>(&::nebulaidl::core::_BindingDataCollection_default_instance_);
}
inline ::nebulaidl::core::BindingDataCollection* BindingData::mutable_collection() {
  if (!has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = CreateMaybeMessage< ::nebulaidl::core::BindingDataCollection >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BindingData.collection)
  return value_.collection_;
}

// .nebulaidl.core.OutputReference promise = 3;
inline bool BindingData::has_promise() const {
  return value_case() == kPromise;
}
inline void BindingData::set_has_promise() {
  _oneof_case_[0] = kPromise;
}
inline ::nebulaidl::core::OutputReference* BindingData::release_promise() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BindingData.promise)
  if (has_promise()) {
    clear_has_value();
      ::nebulaidl::core::OutputReference* temp = value_.promise_;
    value_.promise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::OutputReference& BindingData::promise() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BindingData.promise)
  return has_promise()
      ? *value_.promise_
      : *reinterpret_cast< ::nebulaidl::core::OutputReference*>(&::nebulaidl::core::_OutputReference_default_instance_);
}
inline ::nebulaidl::core::OutputReference* BindingData::mutable_promise() {
  if (!has_promise()) {
    clear_value();
    set_has_promise();
    value_.promise_ = CreateMaybeMessage< ::nebulaidl::core::OutputReference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BindingData.promise)
  return value_.promise_;
}

// .nebulaidl.core.BindingDataMap map = 4;
inline bool BindingData::has_map() const {
  return value_case() == kMap;
}
inline void BindingData::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void BindingData::clear_map() {
  if (has_map()) {
    delete value_.map_;
    clear_has_value();
  }
}
inline ::nebulaidl::core::BindingDataMap* BindingData::release_map() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BindingData.map)
  if (has_map()) {
    clear_has_value();
      ::nebulaidl::core::BindingDataMap* temp = value_.map_;
    value_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::BindingDataMap& BindingData::map() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BindingData.map)
  return has_map()
      ? *value_.map_
      : *reinterpret_cast< ::nebulaidl::core::BindingDataMap*>(&::nebulaidl::core::_BindingDataMap_default_instance_);
}
inline ::nebulaidl::core::BindingDataMap* BindingData::mutable_map() {
  if (!has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = CreateMaybeMessage< ::nebulaidl::core::BindingDataMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BindingData.map)
  return value_.map_;
}

// .nebulaidl.core.UnionInfo union = 5;
inline bool BindingData::has_union_() const {
  return this != internal_default_instance() && union__ != nullptr;
}
inline void BindingData::clear_union_() {
  if (GetArenaNoVirtual() == nullptr && union__ != nullptr) {
    delete union__;
  }
  union__ = nullptr;
}
inline const ::nebulaidl::core::UnionInfo& BindingData::union_() const {
  const ::nebulaidl::core::UnionInfo* p = union__;
  // @@protoc_insertion_point(field_get:nebulaidl.core.BindingData.union)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::UnionInfo*>(
      &::nebulaidl::core::_UnionInfo_default_instance_);
}
inline ::nebulaidl::core::UnionInfo* BindingData::release_union_() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BindingData.union)
  
  ::nebulaidl::core::UnionInfo* temp = union__;
  union__ = nullptr;
  return temp;
}
inline ::nebulaidl::core::UnionInfo* BindingData::mutable_union_() {
  
  if (union__ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::UnionInfo>(GetArenaNoVirtual());
    union__ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BindingData.union)
  return union__;
}
inline void BindingData::set_allocated_union_(::nebulaidl::core::UnionInfo* union_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete union__;
  }
  if (union_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      union_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, union_, submessage_arena);
    }
    
  } else {
    
  }
  union__ = union_;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.BindingData.union)
}

inline bool BindingData::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BindingData::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline BindingData::ValueCase BindingData::value_case() const {
  return BindingData::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Binding

// string var = 1;
inline void Binding::clear_var() {
  var_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binding::var() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Binding.var)
  return var_.GetNoArena();
}
inline void Binding::set_var(const ::std::string& value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Binding.var)
}
#if LANG_CXX11
inline void Binding::set_var(::std::string&& value) {
  
  var_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Binding.var)
}
#endif
inline void Binding::set_var(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Binding.var)
}
inline void Binding::set_var(const char* value, size_t size) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Binding.var)
}
inline ::std::string* Binding::mutable_var() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Binding.var)
  return var_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binding::release_var() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Binding.var)
  
  return var_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binding::set_allocated_var(::std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  var_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), var);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Binding.var)
}

// .nebulaidl.core.BindingData binding = 2;
inline bool Binding::has_binding() const {
  return this != internal_default_instance() && binding_ != nullptr;
}
inline void Binding::clear_binding() {
  if (GetArenaNoVirtual() == nullptr && binding_ != nullptr) {
    delete binding_;
  }
  binding_ = nullptr;
}
inline const ::nebulaidl::core::BindingData& Binding::binding() const {
  const ::nebulaidl::core::BindingData* p = binding_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.Binding.binding)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::BindingData*>(
      &::nebulaidl::core::_BindingData_default_instance_);
}
inline ::nebulaidl::core::BindingData* Binding::release_binding() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Binding.binding)
  
  ::nebulaidl::core::BindingData* temp = binding_;
  binding_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::BindingData* Binding::mutable_binding() {
  
  if (binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::BindingData>(GetArenaNoVirtual());
    binding_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Binding.binding)
  return binding_;
}
inline void Binding::set_allocated_binding(::nebulaidl::core::BindingData* binding) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete binding_;
  }
  if (binding) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      binding = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    
  } else {
    
  }
  binding_ = binding;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Binding.binding)
}

// -------------------------------------------------------------------

// KeyValuePair

// string key = 1;
inline void KeyValuePair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.KeyValuePair.key)
  return key_.GetNoArena();
}
inline void KeyValuePair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.KeyValuePair.key)
}
#if LANG_CXX11
inline void KeyValuePair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.KeyValuePair.key)
}
#endif
inline void KeyValuePair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.KeyValuePair.key)
}
inline void KeyValuePair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.KeyValuePair.key)
}
inline ::std::string* KeyValuePair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.KeyValuePair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.KeyValuePair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.KeyValuePair.key)
}

// string value = 2;
inline void KeyValuePair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.KeyValuePair.value)
  return value_.GetNoArena();
}
inline void KeyValuePair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.KeyValuePair.value)
}
#if LANG_CXX11
inline void KeyValuePair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.KeyValuePair.value)
}
#endif
inline void KeyValuePair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.KeyValuePair.value)
}
inline void KeyValuePair::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.KeyValuePair.value)
}
inline ::std::string* KeyValuePair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.KeyValuePair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.KeyValuePair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.KeyValuePair.value)
}

// -------------------------------------------------------------------

// RetryStrategy

// uint32 retries = 5;
inline void RetryStrategy::clear_retries() {
  retries_ = 0u;
}
inline ::google::protobuf::uint32 RetryStrategy::retries() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.RetryStrategy.retries)
  return retries_;
}
inline void RetryStrategy::set_retries(::google::protobuf::uint32 value) {
  
  retries_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.RetryStrategy.retries)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace nebulaidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_nebulaidl_2fcore_2fliterals_2eproto
