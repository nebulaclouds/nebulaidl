// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nebulaidl/core/types.proto

#ifndef PROTOBUF_INCLUDED_nebulaidl_2fcore_2ftypes_2eproto
#define PROTOBUF_INCLUDED_nebulaidl_2fcore_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nebulaidl_2fcore_2ftypes_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_nebulaidl_2fcore_2ftypes_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_nebulaidl_2fcore_2ftypes_2eproto();
namespace nebulaidl {
namespace core {
class BlobType;
class BlobTypeDefaultTypeInternal;
extern BlobTypeDefaultTypeInternal _BlobType_default_instance_;
class EnumType;
class EnumTypeDefaultTypeInternal;
extern EnumTypeDefaultTypeInternal _EnumType_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class LiteralType;
class LiteralTypeDefaultTypeInternal;
extern LiteralTypeDefaultTypeInternal _LiteralType_default_instance_;
class OutputReference;
class OutputReferenceDefaultTypeInternal;
extern OutputReferenceDefaultTypeInternal _OutputReference_default_instance_;
class PromiseAttribute;
class PromiseAttributeDefaultTypeInternal;
extern PromiseAttributeDefaultTypeInternal _PromiseAttribute_default_instance_;
class SchemaType;
class SchemaTypeDefaultTypeInternal;
extern SchemaTypeDefaultTypeInternal _SchemaType_default_instance_;
class SchemaType_SchemaColumn;
class SchemaType_SchemaColumnDefaultTypeInternal;
extern SchemaType_SchemaColumnDefaultTypeInternal _SchemaType_SchemaColumn_default_instance_;
class StructuredDatasetType;
class StructuredDatasetTypeDefaultTypeInternal;
extern StructuredDatasetTypeDefaultTypeInternal _StructuredDatasetType_default_instance_;
class StructuredDatasetType_DatasetColumn;
class StructuredDatasetType_DatasetColumnDefaultTypeInternal;
extern StructuredDatasetType_DatasetColumnDefaultTypeInternal _StructuredDatasetType_DatasetColumn_default_instance_;
class TypeAnnotation;
class TypeAnnotationDefaultTypeInternal;
extern TypeAnnotationDefaultTypeInternal _TypeAnnotation_default_instance_;
class TypeStructure;
class TypeStructureDefaultTypeInternal;
extern TypeStructureDefaultTypeInternal _TypeStructure_default_instance_;
class UnionType;
class UnionTypeDefaultTypeInternal;
extern UnionTypeDefaultTypeInternal _UnionType_default_instance_;
}  // namespace core
}  // namespace nebulaidl
namespace google {
namespace protobuf {
template<> ::nebulaidl::core::BlobType* Arena::CreateMaybeMessage<::nebulaidl::core::BlobType>(Arena*);
template<> ::nebulaidl::core::EnumType* Arena::CreateMaybeMessage<::nebulaidl::core::EnumType>(Arena*);
template<> ::nebulaidl::core::Error* Arena::CreateMaybeMessage<::nebulaidl::core::Error>(Arena*);
template<> ::nebulaidl::core::LiteralType* Arena::CreateMaybeMessage<::nebulaidl::core::LiteralType>(Arena*);
template<> ::nebulaidl::core::OutputReference* Arena::CreateMaybeMessage<::nebulaidl::core::OutputReference>(Arena*);
template<> ::nebulaidl::core::PromiseAttribute* Arena::CreateMaybeMessage<::nebulaidl::core::PromiseAttribute>(Arena*);
template<> ::nebulaidl::core::SchemaType* Arena::CreateMaybeMessage<::nebulaidl::core::SchemaType>(Arena*);
template<> ::nebulaidl::core::SchemaType_SchemaColumn* Arena::CreateMaybeMessage<::nebulaidl::core::SchemaType_SchemaColumn>(Arena*);
template<> ::nebulaidl::core::StructuredDatasetType* Arena::CreateMaybeMessage<::nebulaidl::core::StructuredDatasetType>(Arena*);
template<> ::nebulaidl::core::StructuredDatasetType_DatasetColumn* Arena::CreateMaybeMessage<::nebulaidl::core::StructuredDatasetType_DatasetColumn>(Arena*);
template<> ::nebulaidl::core::TypeAnnotation* Arena::CreateMaybeMessage<::nebulaidl::core::TypeAnnotation>(Arena*);
template<> ::nebulaidl::core::TypeStructure* Arena::CreateMaybeMessage<::nebulaidl::core::TypeStructure>(Arena*);
template<> ::nebulaidl::core::UnionType* Arena::CreateMaybeMessage<::nebulaidl::core::UnionType>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nebulaidl {
namespace core {

enum SchemaType_SchemaColumn_SchemaColumnType {
  SchemaType_SchemaColumn_SchemaColumnType_INTEGER = 0,
  SchemaType_SchemaColumn_SchemaColumnType_FLOAT = 1,
  SchemaType_SchemaColumn_SchemaColumnType_STRING = 2,
  SchemaType_SchemaColumn_SchemaColumnType_BOOLEAN = 3,
  SchemaType_SchemaColumn_SchemaColumnType_DATETIME = 4,
  SchemaType_SchemaColumn_SchemaColumnType_DURATION = 5,
  SchemaType_SchemaColumn_SchemaColumnType_SchemaType_SchemaColumn_SchemaColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SchemaType_SchemaColumn_SchemaColumnType_SchemaType_SchemaColumn_SchemaColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SchemaType_SchemaColumn_SchemaColumnType_IsValid(int value);
const SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MIN = SchemaType_SchemaColumn_SchemaColumnType_INTEGER;
const SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MAX = SchemaType_SchemaColumn_SchemaColumnType_DURATION;
const int SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_ARRAYSIZE = SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SchemaType_SchemaColumn_SchemaColumnType_descriptor();
inline const ::std::string& SchemaType_SchemaColumn_SchemaColumnType_Name(SchemaType_SchemaColumn_SchemaColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SchemaType_SchemaColumn_SchemaColumnType_descriptor(), value);
}
inline bool SchemaType_SchemaColumn_SchemaColumnType_Parse(
    const ::std::string& name, SchemaType_SchemaColumn_SchemaColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SchemaType_SchemaColumn_SchemaColumnType>(
    SchemaType_SchemaColumn_SchemaColumnType_descriptor(), name, value);
}
enum BlobType_BlobDimensionality {
  BlobType_BlobDimensionality_SINGLE = 0,
  BlobType_BlobDimensionality_MULTIPART = 1,
  BlobType_BlobDimensionality_BlobType_BlobDimensionality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  BlobType_BlobDimensionality_BlobType_BlobDimensionality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool BlobType_BlobDimensionality_IsValid(int value);
const BlobType_BlobDimensionality BlobType_BlobDimensionality_BlobDimensionality_MIN = BlobType_BlobDimensionality_SINGLE;
const BlobType_BlobDimensionality BlobType_BlobDimensionality_BlobDimensionality_MAX = BlobType_BlobDimensionality_MULTIPART;
const int BlobType_BlobDimensionality_BlobDimensionality_ARRAYSIZE = BlobType_BlobDimensionality_BlobDimensionality_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlobType_BlobDimensionality_descriptor();
inline const ::std::string& BlobType_BlobDimensionality_Name(BlobType_BlobDimensionality value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlobType_BlobDimensionality_descriptor(), value);
}
inline bool BlobType_BlobDimensionality_Parse(
    const ::std::string& name, BlobType_BlobDimensionality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlobType_BlobDimensionality>(
    BlobType_BlobDimensionality_descriptor(), name, value);
}
enum SimpleType {
  NONE = 0,
  INTEGER = 1,
  FLOAT = 2,
  STRING = 3,
  BOOLEAN = 4,
  DATETIME = 5,
  DURATION = 6,
  BINARY = 7,
  ERROR = 8,
  STRUCT = 9,
  SimpleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SimpleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SimpleType_IsValid(int value);
const SimpleType SimpleType_MIN = NONE;
const SimpleType SimpleType_MAX = STRUCT;
const int SimpleType_ARRAYSIZE = SimpleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SimpleType_descriptor();
inline const ::std::string& SimpleType_Name(SimpleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SimpleType_descriptor(), value);
}
inline bool SimpleType_Parse(
    const ::std::string& name, SimpleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SimpleType>(
    SimpleType_descriptor(), name, value);
}
// ===================================================================

class SchemaType_SchemaColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.SchemaType.SchemaColumn) */ {
 public:
  SchemaType_SchemaColumn();
  virtual ~SchemaType_SchemaColumn();

  SchemaType_SchemaColumn(const SchemaType_SchemaColumn& from);

  inline SchemaType_SchemaColumn& operator=(const SchemaType_SchemaColumn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SchemaType_SchemaColumn(SchemaType_SchemaColumn&& from) noexcept
    : SchemaType_SchemaColumn() {
    *this = ::std::move(from);
  }

  inline SchemaType_SchemaColumn& operator=(SchemaType_SchemaColumn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SchemaType_SchemaColumn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaType_SchemaColumn* internal_default_instance() {
    return reinterpret_cast<const SchemaType_SchemaColumn*>(
               &_SchemaType_SchemaColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SchemaType_SchemaColumn* other);
  friend void swap(SchemaType_SchemaColumn& a, SchemaType_SchemaColumn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SchemaType_SchemaColumn* New() const final {
    return CreateMaybeMessage<SchemaType_SchemaColumn>(nullptr);
  }

  SchemaType_SchemaColumn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SchemaType_SchemaColumn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SchemaType_SchemaColumn& from);
  void MergeFrom(const SchemaType_SchemaColumn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaType_SchemaColumn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SchemaType_SchemaColumn_SchemaColumnType SchemaColumnType;
  static const SchemaColumnType INTEGER =
    SchemaType_SchemaColumn_SchemaColumnType_INTEGER;
  static const SchemaColumnType FLOAT =
    SchemaType_SchemaColumn_SchemaColumnType_FLOAT;
  static const SchemaColumnType STRING =
    SchemaType_SchemaColumn_SchemaColumnType_STRING;
  static const SchemaColumnType BOOLEAN =
    SchemaType_SchemaColumn_SchemaColumnType_BOOLEAN;
  static const SchemaColumnType DATETIME =
    SchemaType_SchemaColumn_SchemaColumnType_DATETIME;
  static const SchemaColumnType DURATION =
    SchemaType_SchemaColumn_SchemaColumnType_DURATION;
  static inline bool SchemaColumnType_IsValid(int value) {
    return SchemaType_SchemaColumn_SchemaColumnType_IsValid(value);
  }
  static const SchemaColumnType SchemaColumnType_MIN =
    SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MIN;
  static const SchemaColumnType SchemaColumnType_MAX =
    SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_MAX;
  static const int SchemaColumnType_ARRAYSIZE =
    SchemaType_SchemaColumn_SchemaColumnType_SchemaColumnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SchemaColumnType_descriptor() {
    return SchemaType_SchemaColumn_SchemaColumnType_descriptor();
  }
  static inline const ::std::string& SchemaColumnType_Name(SchemaColumnType value) {
    return SchemaType_SchemaColumn_SchemaColumnType_Name(value);
  }
  static inline bool SchemaColumnType_Parse(const ::std::string& name,
      SchemaColumnType* value) {
    return SchemaType_SchemaColumn_SchemaColumnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .nebulaidl.core.SchemaType.SchemaColumn.SchemaColumnType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType type() const;
  void set_type(::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType value);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.SchemaType.SchemaColumn)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SchemaType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.SchemaType) */ {
 public:
  SchemaType();
  virtual ~SchemaType();

  SchemaType(const SchemaType& from);

  inline SchemaType& operator=(const SchemaType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SchemaType(SchemaType&& from) noexcept
    : SchemaType() {
    *this = ::std::move(from);
  }

  inline SchemaType& operator=(SchemaType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SchemaType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaType* internal_default_instance() {
    return reinterpret_cast<const SchemaType*>(
               &_SchemaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SchemaType* other);
  friend void swap(SchemaType& a, SchemaType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SchemaType* New() const final {
    return CreateMaybeMessage<SchemaType>(nullptr);
  }

  SchemaType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SchemaType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SchemaType& from);
  void MergeFrom(const SchemaType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SchemaType_SchemaColumn SchemaColumn;

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.SchemaType.SchemaColumn columns = 3;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 3;
  ::nebulaidl::core::SchemaType_SchemaColumn* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::SchemaType_SchemaColumn >*
      mutable_columns();
  const ::nebulaidl::core::SchemaType_SchemaColumn& columns(int index) const;
  ::nebulaidl::core::SchemaType_SchemaColumn* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::SchemaType_SchemaColumn >&
      columns() const;

  // @@protoc_insertion_point(class_scope:nebulaidl.core.SchemaType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::SchemaType_SchemaColumn > columns_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class StructuredDatasetType_DatasetColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.StructuredDatasetType.DatasetColumn) */ {
 public:
  StructuredDatasetType_DatasetColumn();
  virtual ~StructuredDatasetType_DatasetColumn();

  StructuredDatasetType_DatasetColumn(const StructuredDatasetType_DatasetColumn& from);

  inline StructuredDatasetType_DatasetColumn& operator=(const StructuredDatasetType_DatasetColumn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StructuredDatasetType_DatasetColumn(StructuredDatasetType_DatasetColumn&& from) noexcept
    : StructuredDatasetType_DatasetColumn() {
    *this = ::std::move(from);
  }

  inline StructuredDatasetType_DatasetColumn& operator=(StructuredDatasetType_DatasetColumn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StructuredDatasetType_DatasetColumn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StructuredDatasetType_DatasetColumn* internal_default_instance() {
    return reinterpret_cast<const StructuredDatasetType_DatasetColumn*>(
               &_StructuredDatasetType_DatasetColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(StructuredDatasetType_DatasetColumn* other);
  friend void swap(StructuredDatasetType_DatasetColumn& a, StructuredDatasetType_DatasetColumn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StructuredDatasetType_DatasetColumn* New() const final {
    return CreateMaybeMessage<StructuredDatasetType_DatasetColumn>(nullptr);
  }

  StructuredDatasetType_DatasetColumn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StructuredDatasetType_DatasetColumn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StructuredDatasetType_DatasetColumn& from);
  void MergeFrom(const StructuredDatasetType_DatasetColumn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDatasetType_DatasetColumn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .nebulaidl.core.LiteralType literal_type = 2;
  bool has_literal_type() const;
  void clear_literal_type();
  static const int kLiteralTypeFieldNumber = 2;
  const ::nebulaidl::core::LiteralType& literal_type() const;
  ::nebulaidl::core::LiteralType* release_literal_type();
  ::nebulaidl::core::LiteralType* mutable_literal_type();
  void set_allocated_literal_type(::nebulaidl::core::LiteralType* literal_type);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.StructuredDatasetType.DatasetColumn)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::nebulaidl::core::LiteralType* literal_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class StructuredDatasetType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.StructuredDatasetType) */ {
 public:
  StructuredDatasetType();
  virtual ~StructuredDatasetType();

  StructuredDatasetType(const StructuredDatasetType& from);

  inline StructuredDatasetType& operator=(const StructuredDatasetType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StructuredDatasetType(StructuredDatasetType&& from) noexcept
    : StructuredDatasetType() {
    *this = ::std::move(from);
  }

  inline StructuredDatasetType& operator=(StructuredDatasetType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StructuredDatasetType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StructuredDatasetType* internal_default_instance() {
    return reinterpret_cast<const StructuredDatasetType*>(
               &_StructuredDatasetType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StructuredDatasetType* other);
  friend void swap(StructuredDatasetType& a, StructuredDatasetType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StructuredDatasetType* New() const final {
    return CreateMaybeMessage<StructuredDatasetType>(nullptr);
  }

  StructuredDatasetType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StructuredDatasetType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StructuredDatasetType& from);
  void MergeFrom(const StructuredDatasetType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructuredDatasetType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StructuredDatasetType_DatasetColumn DatasetColumn;

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.StructuredDatasetType.DatasetColumn columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  ::nebulaidl::core::StructuredDatasetType_DatasetColumn* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::StructuredDatasetType_DatasetColumn >*
      mutable_columns();
  const ::nebulaidl::core::StructuredDatasetType_DatasetColumn& columns(int index) const;
  ::nebulaidl::core::StructuredDatasetType_DatasetColumn* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::StructuredDatasetType_DatasetColumn >&
      columns() const;

  // string format = 2;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // string external_schema_type = 3;
  void clear_external_schema_type();
  static const int kExternalSchemaTypeFieldNumber = 3;
  const ::std::string& external_schema_type() const;
  void set_external_schema_type(const ::std::string& value);
  #if LANG_CXX11
  void set_external_schema_type(::std::string&& value);
  #endif
  void set_external_schema_type(const char* value);
  void set_external_schema_type(const char* value, size_t size);
  ::std::string* mutable_external_schema_type();
  ::std::string* release_external_schema_type();
  void set_allocated_external_schema_type(::std::string* external_schema_type);

  // bytes external_schema_bytes = 4;
  void clear_external_schema_bytes();
  static const int kExternalSchemaBytesFieldNumber = 4;
  const ::std::string& external_schema_bytes() const;
  void set_external_schema_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_external_schema_bytes(::std::string&& value);
  #endif
  void set_external_schema_bytes(const char* value);
  void set_external_schema_bytes(const void* value, size_t size);
  ::std::string* mutable_external_schema_bytes();
  ::std::string* release_external_schema_bytes();
  void set_allocated_external_schema_bytes(::std::string* external_schema_bytes);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.StructuredDatasetType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::StructuredDatasetType_DatasetColumn > columns_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::google::protobuf::internal::ArenaStringPtr external_schema_type_;
  ::google::protobuf::internal::ArenaStringPtr external_schema_bytes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BlobType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.BlobType) */ {
 public:
  BlobType();
  virtual ~BlobType();

  BlobType(const BlobType& from);

  inline BlobType& operator=(const BlobType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobType(BlobType&& from) noexcept
    : BlobType() {
    *this = ::std::move(from);
  }

  inline BlobType& operator=(BlobType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlobType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobType* internal_default_instance() {
    return reinterpret_cast<const BlobType*>(
               &_BlobType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BlobType* other);
  friend void swap(BlobType& a, BlobType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobType* New() const final {
    return CreateMaybeMessage<BlobType>(nullptr);
  }

  BlobType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlobType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlobType& from);
  void MergeFrom(const BlobType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlobType_BlobDimensionality BlobDimensionality;
  static const BlobDimensionality SINGLE =
    BlobType_BlobDimensionality_SINGLE;
  static const BlobDimensionality MULTIPART =
    BlobType_BlobDimensionality_MULTIPART;
  static inline bool BlobDimensionality_IsValid(int value) {
    return BlobType_BlobDimensionality_IsValid(value);
  }
  static const BlobDimensionality BlobDimensionality_MIN =
    BlobType_BlobDimensionality_BlobDimensionality_MIN;
  static const BlobDimensionality BlobDimensionality_MAX =
    BlobType_BlobDimensionality_BlobDimensionality_MAX;
  static const int BlobDimensionality_ARRAYSIZE =
    BlobType_BlobDimensionality_BlobDimensionality_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BlobDimensionality_descriptor() {
    return BlobType_BlobDimensionality_descriptor();
  }
  static inline const ::std::string& BlobDimensionality_Name(BlobDimensionality value) {
    return BlobType_BlobDimensionality_Name(value);
  }
  static inline bool BlobDimensionality_Parse(const ::std::string& name,
      BlobDimensionality* value) {
    return BlobType_BlobDimensionality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string format = 1;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // .nebulaidl.core.BlobType.BlobDimensionality dimensionality = 2;
  void clear_dimensionality();
  static const int kDimensionalityFieldNumber = 2;
  ::nebulaidl::core::BlobType_BlobDimensionality dimensionality() const;
  void set_dimensionality(::nebulaidl::core::BlobType_BlobDimensionality value);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.BlobType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  int dimensionality_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class EnumType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.EnumType) */ {
 public:
  EnumType();
  virtual ~EnumType();

  EnumType(const EnumType& from);

  inline EnumType& operator=(const EnumType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnumType(EnumType&& from) noexcept
    : EnumType() {
    *this = ::std::move(from);
  }

  inline EnumType& operator=(EnumType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EnumType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnumType* internal_default_instance() {
    return reinterpret_cast<const EnumType*>(
               &_EnumType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(EnumType* other);
  friend void swap(EnumType& a, EnumType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnumType* New() const final {
    return CreateMaybeMessage<EnumType>(nullptr);
  }

  EnumType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnumType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnumType& from);
  void MergeFrom(const EnumType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:nebulaidl.core.EnumType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class UnionType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.UnionType) */ {
 public:
  UnionType();
  virtual ~UnionType();

  UnionType(const UnionType& from);

  inline UnionType& operator=(const UnionType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnionType(UnionType&& from) noexcept
    : UnionType() {
    *this = ::std::move(from);
  }

  inline UnionType& operator=(UnionType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UnionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnionType* internal_default_instance() {
    return reinterpret_cast<const UnionType*>(
               &_UnionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UnionType* other);
  friend void swap(UnionType& a, UnionType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnionType* New() const final {
    return CreateMaybeMessage<UnionType>(nullptr);
  }

  UnionType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnionType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnionType& from);
  void MergeFrom(const UnionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnionType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.LiteralType variants = 1;
  int variants_size() const;
  void clear_variants();
  static const int kVariantsFieldNumber = 1;
  ::nebulaidl::core::LiteralType* mutable_variants(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::LiteralType >*
      mutable_variants();
  const ::nebulaidl::core::LiteralType& variants(int index) const;
  ::nebulaidl::core::LiteralType* add_variants();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::LiteralType >&
      variants() const;

  // @@protoc_insertion_point(class_scope:nebulaidl.core.UnionType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::LiteralType > variants_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class TypeStructure final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.TypeStructure) */ {
 public:
  TypeStructure();
  virtual ~TypeStructure();

  TypeStructure(const TypeStructure& from);

  inline TypeStructure& operator=(const TypeStructure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TypeStructure(TypeStructure&& from) noexcept
    : TypeStructure() {
    *this = ::std::move(from);
  }

  inline TypeStructure& operator=(TypeStructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TypeStructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TypeStructure* internal_default_instance() {
    return reinterpret_cast<const TypeStructure*>(
               &_TypeStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TypeStructure* other);
  friend void swap(TypeStructure& a, TypeStructure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TypeStructure* New() const final {
    return CreateMaybeMessage<TypeStructure>(nullptr);
  }

  TypeStructure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TypeStructure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TypeStructure& from);
  void MergeFrom(const TypeStructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeStructure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tag = 1;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.TypeStructure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class TypeAnnotation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.TypeAnnotation) */ {
 public:
  TypeAnnotation();
  virtual ~TypeAnnotation();

  TypeAnnotation(const TypeAnnotation& from);

  inline TypeAnnotation& operator=(const TypeAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TypeAnnotation(TypeAnnotation&& from) noexcept
    : TypeAnnotation() {
    *this = ::std::move(from);
  }

  inline TypeAnnotation& operator=(TypeAnnotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TypeAnnotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TypeAnnotation* internal_default_instance() {
    return reinterpret_cast<const TypeAnnotation*>(
               &_TypeAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TypeAnnotation* other);
  friend void swap(TypeAnnotation& a, TypeAnnotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TypeAnnotation* New() const final {
    return CreateMaybeMessage<TypeAnnotation>(nullptr);
  }

  TypeAnnotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TypeAnnotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TypeAnnotation& from);
  void MergeFrom(const TypeAnnotation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeAnnotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Struct annotations = 1;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 1;
  const ::google::protobuf::Struct& annotations() const;
  ::google::protobuf::Struct* release_annotations();
  ::google::protobuf::Struct* mutable_annotations();
  void set_allocated_annotations(::google::protobuf::Struct* annotations);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.TypeAnnotation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Struct* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LiteralType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.LiteralType) */ {
 public:
  LiteralType();
  virtual ~LiteralType();

  LiteralType(const LiteralType& from);

  inline LiteralType& operator=(const LiteralType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralType(LiteralType&& from) noexcept
    : LiteralType() {
    *this = ::std::move(from);
  }

  inline LiteralType& operator=(LiteralType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiteralType& default_instance();

  enum TypeCase {
    kSimple = 1,
    kSchema = 2,
    kCollectionType = 3,
    kMapValueType = 4,
    kBlob = 5,
    kEnumType = 7,
    kStructuredDatasetType = 8,
    kUnionType = 10,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralType* internal_default_instance() {
    return reinterpret_cast<const LiteralType*>(
               &_LiteralType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(LiteralType* other);
  friend void swap(LiteralType& a, LiteralType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralType* New() const final {
    return CreateMaybeMessage<LiteralType>(nullptr);
  }

  LiteralType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiteralType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiteralType& from);
  void MergeFrom(const LiteralType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Struct metadata = 6;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::google::protobuf::Struct& metadata() const;
  ::google::protobuf::Struct* release_metadata();
  ::google::protobuf::Struct* mutable_metadata();
  void set_allocated_metadata(::google::protobuf::Struct* metadata);

  // .nebulaidl.core.TypeAnnotation annotation = 9;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 9;
  const ::nebulaidl::core::TypeAnnotation& annotation() const;
  ::nebulaidl::core::TypeAnnotation* release_annotation();
  ::nebulaidl::core::TypeAnnotation* mutable_annotation();
  void set_allocated_annotation(::nebulaidl::core::TypeAnnotation* annotation);

  // .nebulaidl.core.TypeStructure structure = 11;
  bool has_structure() const;
  void clear_structure();
  static const int kStructureFieldNumber = 11;
  const ::nebulaidl::core::TypeStructure& structure() const;
  ::nebulaidl::core::TypeStructure* release_structure();
  ::nebulaidl::core::TypeStructure* mutable_structure();
  void set_allocated_structure(::nebulaidl::core::TypeStructure* structure);

  // .nebulaidl.core.SimpleType simple = 1;
  private:
  bool has_simple() const;
  public:
  void clear_simple();
  static const int kSimpleFieldNumber = 1;
  ::nebulaidl::core::SimpleType simple() const;
  void set_simple(::nebulaidl::core::SimpleType value);

  // .nebulaidl.core.SchemaType schema = 2;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 2;
  const ::nebulaidl::core::SchemaType& schema() const;
  ::nebulaidl::core::SchemaType* release_schema();
  ::nebulaidl::core::SchemaType* mutable_schema();
  void set_allocated_schema(::nebulaidl::core::SchemaType* schema);

  // .nebulaidl.core.LiteralType collection_type = 3;
  bool has_collection_type() const;
  void clear_collection_type();
  static const int kCollectionTypeFieldNumber = 3;
  const ::nebulaidl::core::LiteralType& collection_type() const;
  ::nebulaidl::core::LiteralType* release_collection_type();
  ::nebulaidl::core::LiteralType* mutable_collection_type();
  void set_allocated_collection_type(::nebulaidl::core::LiteralType* collection_type);

  // .nebulaidl.core.LiteralType map_value_type = 4;
  bool has_map_value_type() const;
  void clear_map_value_type();
  static const int kMapValueTypeFieldNumber = 4;
  const ::nebulaidl::core::LiteralType& map_value_type() const;
  ::nebulaidl::core::LiteralType* release_map_value_type();
  ::nebulaidl::core::LiteralType* mutable_map_value_type();
  void set_allocated_map_value_type(::nebulaidl::core::LiteralType* map_value_type);

  // .nebulaidl.core.BlobType blob = 5;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 5;
  const ::nebulaidl::core::BlobType& blob() const;
  ::nebulaidl::core::BlobType* release_blob();
  ::nebulaidl::core::BlobType* mutable_blob();
  void set_allocated_blob(::nebulaidl::core::BlobType* blob);

  // .nebulaidl.core.EnumType enum_type = 7;
  bool has_enum_type() const;
  void clear_enum_type();
  static const int kEnumTypeFieldNumber = 7;
  const ::nebulaidl::core::EnumType& enum_type() const;
  ::nebulaidl::core::EnumType* release_enum_type();
  ::nebulaidl::core::EnumType* mutable_enum_type();
  void set_allocated_enum_type(::nebulaidl::core::EnumType* enum_type);

  // .nebulaidl.core.StructuredDatasetType structured_dataset_type = 8;
  bool has_structured_dataset_type() const;
  void clear_structured_dataset_type();
  static const int kStructuredDatasetTypeFieldNumber = 8;
  const ::nebulaidl::core::StructuredDatasetType& structured_dataset_type() const;
  ::nebulaidl::core::StructuredDatasetType* release_structured_dataset_type();
  ::nebulaidl::core::StructuredDatasetType* mutable_structured_dataset_type();
  void set_allocated_structured_dataset_type(::nebulaidl::core::StructuredDatasetType* structured_dataset_type);

  // .nebulaidl.core.UnionType union_type = 10;
  bool has_union_type() const;
  void clear_union_type();
  static const int kUnionTypeFieldNumber = 10;
  const ::nebulaidl::core::UnionType& union_type() const;
  ::nebulaidl::core::UnionType* release_union_type();
  ::nebulaidl::core::UnionType* mutable_union_type();
  void set_allocated_union_type(::nebulaidl::core::UnionType* union_type);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.core.LiteralType)
 private:
  class HasBitSetters;
  void set_has_simple();
  void set_has_schema();
  void set_has_collection_type();
  void set_has_map_value_type();
  void set_has_blob();
  void set_has_enum_type();
  void set_has_structured_dataset_type();
  void set_has_union_type();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Struct* metadata_;
  ::nebulaidl::core::TypeAnnotation* annotation_;
  ::nebulaidl::core::TypeStructure* structure_;
  union TypeUnion {
    TypeUnion() {}
    int simple_;
    ::nebulaidl::core::SchemaType* schema_;
    ::nebulaidl::core::LiteralType* collection_type_;
    ::nebulaidl::core::LiteralType* map_value_type_;
    ::nebulaidl::core::BlobType* blob_;
    ::nebulaidl::core::EnumType* enum_type_;
    ::nebulaidl::core::StructuredDatasetType* structured_dataset_type_;
    ::nebulaidl::core::UnionType* union_type_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class OutputReference final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.OutputReference) */ {
 public:
  OutputReference();
  virtual ~OutputReference();

  OutputReference(const OutputReference& from);

  inline OutputReference& operator=(const OutputReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputReference(OutputReference&& from) noexcept
    : OutputReference() {
    *this = ::std::move(from);
  }

  inline OutputReference& operator=(OutputReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OutputReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputReference* internal_default_instance() {
    return reinterpret_cast<const OutputReference*>(
               &_OutputReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(OutputReference* other);
  friend void swap(OutputReference& a, OutputReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputReference* New() const final {
    return CreateMaybeMessage<OutputReference>(nullptr);
  }

  OutputReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OutputReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OutputReference& from);
  void MergeFrom(const OutputReference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nebulaidl.core.PromiseAttribute attr_path = 3;
  int attr_path_size() const;
  void clear_attr_path();
  static const int kAttrPathFieldNumber = 3;
  ::nebulaidl::core::PromiseAttribute* mutable_attr_path(int index);
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::PromiseAttribute >*
      mutable_attr_path();
  const ::nebulaidl::core::PromiseAttribute& attr_path(int index) const;
  ::nebulaidl::core::PromiseAttribute* add_attr_path();
  const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::PromiseAttribute >&
      attr_path() const;

  // string node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // string var = 2;
  void clear_var();
  static const int kVarFieldNumber = 2;
  const ::std::string& var() const;
  void set_var(const ::std::string& value);
  #if LANG_CXX11
  void set_var(::std::string&& value);
  #endif
  void set_var(const char* value);
  void set_var(const char* value, size_t size);
  ::std::string* mutable_var();
  ::std::string* release_var();
  void set_allocated_var(::std::string* var);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.OutputReference)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::PromiseAttribute > attr_path_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::internal::ArenaStringPtr var_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PromiseAttribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.PromiseAttribute) */ {
 public:
  PromiseAttribute();
  virtual ~PromiseAttribute();

  PromiseAttribute(const PromiseAttribute& from);

  inline PromiseAttribute& operator=(const PromiseAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PromiseAttribute(PromiseAttribute&& from) noexcept
    : PromiseAttribute() {
    *this = ::std::move(from);
  }

  inline PromiseAttribute& operator=(PromiseAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PromiseAttribute& default_instance();

  enum ValueCase {
    kStringValue = 1,
    kIntValue = 2,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PromiseAttribute* internal_default_instance() {
    return reinterpret_cast<const PromiseAttribute*>(
               &_PromiseAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PromiseAttribute* other);
  friend void swap(PromiseAttribute& a, PromiseAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PromiseAttribute* New() const final {
    return CreateMaybeMessage<PromiseAttribute>(nullptr);
  }

  PromiseAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PromiseAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PromiseAttribute& from);
  void MergeFrom(const PromiseAttribute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromiseAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string string_value = 1;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 1;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // int32 int_value = 2;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 2;
  ::google::protobuf::int32 int_value() const;
  void set_int_value(::google::protobuf::int32 value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:nebulaidl.core.PromiseAttribute)
 private:
  class HasBitSetters;
  void set_has_string_value();
  void set_has_int_value();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    ::google::protobuf::int32 int_value_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string failed_node_id = 1;
  void clear_failed_node_id();
  static const int kFailedNodeIdFieldNumber = 1;
  const ::std::string& failed_node_id() const;
  void set_failed_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_failed_node_id(::std::string&& value);
  #endif
  void set_failed_node_id(const char* value);
  void set_failed_node_id(const char* value, size_t size);
  ::std::string* mutable_failed_node_id();
  ::std::string* release_failed_node_id();
  void set_allocated_failed_node_id(::std::string* failed_node_id);

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Error)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr failed_node_id_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchemaType_SchemaColumn

// string name = 1;
inline void SchemaType_SchemaColumn::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SchemaType_SchemaColumn::name() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.SchemaType.SchemaColumn.name)
  return name_.GetNoArena();
}
inline void SchemaType_SchemaColumn::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.SchemaType.SchemaColumn.name)
}
#if LANG_CXX11
inline void SchemaType_SchemaColumn::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.SchemaType.SchemaColumn.name)
}
#endif
inline void SchemaType_SchemaColumn::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.SchemaType.SchemaColumn.name)
}
inline void SchemaType_SchemaColumn::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.SchemaType.SchemaColumn.name)
}
inline ::std::string* SchemaType_SchemaColumn::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.SchemaType.SchemaColumn.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaType_SchemaColumn::release_name() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.SchemaType.SchemaColumn.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaType_SchemaColumn::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.SchemaType.SchemaColumn.name)
}

// .nebulaidl.core.SchemaType.SchemaColumn.SchemaColumnType type = 2;
inline void SchemaType_SchemaColumn::clear_type() {
  type_ = 0;
}
inline ::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType SchemaType_SchemaColumn::type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.SchemaType.SchemaColumn.type)
  return static_cast< ::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType >(type_);
}
inline void SchemaType_SchemaColumn::set_type(::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.SchemaType.SchemaColumn.type)
}

// -------------------------------------------------------------------

// SchemaType

// repeated .nebulaidl.core.SchemaType.SchemaColumn columns = 3;
inline int SchemaType::columns_size() const {
  return columns_.size();
}
inline void SchemaType::clear_columns() {
  columns_.Clear();
}
inline ::nebulaidl::core::SchemaType_SchemaColumn* SchemaType::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.SchemaType.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::SchemaType_SchemaColumn >*
SchemaType::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.SchemaType.columns)
  return &columns_;
}
inline const ::nebulaidl::core::SchemaType_SchemaColumn& SchemaType::columns(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.SchemaType.columns)
  return columns_.Get(index);
}
inline ::nebulaidl::core::SchemaType_SchemaColumn* SchemaType::add_columns() {
  // @@protoc_insertion_point(field_add:nebulaidl.core.SchemaType.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::SchemaType_SchemaColumn >&
SchemaType::columns() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.SchemaType.columns)
  return columns_;
}

// -------------------------------------------------------------------

// StructuredDatasetType_DatasetColumn

// string name = 1;
inline void StructuredDatasetType_DatasetColumn::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StructuredDatasetType_DatasetColumn::name() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
  return name_.GetNoArena();
}
inline void StructuredDatasetType_DatasetColumn::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
}
#if LANG_CXX11
inline void StructuredDatasetType_DatasetColumn::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
}
#endif
inline void StructuredDatasetType_DatasetColumn::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
}
inline void StructuredDatasetType_DatasetColumn::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
}
inline ::std::string* StructuredDatasetType_DatasetColumn::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructuredDatasetType_DatasetColumn::release_name() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructuredDatasetType_DatasetColumn::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDatasetType.DatasetColumn.name)
}

// .nebulaidl.core.LiteralType literal_type = 2;
inline bool StructuredDatasetType_DatasetColumn::has_literal_type() const {
  return this != internal_default_instance() && literal_type_ != nullptr;
}
inline void StructuredDatasetType_DatasetColumn::clear_literal_type() {
  if (GetArenaNoVirtual() == nullptr && literal_type_ != nullptr) {
    delete literal_type_;
  }
  literal_type_ = nullptr;
}
inline const ::nebulaidl::core::LiteralType& StructuredDatasetType_DatasetColumn::literal_type() const {
  const ::nebulaidl::core::LiteralType* p = literal_type_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetType.DatasetColumn.literal_type)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::LiteralType*>(
      &::nebulaidl::core::_LiteralType_default_instance_);
}
inline ::nebulaidl::core::LiteralType* StructuredDatasetType_DatasetColumn::release_literal_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDatasetType.DatasetColumn.literal_type)
  
  ::nebulaidl::core::LiteralType* temp = literal_type_;
  literal_type_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::LiteralType* StructuredDatasetType_DatasetColumn::mutable_literal_type() {
  
  if (literal_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::LiteralType>(GetArenaNoVirtual());
    literal_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetType.DatasetColumn.literal_type)
  return literal_type_;
}
inline void StructuredDatasetType_DatasetColumn::set_allocated_literal_type(::nebulaidl::core::LiteralType* literal_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete literal_type_;
  }
  if (literal_type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      literal_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, literal_type, submessage_arena);
    }
    
  } else {
    
  }
  literal_type_ = literal_type;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDatasetType.DatasetColumn.literal_type)
}

// -------------------------------------------------------------------

// StructuredDatasetType

// repeated .nebulaidl.core.StructuredDatasetType.DatasetColumn columns = 1;
inline int StructuredDatasetType::columns_size() const {
  return columns_.size();
}
inline void StructuredDatasetType::clear_columns() {
  columns_.Clear();
}
inline ::nebulaidl::core::StructuredDatasetType_DatasetColumn* StructuredDatasetType::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetType.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::StructuredDatasetType_DatasetColumn >*
StructuredDatasetType::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.StructuredDatasetType.columns)
  return &columns_;
}
inline const ::nebulaidl::core::StructuredDatasetType_DatasetColumn& StructuredDatasetType::columns(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetType.columns)
  return columns_.Get(index);
}
inline ::nebulaidl::core::StructuredDatasetType_DatasetColumn* StructuredDatasetType::add_columns() {
  // @@protoc_insertion_point(field_add:nebulaidl.core.StructuredDatasetType.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::StructuredDatasetType_DatasetColumn >&
StructuredDatasetType::columns() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.StructuredDatasetType.columns)
  return columns_;
}

// string format = 2;
inline void StructuredDatasetType::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StructuredDatasetType::format() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetType.format)
  return format_.GetNoArena();
}
inline void StructuredDatasetType::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.StructuredDatasetType.format)
}
#if LANG_CXX11
inline void StructuredDatasetType::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.StructuredDatasetType.format)
}
#endif
inline void StructuredDatasetType::set_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.StructuredDatasetType.format)
}
inline void StructuredDatasetType::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.StructuredDatasetType.format)
}
inline ::std::string* StructuredDatasetType::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetType.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructuredDatasetType::release_format() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDatasetType.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructuredDatasetType::set_allocated_format(::std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDatasetType.format)
}

// string external_schema_type = 3;
inline void StructuredDatasetType::clear_external_schema_type() {
  external_schema_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StructuredDatasetType::external_schema_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetType.external_schema_type)
  return external_schema_type_.GetNoArena();
}
inline void StructuredDatasetType::set_external_schema_type(const ::std::string& value) {
  
  external_schema_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.StructuredDatasetType.external_schema_type)
}
#if LANG_CXX11
inline void StructuredDatasetType::set_external_schema_type(::std::string&& value) {
  
  external_schema_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.StructuredDatasetType.external_schema_type)
}
#endif
inline void StructuredDatasetType::set_external_schema_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  external_schema_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.StructuredDatasetType.external_schema_type)
}
inline void StructuredDatasetType::set_external_schema_type(const char* value, size_t size) {
  
  external_schema_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.StructuredDatasetType.external_schema_type)
}
inline ::std::string* StructuredDatasetType::mutable_external_schema_type() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetType.external_schema_type)
  return external_schema_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructuredDatasetType::release_external_schema_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDatasetType.external_schema_type)
  
  return external_schema_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructuredDatasetType::set_allocated_external_schema_type(::std::string* external_schema_type) {
  if (external_schema_type != nullptr) {
    
  } else {
    
  }
  external_schema_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_schema_type);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDatasetType.external_schema_type)
}

// bytes external_schema_bytes = 4;
inline void StructuredDatasetType::clear_external_schema_bytes() {
  external_schema_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StructuredDatasetType::external_schema_bytes() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
  return external_schema_bytes_.GetNoArena();
}
inline void StructuredDatasetType::set_external_schema_bytes(const ::std::string& value) {
  
  external_schema_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
}
#if LANG_CXX11
inline void StructuredDatasetType::set_external_schema_bytes(::std::string&& value) {
  
  external_schema_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
}
#endif
inline void StructuredDatasetType::set_external_schema_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  external_schema_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
}
inline void StructuredDatasetType::set_external_schema_bytes(const void* value, size_t size) {
  
  external_schema_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
}
inline ::std::string* StructuredDatasetType::mutable_external_schema_bytes() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
  return external_schema_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructuredDatasetType::release_external_schema_bytes() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
  
  return external_schema_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructuredDatasetType::set_allocated_external_schema_bytes(::std::string* external_schema_bytes) {
  if (external_schema_bytes != nullptr) {
    
  } else {
    
  }
  external_schema_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_schema_bytes);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.StructuredDatasetType.external_schema_bytes)
}

// -------------------------------------------------------------------

// BlobType

// string format = 1;
inline void BlobType::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlobType::format() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BlobType.format)
  return format_.GetNoArena();
}
inline void BlobType::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.BlobType.format)
}
#if LANG_CXX11
inline void BlobType::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.BlobType.format)
}
#endif
inline void BlobType::set_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.BlobType.format)
}
inline void BlobType::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.BlobType.format)
}
inline ::std::string* BlobType::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.BlobType.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobType::release_format() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.BlobType.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlobType::set_allocated_format(::std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.BlobType.format)
}

// .nebulaidl.core.BlobType.BlobDimensionality dimensionality = 2;
inline void BlobType::clear_dimensionality() {
  dimensionality_ = 0;
}
inline ::nebulaidl::core::BlobType_BlobDimensionality BlobType::dimensionality() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.BlobType.dimensionality)
  return static_cast< ::nebulaidl::core::BlobType_BlobDimensionality >(dimensionality_);
}
inline void BlobType::set_dimensionality(::nebulaidl::core::BlobType_BlobDimensionality value) {
  
  dimensionality_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.BlobType.dimensionality)
}

// -------------------------------------------------------------------

// EnumType

// repeated string values = 1;
inline int EnumType::values_size() const {
  return values_.size();
}
inline void EnumType::clear_values() {
  values_.Clear();
}
inline const ::std::string& EnumType::values(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.EnumType.values)
  return values_.Get(index);
}
inline ::std::string* EnumType::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.EnumType.values)
  return values_.Mutable(index);
}
inline void EnumType::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nebulaidl.core.EnumType.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void EnumType::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:nebulaidl.core.EnumType.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void EnumType::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.EnumType.values)
}
inline void EnumType::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.EnumType.values)
}
inline ::std::string* EnumType::add_values() {
  // @@protoc_insertion_point(field_add_mutable:nebulaidl.core.EnumType.values)
  return values_.Add();
}
inline void EnumType::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nebulaidl.core.EnumType.values)
}
#if LANG_CXX11
inline void EnumType::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nebulaidl.core.EnumType.values)
}
#endif
inline void EnumType::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nebulaidl.core.EnumType.values)
}
inline void EnumType::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nebulaidl.core.EnumType.values)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
EnumType::values() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.EnumType.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
EnumType::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.EnumType.values)
  return &values_;
}

// -------------------------------------------------------------------

// UnionType

// repeated .nebulaidl.core.LiteralType variants = 1;
inline int UnionType::variants_size() const {
  return variants_.size();
}
inline void UnionType::clear_variants() {
  variants_.Clear();
}
inline ::nebulaidl::core::LiteralType* UnionType::mutable_variants(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.UnionType.variants)
  return variants_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::LiteralType >*
UnionType::mutable_variants() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.UnionType.variants)
  return &variants_;
}
inline const ::nebulaidl::core::LiteralType& UnionType::variants(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.UnionType.variants)
  return variants_.Get(index);
}
inline ::nebulaidl::core::LiteralType* UnionType::add_variants() {
  // @@protoc_insertion_point(field_add:nebulaidl.core.UnionType.variants)
  return variants_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::LiteralType >&
UnionType::variants() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.UnionType.variants)
  return variants_;
}

// -------------------------------------------------------------------

// TypeStructure

// string tag = 1;
inline void TypeStructure::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TypeStructure::tag() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.TypeStructure.tag)
  return tag_.GetNoArena();
}
inline void TypeStructure::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.TypeStructure.tag)
}
#if LANG_CXX11
inline void TypeStructure::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.TypeStructure.tag)
}
#endif
inline void TypeStructure::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.TypeStructure.tag)
}
inline void TypeStructure::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.TypeStructure.tag)
}
inline ::std::string* TypeStructure::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.TypeStructure.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TypeStructure::release_tag() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.TypeStructure.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TypeStructure::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.TypeStructure.tag)
}

// -------------------------------------------------------------------

// TypeAnnotation

// .google.protobuf.Struct annotations = 1;
inline bool TypeAnnotation::has_annotations() const {
  return this != internal_default_instance() && annotations_ != nullptr;
}
inline const ::google::protobuf::Struct& TypeAnnotation::annotations() const {
  const ::google::protobuf::Struct* p = annotations_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.TypeAnnotation.annotations)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* TypeAnnotation::release_annotations() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.TypeAnnotation.annotations)
  
  ::google::protobuf::Struct* temp = annotations_;
  annotations_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* TypeAnnotation::mutable_annotations() {
  
  if (annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.TypeAnnotation.annotations)
  return annotations_;
}
inline void TypeAnnotation::set_allocated_annotations(::google::protobuf::Struct* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(annotations_);
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(annotations)->GetArena();
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.TypeAnnotation.annotations)
}

// -------------------------------------------------------------------

// LiteralType

// .nebulaidl.core.SimpleType simple = 1;
inline bool LiteralType::has_simple() const {
  return type_case() == kSimple;
}
inline void LiteralType::set_has_simple() {
  _oneof_case_[0] = kSimple;
}
inline void LiteralType::clear_simple() {
  if (has_simple()) {
    type_.simple_ = 0;
    clear_has_type();
  }
}
inline ::nebulaidl::core::SimpleType LiteralType::simple() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.simple)
  if (has_simple()) {
    return static_cast< ::nebulaidl::core::SimpleType >(type_.simple_);
  }
  return static_cast< ::nebulaidl::core::SimpleType >(0);
}
inline void LiteralType::set_simple(::nebulaidl::core::SimpleType value) {
  if (!has_simple()) {
    clear_type();
    set_has_simple();
  }
  type_.simple_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.LiteralType.simple)
}

// .nebulaidl.core.SchemaType schema = 2;
inline bool LiteralType::has_schema() const {
  return type_case() == kSchema;
}
inline void LiteralType::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void LiteralType::clear_schema() {
  if (has_schema()) {
    delete type_.schema_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::SchemaType* LiteralType::release_schema() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.schema)
  if (has_schema()) {
    clear_has_type();
      ::nebulaidl::core::SchemaType* temp = type_.schema_;
    type_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::SchemaType& LiteralType::schema() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.schema)
  return has_schema()
      ? *type_.schema_
      : *reinterpret_cast< ::nebulaidl::core::SchemaType*>(&::nebulaidl::core::_SchemaType_default_instance_);
}
inline ::nebulaidl::core::SchemaType* LiteralType::mutable_schema() {
  if (!has_schema()) {
    clear_type();
    set_has_schema();
    type_.schema_ = CreateMaybeMessage< ::nebulaidl::core::SchemaType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.schema)
  return type_.schema_;
}

// .nebulaidl.core.LiteralType collection_type = 3;
inline bool LiteralType::has_collection_type() const {
  return type_case() == kCollectionType;
}
inline void LiteralType::set_has_collection_type() {
  _oneof_case_[0] = kCollectionType;
}
inline void LiteralType::clear_collection_type() {
  if (has_collection_type()) {
    delete type_.collection_type_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::LiteralType* LiteralType::release_collection_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.collection_type)
  if (has_collection_type()) {
    clear_has_type();
      ::nebulaidl::core::LiteralType* temp = type_.collection_type_;
    type_.collection_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::LiteralType& LiteralType::collection_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.collection_type)
  return has_collection_type()
      ? *type_.collection_type_
      : *reinterpret_cast< ::nebulaidl::core::LiteralType*>(&::nebulaidl::core::_LiteralType_default_instance_);
}
inline ::nebulaidl::core::LiteralType* LiteralType::mutable_collection_type() {
  if (!has_collection_type()) {
    clear_type();
    set_has_collection_type();
    type_.collection_type_ = CreateMaybeMessage< ::nebulaidl::core::LiteralType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.collection_type)
  return type_.collection_type_;
}

// .nebulaidl.core.LiteralType map_value_type = 4;
inline bool LiteralType::has_map_value_type() const {
  return type_case() == kMapValueType;
}
inline void LiteralType::set_has_map_value_type() {
  _oneof_case_[0] = kMapValueType;
}
inline void LiteralType::clear_map_value_type() {
  if (has_map_value_type()) {
    delete type_.map_value_type_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::LiteralType* LiteralType::release_map_value_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.map_value_type)
  if (has_map_value_type()) {
    clear_has_type();
      ::nebulaidl::core::LiteralType* temp = type_.map_value_type_;
    type_.map_value_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::LiteralType& LiteralType::map_value_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.map_value_type)
  return has_map_value_type()
      ? *type_.map_value_type_
      : *reinterpret_cast< ::nebulaidl::core::LiteralType*>(&::nebulaidl::core::_LiteralType_default_instance_);
}
inline ::nebulaidl::core::LiteralType* LiteralType::mutable_map_value_type() {
  if (!has_map_value_type()) {
    clear_type();
    set_has_map_value_type();
    type_.map_value_type_ = CreateMaybeMessage< ::nebulaidl::core::LiteralType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.map_value_type)
  return type_.map_value_type_;
}

// .nebulaidl.core.BlobType blob = 5;
inline bool LiteralType::has_blob() const {
  return type_case() == kBlob;
}
inline void LiteralType::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void LiteralType::clear_blob() {
  if (has_blob()) {
    delete type_.blob_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::BlobType* LiteralType::release_blob() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.blob)
  if (has_blob()) {
    clear_has_type();
      ::nebulaidl::core::BlobType* temp = type_.blob_;
    type_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::BlobType& LiteralType::blob() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.blob)
  return has_blob()
      ? *type_.blob_
      : *reinterpret_cast< ::nebulaidl::core::BlobType*>(&::nebulaidl::core::_BlobType_default_instance_);
}
inline ::nebulaidl::core::BlobType* LiteralType::mutable_blob() {
  if (!has_blob()) {
    clear_type();
    set_has_blob();
    type_.blob_ = CreateMaybeMessage< ::nebulaidl::core::BlobType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.blob)
  return type_.blob_;
}

// .nebulaidl.core.EnumType enum_type = 7;
inline bool LiteralType::has_enum_type() const {
  return type_case() == kEnumType;
}
inline void LiteralType::set_has_enum_type() {
  _oneof_case_[0] = kEnumType;
}
inline void LiteralType::clear_enum_type() {
  if (has_enum_type()) {
    delete type_.enum_type_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::EnumType* LiteralType::release_enum_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.enum_type)
  if (has_enum_type()) {
    clear_has_type();
      ::nebulaidl::core::EnumType* temp = type_.enum_type_;
    type_.enum_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::EnumType& LiteralType::enum_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.enum_type)
  return has_enum_type()
      ? *type_.enum_type_
      : *reinterpret_cast< ::nebulaidl::core::EnumType*>(&::nebulaidl::core::_EnumType_default_instance_);
}
inline ::nebulaidl::core::EnumType* LiteralType::mutable_enum_type() {
  if (!has_enum_type()) {
    clear_type();
    set_has_enum_type();
    type_.enum_type_ = CreateMaybeMessage< ::nebulaidl::core::EnumType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.enum_type)
  return type_.enum_type_;
}

// .nebulaidl.core.StructuredDatasetType structured_dataset_type = 8;
inline bool LiteralType::has_structured_dataset_type() const {
  return type_case() == kStructuredDatasetType;
}
inline void LiteralType::set_has_structured_dataset_type() {
  _oneof_case_[0] = kStructuredDatasetType;
}
inline void LiteralType::clear_structured_dataset_type() {
  if (has_structured_dataset_type()) {
    delete type_.structured_dataset_type_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::StructuredDatasetType* LiteralType::release_structured_dataset_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.structured_dataset_type)
  if (has_structured_dataset_type()) {
    clear_has_type();
      ::nebulaidl::core::StructuredDatasetType* temp = type_.structured_dataset_type_;
    type_.structured_dataset_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::StructuredDatasetType& LiteralType::structured_dataset_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.structured_dataset_type)
  return has_structured_dataset_type()
      ? *type_.structured_dataset_type_
      : *reinterpret_cast< ::nebulaidl::core::StructuredDatasetType*>(&::nebulaidl::core::_StructuredDatasetType_default_instance_);
}
inline ::nebulaidl::core::StructuredDatasetType* LiteralType::mutable_structured_dataset_type() {
  if (!has_structured_dataset_type()) {
    clear_type();
    set_has_structured_dataset_type();
    type_.structured_dataset_type_ = CreateMaybeMessage< ::nebulaidl::core::StructuredDatasetType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.structured_dataset_type)
  return type_.structured_dataset_type_;
}

// .nebulaidl.core.UnionType union_type = 10;
inline bool LiteralType::has_union_type() const {
  return type_case() == kUnionType;
}
inline void LiteralType::set_has_union_type() {
  _oneof_case_[0] = kUnionType;
}
inline void LiteralType::clear_union_type() {
  if (has_union_type()) {
    delete type_.union_type_;
    clear_has_type();
  }
}
inline ::nebulaidl::core::UnionType* LiteralType::release_union_type() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.union_type)
  if (has_union_type()) {
    clear_has_type();
      ::nebulaidl::core::UnionType* temp = type_.union_type_;
    type_.union_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nebulaidl::core::UnionType& LiteralType::union_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.union_type)
  return has_union_type()
      ? *type_.union_type_
      : *reinterpret_cast< ::nebulaidl::core::UnionType*>(&::nebulaidl::core::_UnionType_default_instance_);
}
inline ::nebulaidl::core::UnionType* LiteralType::mutable_union_type() {
  if (!has_union_type()) {
    clear_type();
    set_has_union_type();
    type_.union_type_ = CreateMaybeMessage< ::nebulaidl::core::UnionType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.union_type)
  return type_.union_type_;
}

// .google.protobuf.Struct metadata = 6;
inline bool LiteralType::has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline const ::google::protobuf::Struct& LiteralType::metadata() const {
  const ::google::protobuf::Struct* p = metadata_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* LiteralType::release_metadata() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.metadata)
  
  ::google::protobuf::Struct* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* LiteralType::mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.metadata)
  return metadata_;
}
inline void LiteralType::set_allocated_metadata(::google::protobuf::Struct* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(metadata)->GetArena();
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.LiteralType.metadata)
}

// .nebulaidl.core.TypeAnnotation annotation = 9;
inline bool LiteralType::has_annotation() const {
  return this != internal_default_instance() && annotation_ != nullptr;
}
inline void LiteralType::clear_annotation() {
  if (GetArenaNoVirtual() == nullptr && annotation_ != nullptr) {
    delete annotation_;
  }
  annotation_ = nullptr;
}
inline const ::nebulaidl::core::TypeAnnotation& LiteralType::annotation() const {
  const ::nebulaidl::core::TypeAnnotation* p = annotation_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.annotation)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::TypeAnnotation*>(
      &::nebulaidl::core::_TypeAnnotation_default_instance_);
}
inline ::nebulaidl::core::TypeAnnotation* LiteralType::release_annotation() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.annotation)
  
  ::nebulaidl::core::TypeAnnotation* temp = annotation_;
  annotation_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::TypeAnnotation* LiteralType::mutable_annotation() {
  
  if (annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::TypeAnnotation>(GetArenaNoVirtual());
    annotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.annotation)
  return annotation_;
}
inline void LiteralType::set_allocated_annotation(::nebulaidl::core::TypeAnnotation* annotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete annotation_;
  }
  if (annotation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      annotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.LiteralType.annotation)
}

// .nebulaidl.core.TypeStructure structure = 11;
inline bool LiteralType::has_structure() const {
  return this != internal_default_instance() && structure_ != nullptr;
}
inline void LiteralType::clear_structure() {
  if (GetArenaNoVirtual() == nullptr && structure_ != nullptr) {
    delete structure_;
  }
  structure_ = nullptr;
}
inline const ::nebulaidl::core::TypeStructure& LiteralType::structure() const {
  const ::nebulaidl::core::TypeStructure* p = structure_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.LiteralType.structure)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::TypeStructure*>(
      &::nebulaidl::core::_TypeStructure_default_instance_);
}
inline ::nebulaidl::core::TypeStructure* LiteralType::release_structure() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.LiteralType.structure)
  
  ::nebulaidl::core::TypeStructure* temp = structure_;
  structure_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::TypeStructure* LiteralType::mutable_structure() {
  
  if (structure_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::TypeStructure>(GetArenaNoVirtual());
    structure_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.LiteralType.structure)
  return structure_;
}
inline void LiteralType::set_allocated_structure(::nebulaidl::core::TypeStructure* structure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete structure_;
  }
  if (structure) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      structure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, structure, submessage_arena);
    }
    
  } else {
    
  }
  structure_ = structure;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.LiteralType.structure)
}

inline bool LiteralType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void LiteralType::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline LiteralType::TypeCase LiteralType::type_case() const {
  return LiteralType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OutputReference

// string node_id = 1;
inline void OutputReference::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OutputReference::node_id() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.OutputReference.node_id)
  return node_id_.GetNoArena();
}
inline void OutputReference::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.OutputReference.node_id)
}
#if LANG_CXX11
inline void OutputReference::set_node_id(::std::string&& value) {
  
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.OutputReference.node_id)
}
#endif
inline void OutputReference::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.OutputReference.node_id)
}
inline void OutputReference::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.OutputReference.node_id)
}
inline ::std::string* OutputReference::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.OutputReference.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OutputReference::release_node_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.OutputReference.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OutputReference::set_allocated_node_id(::std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.OutputReference.node_id)
}

// string var = 2;
inline void OutputReference::clear_var() {
  var_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OutputReference::var() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.OutputReference.var)
  return var_.GetNoArena();
}
inline void OutputReference::set_var(const ::std::string& value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.OutputReference.var)
}
#if LANG_CXX11
inline void OutputReference::set_var(::std::string&& value) {
  
  var_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.OutputReference.var)
}
#endif
inline void OutputReference::set_var(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.OutputReference.var)
}
inline void OutputReference::set_var(const char* value, size_t size) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.OutputReference.var)
}
inline ::std::string* OutputReference::mutable_var() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.OutputReference.var)
  return var_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OutputReference::release_var() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.OutputReference.var)
  
  return var_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OutputReference::set_allocated_var(::std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  var_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), var);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.OutputReference.var)
}

// repeated .nebulaidl.core.PromiseAttribute attr_path = 3;
inline int OutputReference::attr_path_size() const {
  return attr_path_.size();
}
inline void OutputReference::clear_attr_path() {
  attr_path_.Clear();
}
inline ::nebulaidl::core::PromiseAttribute* OutputReference::mutable_attr_path(int index) {
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.OutputReference.attr_path)
  return attr_path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::PromiseAttribute >*
OutputReference::mutable_attr_path() {
  // @@protoc_insertion_point(field_mutable_list:nebulaidl.core.OutputReference.attr_path)
  return &attr_path_;
}
inline const ::nebulaidl::core::PromiseAttribute& OutputReference::attr_path(int index) const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.OutputReference.attr_path)
  return attr_path_.Get(index);
}
inline ::nebulaidl::core::PromiseAttribute* OutputReference::add_attr_path() {
  // @@protoc_insertion_point(field_add:nebulaidl.core.OutputReference.attr_path)
  return attr_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nebulaidl::core::PromiseAttribute >&
OutputReference::attr_path() const {
  // @@protoc_insertion_point(field_list:nebulaidl.core.OutputReference.attr_path)
  return attr_path_;
}

// -------------------------------------------------------------------

// PromiseAttribute

// string string_value = 1;
inline bool PromiseAttribute::has_string_value() const {
  return value_case() == kStringValue;
}
inline void PromiseAttribute::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void PromiseAttribute::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& PromiseAttribute::string_value() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.PromiseAttribute.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void PromiseAttribute::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nebulaidl.core.PromiseAttribute.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.PromiseAttribute.string_value)
}
#if LANG_CXX11
inline void PromiseAttribute::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:nebulaidl.core.PromiseAttribute.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.PromiseAttribute.string_value)
}
#endif
inline void PromiseAttribute::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.PromiseAttribute.string_value)
}
inline void PromiseAttribute::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.PromiseAttribute.string_value)
}
inline ::std::string* PromiseAttribute::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.PromiseAttribute.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PromiseAttribute::release_string_value() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.PromiseAttribute.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void PromiseAttribute::set_allocated_string_value(::std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.PromiseAttribute.string_value)
}

// int32 int_value = 2;
inline bool PromiseAttribute::has_int_value() const {
  return value_case() == kIntValue;
}
inline void PromiseAttribute::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void PromiseAttribute::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = 0;
    clear_has_value();
  }
}
inline ::google::protobuf::int32 PromiseAttribute::int_value() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.PromiseAttribute.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return 0;
}
inline void PromiseAttribute::set_int_value(::google::protobuf::int32 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.PromiseAttribute.int_value)
}

inline bool PromiseAttribute::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void PromiseAttribute::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline PromiseAttribute::ValueCase PromiseAttribute::value_case() const {
  return PromiseAttribute::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Error

// string failed_node_id = 1;
inline void Error::clear_failed_node_id() {
  failed_node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::failed_node_id() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Error.failed_node_id)
  return failed_node_id_.GetNoArena();
}
inline void Error::set_failed_node_id(const ::std::string& value) {
  
  failed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Error.failed_node_id)
}
#if LANG_CXX11
inline void Error::set_failed_node_id(::std::string&& value) {
  
  failed_node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Error.failed_node_id)
}
#endif
inline void Error::set_failed_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  failed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Error.failed_node_id)
}
inline void Error::set_failed_node_id(const char* value, size_t size) {
  
  failed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Error.failed_node_id)
}
inline ::std::string* Error::mutable_failed_node_id() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Error.failed_node_id)
  return failed_node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_failed_node_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Error.failed_node_id)
  
  return failed_node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_failed_node_id(::std::string* failed_node_id) {
  if (failed_node_id != nullptr) {
    
  } else {
    
  }
  failed_node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), failed_node_id);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Error.failed_node_id)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Error.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace nebulaidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType>() {
  return ::nebulaidl::core::SchemaType_SchemaColumn_SchemaColumnType_descriptor();
}
template <> struct is_proto_enum< ::nebulaidl::core::BlobType_BlobDimensionality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nebulaidl::core::BlobType_BlobDimensionality>() {
  return ::nebulaidl::core::BlobType_BlobDimensionality_descriptor();
}
template <> struct is_proto_enum< ::nebulaidl::core::SimpleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nebulaidl::core::SimpleType>() {
  return ::nebulaidl::core::SimpleType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_nebulaidl_2fcore_2ftypes_2eproto
