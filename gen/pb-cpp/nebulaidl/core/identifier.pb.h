// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nebulaidl/core/identifier.proto

#ifndef PROTOBUF_INCLUDED_nebulaidl_2fcore_2fidentifier_2eproto
#define PROTOBUF_INCLUDED_nebulaidl_2fcore_2fidentifier_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nebulaidl_2fcore_2fidentifier_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_nebulaidl_2fcore_2fidentifier_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_nebulaidl_2fcore_2fidentifier_2eproto();
namespace nebulaidl {
namespace core {
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class NodeExecutionIdentifier;
class NodeExecutionIdentifierDefaultTypeInternal;
extern NodeExecutionIdentifierDefaultTypeInternal _NodeExecutionIdentifier_default_instance_;
class SignalIdentifier;
class SignalIdentifierDefaultTypeInternal;
extern SignalIdentifierDefaultTypeInternal _SignalIdentifier_default_instance_;
class TaskExecutionIdentifier;
class TaskExecutionIdentifierDefaultTypeInternal;
extern TaskExecutionIdentifierDefaultTypeInternal _TaskExecutionIdentifier_default_instance_;
class WorkflowExecutionIdentifier;
class WorkflowExecutionIdentifierDefaultTypeInternal;
extern WorkflowExecutionIdentifierDefaultTypeInternal _WorkflowExecutionIdentifier_default_instance_;
}  // namespace core
}  // namespace nebulaidl
namespace google {
namespace protobuf {
template<> ::nebulaidl::core::Identifier* Arena::CreateMaybeMessage<::nebulaidl::core::Identifier>(Arena*);
template<> ::nebulaidl::core::NodeExecutionIdentifier* Arena::CreateMaybeMessage<::nebulaidl::core::NodeExecutionIdentifier>(Arena*);
template<> ::nebulaidl::core::SignalIdentifier* Arena::CreateMaybeMessage<::nebulaidl::core::SignalIdentifier>(Arena*);
template<> ::nebulaidl::core::TaskExecutionIdentifier* Arena::CreateMaybeMessage<::nebulaidl::core::TaskExecutionIdentifier>(Arena*);
template<> ::nebulaidl::core::WorkflowExecutionIdentifier* Arena::CreateMaybeMessage<::nebulaidl::core::WorkflowExecutionIdentifier>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace nebulaidl {
namespace core {

enum ResourceType {
  UNSPECIFIED = 0,
  TASK = 1,
  WORKFLOW = 2,
  LAUNCH_PLAN = 3,
  DATASET = 4,
  ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ResourceType_IsValid(int value);
const ResourceType ResourceType_MIN = UNSPECIFIED;
const ResourceType ResourceType_MAX = DATASET;
const int ResourceType_ARRAYSIZE = ResourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResourceType_descriptor();
inline const ::std::string& ResourceType_Name(ResourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResourceType_descriptor(), value);
}
inline bool ResourceType_Parse(
    const ::std::string& name, ResourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourceType>(
    ResourceType_descriptor(), name, value);
}
// ===================================================================

class Identifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(nullptr);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 2;
  void clear_project();
  static const int kProjectFieldNumber = 2;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 3;
  void clear_domain();
  static const int kDomainFieldNumber = 3;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .nebulaidl.core.ResourceType resource_type = 1;
  void clear_resource_type();
  static const int kResourceTypeFieldNumber = 1;
  ::nebulaidl::core::ResourceType resource_type() const;
  void set_resource_type(::nebulaidl::core::ResourceType value);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.Identifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  int resource_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.WorkflowExecutionIdentifier) */ {
 public:
  WorkflowExecutionIdentifier();
  virtual ~WorkflowExecutionIdentifier();

  WorkflowExecutionIdentifier(const WorkflowExecutionIdentifier& from);

  inline WorkflowExecutionIdentifier& operator=(const WorkflowExecutionIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowExecutionIdentifier(WorkflowExecutionIdentifier&& from) noexcept
    : WorkflowExecutionIdentifier() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionIdentifier& operator=(WorkflowExecutionIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowExecutionIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowExecutionIdentifier* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionIdentifier*>(
               &_WorkflowExecutionIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WorkflowExecutionIdentifier* other);
  friend void swap(WorkflowExecutionIdentifier& a, WorkflowExecutionIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowExecutionIdentifier* New() const final {
    return CreateMaybeMessage<WorkflowExecutionIdentifier>(nullptr);
  }

  WorkflowExecutionIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowExecutionIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowExecutionIdentifier& from);
  void MergeFrom(const WorkflowExecutionIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 2;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.WorkflowExecutionIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.NodeExecutionIdentifier) */ {
 public:
  NodeExecutionIdentifier();
  virtual ~NodeExecutionIdentifier();

  NodeExecutionIdentifier(const NodeExecutionIdentifier& from);

  inline NodeExecutionIdentifier& operator=(const NodeExecutionIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeExecutionIdentifier(NodeExecutionIdentifier&& from) noexcept
    : NodeExecutionIdentifier() {
    *this = ::std::move(from);
  }

  inline NodeExecutionIdentifier& operator=(NodeExecutionIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeExecutionIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeExecutionIdentifier* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionIdentifier*>(
               &_NodeExecutionIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NodeExecutionIdentifier* other);
  friend void swap(NodeExecutionIdentifier& a, NodeExecutionIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeExecutionIdentifier* New() const final {
    return CreateMaybeMessage<NodeExecutionIdentifier>(nullptr);
  }

  NodeExecutionIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeExecutionIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeExecutionIdentifier& from);
  void MergeFrom(const NodeExecutionIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // .nebulaidl.core.WorkflowExecutionIdentifier execution_id = 2;
  bool has_execution_id() const;
  void clear_execution_id();
  static const int kExecutionIdFieldNumber = 2;
  const ::nebulaidl::core::WorkflowExecutionIdentifier& execution_id() const;
  ::nebulaidl::core::WorkflowExecutionIdentifier* release_execution_id();
  ::nebulaidl::core::WorkflowExecutionIdentifier* mutable_execution_id();
  void set_allocated_execution_id(::nebulaidl::core::WorkflowExecutionIdentifier* execution_id);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.NodeExecutionIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::nebulaidl::core::WorkflowExecutionIdentifier* execution_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class TaskExecutionIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.TaskExecutionIdentifier) */ {
 public:
  TaskExecutionIdentifier();
  virtual ~TaskExecutionIdentifier();

  TaskExecutionIdentifier(const TaskExecutionIdentifier& from);

  inline TaskExecutionIdentifier& operator=(const TaskExecutionIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskExecutionIdentifier(TaskExecutionIdentifier&& from) noexcept
    : TaskExecutionIdentifier() {
    *this = ::std::move(from);
  }

  inline TaskExecutionIdentifier& operator=(TaskExecutionIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskExecutionIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskExecutionIdentifier* internal_default_instance() {
    return reinterpret_cast<const TaskExecutionIdentifier*>(
               &_TaskExecutionIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TaskExecutionIdentifier* other);
  friend void swap(TaskExecutionIdentifier& a, TaskExecutionIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskExecutionIdentifier* New() const final {
    return CreateMaybeMessage<TaskExecutionIdentifier>(nullptr);
  }

  TaskExecutionIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskExecutionIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskExecutionIdentifier& from);
  void MergeFrom(const TaskExecutionIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskExecutionIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebulaidl.core.Identifier task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  const ::nebulaidl::core::Identifier& task_id() const;
  ::nebulaidl::core::Identifier* release_task_id();
  ::nebulaidl::core::Identifier* mutable_task_id();
  void set_allocated_task_id(::nebulaidl::core::Identifier* task_id);

  // .nebulaidl.core.NodeExecutionIdentifier node_execution_id = 2;
  bool has_node_execution_id() const;
  void clear_node_execution_id();
  static const int kNodeExecutionIdFieldNumber = 2;
  const ::nebulaidl::core::NodeExecutionIdentifier& node_execution_id() const;
  ::nebulaidl::core::NodeExecutionIdentifier* release_node_execution_id();
  ::nebulaidl::core::NodeExecutionIdentifier* mutable_node_execution_id();
  void set_allocated_node_execution_id(::nebulaidl::core::NodeExecutionIdentifier* node_execution_id);

  // uint32 retry_attempt = 3;
  void clear_retry_attempt();
  static const int kRetryAttemptFieldNumber = 3;
  ::google::protobuf::uint32 retry_attempt() const;
  void set_retry_attempt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.TaskExecutionIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebulaidl::core::Identifier* task_id_;
  ::nebulaidl::core::NodeExecutionIdentifier* node_execution_id_;
  ::google::protobuf::uint32 retry_attempt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class SignalIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nebulaidl.core.SignalIdentifier) */ {
 public:
  SignalIdentifier();
  virtual ~SignalIdentifier();

  SignalIdentifier(const SignalIdentifier& from);

  inline SignalIdentifier& operator=(const SignalIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalIdentifier(SignalIdentifier&& from) noexcept
    : SignalIdentifier() {
    *this = ::std::move(from);
  }

  inline SignalIdentifier& operator=(SignalIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SignalIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalIdentifier* internal_default_instance() {
    return reinterpret_cast<const SignalIdentifier*>(
               &_SignalIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SignalIdentifier* other);
  friend void swap(SignalIdentifier& a, SignalIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalIdentifier* New() const final {
    return CreateMaybeMessage<SignalIdentifier>(nullptr);
  }

  SignalIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignalIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignalIdentifier& from);
  void MergeFrom(const SignalIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string signal_id = 1;
  void clear_signal_id();
  static const int kSignalIdFieldNumber = 1;
  const ::std::string& signal_id() const;
  void set_signal_id(const ::std::string& value);
  #if LANG_CXX11
  void set_signal_id(::std::string&& value);
  #endif
  void set_signal_id(const char* value);
  void set_signal_id(const char* value, size_t size);
  ::std::string* mutable_signal_id();
  ::std::string* release_signal_id();
  void set_allocated_signal_id(::std::string* signal_id);

  // .nebulaidl.core.WorkflowExecutionIdentifier execution_id = 2;
  bool has_execution_id() const;
  void clear_execution_id();
  static const int kExecutionIdFieldNumber = 2;
  const ::nebulaidl::core::WorkflowExecutionIdentifier& execution_id() const;
  ::nebulaidl::core::WorkflowExecutionIdentifier* release_execution_id();
  ::nebulaidl::core::WorkflowExecutionIdentifier* mutable_execution_id();
  void set_allocated_execution_id(::nebulaidl::core::WorkflowExecutionIdentifier* execution_id);

  // @@protoc_insertion_point(class_scope:nebulaidl.core.SignalIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signal_id_;
  ::nebulaidl::core::WorkflowExecutionIdentifier* execution_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nebulaidl_2fcore_2fidentifier_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Identifier

// .nebulaidl.core.ResourceType resource_type = 1;
inline void Identifier::clear_resource_type() {
  resource_type_ = 0;
}
inline ::nebulaidl::core::ResourceType Identifier::resource_type() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Identifier.resource_type)
  return static_cast< ::nebulaidl::core::ResourceType >(resource_type_);
}
inline void Identifier::set_resource_type(::nebulaidl::core::ResourceType value) {
  
  resource_type_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.Identifier.resource_type)
}

// string project = 2;
inline void Identifier::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::project() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Identifier.project)
  return project_.GetNoArena();
}
inline void Identifier::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Identifier.project)
}
#if LANG_CXX11
inline void Identifier::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Identifier.project)
}
#endif
inline void Identifier::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Identifier.project)
}
inline void Identifier::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Identifier.project)
}
inline ::std::string* Identifier::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Identifier.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_project() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Identifier.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Identifier.project)
}

// string domain = 3;
inline void Identifier::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::domain() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Identifier.domain)
  return domain_.GetNoArena();
}
inline void Identifier::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Identifier.domain)
}
#if LANG_CXX11
inline void Identifier::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Identifier.domain)
}
#endif
inline void Identifier::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Identifier.domain)
}
inline void Identifier::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Identifier.domain)
}
inline ::std::string* Identifier::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Identifier.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_domain() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Identifier.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Identifier.domain)
}

// string name = 4;
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Identifier.name)
  return name_.GetNoArena();
}
inline void Identifier::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Identifier.name)
}
#if LANG_CXX11
inline void Identifier::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Identifier.name)
}
#endif
inline void Identifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Identifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Identifier.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Identifier.name)
}

// string version = 5;
inline void Identifier::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::version() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.Identifier.version)
  return version_.GetNoArena();
}
inline void Identifier::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.Identifier.version)
}
#if LANG_CXX11
inline void Identifier::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.Identifier.version)
}
#endif
inline void Identifier::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.Identifier.version)
}
inline void Identifier::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.Identifier.version)
}
inline ::std::string* Identifier::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.Identifier.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_version() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.Identifier.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.Identifier.version)
}

// -------------------------------------------------------------------

// WorkflowExecutionIdentifier

// string project = 1;
inline void WorkflowExecutionIdentifier::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionIdentifier::project() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.WorkflowExecutionIdentifier.project)
  return project_.GetNoArena();
}
inline void WorkflowExecutionIdentifier::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.WorkflowExecutionIdentifier.project)
}
#if LANG_CXX11
inline void WorkflowExecutionIdentifier::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.WorkflowExecutionIdentifier.project)
}
#endif
inline void WorkflowExecutionIdentifier::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.WorkflowExecutionIdentifier.project)
}
inline void WorkflowExecutionIdentifier::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.WorkflowExecutionIdentifier.project)
}
inline ::std::string* WorkflowExecutionIdentifier::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.WorkflowExecutionIdentifier.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionIdentifier::release_project() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.WorkflowExecutionIdentifier.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionIdentifier::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.WorkflowExecutionIdentifier.project)
}

// string domain = 2;
inline void WorkflowExecutionIdentifier::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionIdentifier::domain() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.WorkflowExecutionIdentifier.domain)
  return domain_.GetNoArena();
}
inline void WorkflowExecutionIdentifier::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.WorkflowExecutionIdentifier.domain)
}
#if LANG_CXX11
inline void WorkflowExecutionIdentifier::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.WorkflowExecutionIdentifier.domain)
}
#endif
inline void WorkflowExecutionIdentifier::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.WorkflowExecutionIdentifier.domain)
}
inline void WorkflowExecutionIdentifier::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.WorkflowExecutionIdentifier.domain)
}
inline ::std::string* WorkflowExecutionIdentifier::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.WorkflowExecutionIdentifier.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionIdentifier::release_domain() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.WorkflowExecutionIdentifier.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionIdentifier::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.WorkflowExecutionIdentifier.domain)
}

// string name = 4;
inline void WorkflowExecutionIdentifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionIdentifier::name() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.WorkflowExecutionIdentifier.name)
  return name_.GetNoArena();
}
inline void WorkflowExecutionIdentifier::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.WorkflowExecutionIdentifier.name)
}
#if LANG_CXX11
inline void WorkflowExecutionIdentifier::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.WorkflowExecutionIdentifier.name)
}
#endif
inline void WorkflowExecutionIdentifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.WorkflowExecutionIdentifier.name)
}
inline void WorkflowExecutionIdentifier::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.WorkflowExecutionIdentifier.name)
}
inline ::std::string* WorkflowExecutionIdentifier::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.WorkflowExecutionIdentifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.WorkflowExecutionIdentifier.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionIdentifier::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.WorkflowExecutionIdentifier.name)
}

// -------------------------------------------------------------------

// NodeExecutionIdentifier

// string node_id = 1;
inline void NodeExecutionIdentifier::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeExecutionIdentifier::node_id() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.NodeExecutionIdentifier.node_id)
  return node_id_.GetNoArena();
}
inline void NodeExecutionIdentifier::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.NodeExecutionIdentifier.node_id)
}
#if LANG_CXX11
inline void NodeExecutionIdentifier::set_node_id(::std::string&& value) {
  
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.NodeExecutionIdentifier.node_id)
}
#endif
inline void NodeExecutionIdentifier::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.NodeExecutionIdentifier.node_id)
}
inline void NodeExecutionIdentifier::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.NodeExecutionIdentifier.node_id)
}
inline ::std::string* NodeExecutionIdentifier::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.NodeExecutionIdentifier.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeExecutionIdentifier::release_node_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.NodeExecutionIdentifier.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeExecutionIdentifier::set_allocated_node_id(::std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.NodeExecutionIdentifier.node_id)
}

// .nebulaidl.core.WorkflowExecutionIdentifier execution_id = 2;
inline bool NodeExecutionIdentifier::has_execution_id() const {
  return this != internal_default_instance() && execution_id_ != nullptr;
}
inline void NodeExecutionIdentifier::clear_execution_id() {
  if (GetArenaNoVirtual() == nullptr && execution_id_ != nullptr) {
    delete execution_id_;
  }
  execution_id_ = nullptr;
}
inline const ::nebulaidl::core::WorkflowExecutionIdentifier& NodeExecutionIdentifier::execution_id() const {
  const ::nebulaidl::core::WorkflowExecutionIdentifier* p = execution_id_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.NodeExecutionIdentifier.execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::WorkflowExecutionIdentifier*>(
      &::nebulaidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::nebulaidl::core::WorkflowExecutionIdentifier* NodeExecutionIdentifier::release_execution_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.NodeExecutionIdentifier.execution_id)
  
  ::nebulaidl::core::WorkflowExecutionIdentifier* temp = execution_id_;
  execution_id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::WorkflowExecutionIdentifier* NodeExecutionIdentifier::mutable_execution_id() {
  
  if (execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.NodeExecutionIdentifier.execution_id)
  return execution_id_;
}
inline void NodeExecutionIdentifier::set_allocated_execution_id(::nebulaidl::core::WorkflowExecutionIdentifier* execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete execution_id_;
  }
  if (execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, execution_id, submessage_arena);
    }
    
  } else {
    
  }
  execution_id_ = execution_id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.NodeExecutionIdentifier.execution_id)
}

// -------------------------------------------------------------------

// TaskExecutionIdentifier

// .nebulaidl.core.Identifier task_id = 1;
inline bool TaskExecutionIdentifier::has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline void TaskExecutionIdentifier::clear_task_id() {
  if (GetArenaNoVirtual() == nullptr && task_id_ != nullptr) {
    delete task_id_;
  }
  task_id_ = nullptr;
}
inline const ::nebulaidl::core::Identifier& TaskExecutionIdentifier::task_id() const {
  const ::nebulaidl::core::Identifier* p = task_id_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.TaskExecutionIdentifier.task_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::Identifier*>(
      &::nebulaidl::core::_Identifier_default_instance_);
}
inline ::nebulaidl::core::Identifier* TaskExecutionIdentifier::release_task_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.TaskExecutionIdentifier.task_id)
  
  ::nebulaidl::core::Identifier* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::Identifier* TaskExecutionIdentifier::mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::Identifier>(GetArenaNoVirtual());
    task_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.TaskExecutionIdentifier.task_id)
  return task_id_;
}
inline void TaskExecutionIdentifier::set_allocated_task_id(::nebulaidl::core::Identifier* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete task_id_;
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.TaskExecutionIdentifier.task_id)
}

// .nebulaidl.core.NodeExecutionIdentifier node_execution_id = 2;
inline bool TaskExecutionIdentifier::has_node_execution_id() const {
  return this != internal_default_instance() && node_execution_id_ != nullptr;
}
inline void TaskExecutionIdentifier::clear_node_execution_id() {
  if (GetArenaNoVirtual() == nullptr && node_execution_id_ != nullptr) {
    delete node_execution_id_;
  }
  node_execution_id_ = nullptr;
}
inline const ::nebulaidl::core::NodeExecutionIdentifier& TaskExecutionIdentifier::node_execution_id() const {
  const ::nebulaidl::core::NodeExecutionIdentifier* p = node_execution_id_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.TaskExecutionIdentifier.node_execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::NodeExecutionIdentifier*>(
      &::nebulaidl::core::_NodeExecutionIdentifier_default_instance_);
}
inline ::nebulaidl::core::NodeExecutionIdentifier* TaskExecutionIdentifier::release_node_execution_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.TaskExecutionIdentifier.node_execution_id)
  
  ::nebulaidl::core::NodeExecutionIdentifier* temp = node_execution_id_;
  node_execution_id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::NodeExecutionIdentifier* TaskExecutionIdentifier::mutable_node_execution_id() {
  
  if (node_execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::NodeExecutionIdentifier>(GetArenaNoVirtual());
    node_execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.TaskExecutionIdentifier.node_execution_id)
  return node_execution_id_;
}
inline void TaskExecutionIdentifier::set_allocated_node_execution_id(::nebulaidl::core::NodeExecutionIdentifier* node_execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_execution_id_;
  }
  if (node_execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_execution_id, submessage_arena);
    }
    
  } else {
    
  }
  node_execution_id_ = node_execution_id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.TaskExecutionIdentifier.node_execution_id)
}

// uint32 retry_attempt = 3;
inline void TaskExecutionIdentifier::clear_retry_attempt() {
  retry_attempt_ = 0u;
}
inline ::google::protobuf::uint32 TaskExecutionIdentifier::retry_attempt() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.TaskExecutionIdentifier.retry_attempt)
  return retry_attempt_;
}
inline void TaskExecutionIdentifier::set_retry_attempt(::google::protobuf::uint32 value) {
  
  retry_attempt_ = value;
  // @@protoc_insertion_point(field_set:nebulaidl.core.TaskExecutionIdentifier.retry_attempt)
}

// -------------------------------------------------------------------

// SignalIdentifier

// string signal_id = 1;
inline void SignalIdentifier::clear_signal_id() {
  signal_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignalIdentifier::signal_id() const {
  // @@protoc_insertion_point(field_get:nebulaidl.core.SignalIdentifier.signal_id)
  return signal_id_.GetNoArena();
}
inline void SignalIdentifier::set_signal_id(const ::std::string& value) {
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nebulaidl.core.SignalIdentifier.signal_id)
}
#if LANG_CXX11
inline void SignalIdentifier::set_signal_id(::std::string&& value) {
  
  signal_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:nebulaidl.core.SignalIdentifier.signal_id)
}
#endif
inline void SignalIdentifier::set_signal_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nebulaidl.core.SignalIdentifier.signal_id)
}
inline void SignalIdentifier::set_signal_id(const char* value, size_t size) {
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nebulaidl.core.SignalIdentifier.signal_id)
}
inline ::std::string* SignalIdentifier::mutable_signal_id() {
  
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.SignalIdentifier.signal_id)
  return signal_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignalIdentifier::release_signal_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.SignalIdentifier.signal_id)
  
  return signal_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignalIdentifier::set_allocated_signal_id(::std::string* signal_id) {
  if (signal_id != nullptr) {
    
  } else {
    
  }
  signal_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signal_id);
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.SignalIdentifier.signal_id)
}

// .nebulaidl.core.WorkflowExecutionIdentifier execution_id = 2;
inline bool SignalIdentifier::has_execution_id() const {
  return this != internal_default_instance() && execution_id_ != nullptr;
}
inline void SignalIdentifier::clear_execution_id() {
  if (GetArenaNoVirtual() == nullptr && execution_id_ != nullptr) {
    delete execution_id_;
  }
  execution_id_ = nullptr;
}
inline const ::nebulaidl::core::WorkflowExecutionIdentifier& SignalIdentifier::execution_id() const {
  const ::nebulaidl::core::WorkflowExecutionIdentifier* p = execution_id_;
  // @@protoc_insertion_point(field_get:nebulaidl.core.SignalIdentifier.execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::nebulaidl::core::WorkflowExecutionIdentifier*>(
      &::nebulaidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::nebulaidl::core::WorkflowExecutionIdentifier* SignalIdentifier::release_execution_id() {
  // @@protoc_insertion_point(field_release:nebulaidl.core.SignalIdentifier.execution_id)
  
  ::nebulaidl::core::WorkflowExecutionIdentifier* temp = execution_id_;
  execution_id_ = nullptr;
  return temp;
}
inline ::nebulaidl::core::WorkflowExecutionIdentifier* SignalIdentifier::mutable_execution_id() {
  
  if (execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nebulaidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:nebulaidl.core.SignalIdentifier.execution_id)
  return execution_id_;
}
inline void SignalIdentifier::set_allocated_execution_id(::nebulaidl::core::WorkflowExecutionIdentifier* execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete execution_id_;
  }
  if (execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, execution_id, submessage_arena);
    }
    
  } else {
    
  }
  execution_id_ = execution_id;
  // @@protoc_insertion_point(field_set_allocated:nebulaidl.core.SignalIdentifier.execution_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace nebulaidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nebulaidl::core::ResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nebulaidl::core::ResourceType>() {
  return ::nebulaidl::core::ResourceType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_nebulaidl_2fcore_2fidentifier_2eproto
