/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots.nebulaidl || ($protobuf.roots.nebulaidl = {});
    
    $root.nebulaidl = (function() {
    
        /**
         * Namespace nebulaidl.
         * @exports nebulaidl
         * @namespace
         */
        var nebulaidl = {};
    
        nebulaidl.core = (function() {
    
            /**
             * Namespace core.
             * @memberof nebulaidl
             * @namespace
             */
            var core = {};
    
            /**
             * CatalogCacheStatus enum.
             * @name nebulaidl.core.CatalogCacheStatus
             * @enum {string}
             * @property {number} CACHE_DISABLED=0 CACHE_DISABLED value
             * @property {number} CACHE_MISS=1 CACHE_MISS value
             * @property {number} CACHE_HIT=2 CACHE_HIT value
             * @property {number} CACHE_POPULATED=3 CACHE_POPULATED value
             * @property {number} CACHE_LOOKUP_FAILURE=4 CACHE_LOOKUP_FAILURE value
             * @property {number} CACHE_PUT_FAILURE=5 CACHE_PUT_FAILURE value
             * @property {number} CACHE_SKIPPED=6 CACHE_SKIPPED value
             */
            core.CatalogCacheStatus = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CACHE_DISABLED"] = 0;
                values[valuesById[1] = "CACHE_MISS"] = 1;
                values[valuesById[2] = "CACHE_HIT"] = 2;
                values[valuesById[3] = "CACHE_POPULATED"] = 3;
                values[valuesById[4] = "CACHE_LOOKUP_FAILURE"] = 4;
                values[valuesById[5] = "CACHE_PUT_FAILURE"] = 5;
                values[valuesById[6] = "CACHE_SKIPPED"] = 6;
                return values;
            })();
    
            core.CatalogArtifactTag = (function() {
    
                /**
                 * Properties of a CatalogArtifactTag.
                 * @memberof nebulaidl.core
                 * @interface ICatalogArtifactTag
                 * @property {string|null} [artifactId] CatalogArtifactTag artifactId
                 * @property {string|null} [name] CatalogArtifactTag name
                 */
    
                /**
                 * Constructs a new CatalogArtifactTag.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a CatalogArtifactTag.
                 * @implements ICatalogArtifactTag
                 * @constructor
                 * @param {nebulaidl.core.ICatalogArtifactTag=} [properties] Properties to set
                 */
                function CatalogArtifactTag(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CatalogArtifactTag artifactId.
                 * @member {string} artifactId
                 * @memberof nebulaidl.core.CatalogArtifactTag
                 * @instance
                 */
                CatalogArtifactTag.prototype.artifactId = "";
    
                /**
                 * CatalogArtifactTag name.
                 * @member {string} name
                 * @memberof nebulaidl.core.CatalogArtifactTag
                 * @instance
                 */
                CatalogArtifactTag.prototype.name = "";
    
                /**
                 * Creates a new CatalogArtifactTag instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.CatalogArtifactTag
                 * @static
                 * @param {nebulaidl.core.ICatalogArtifactTag=} [properties] Properties to set
                 * @returns {nebulaidl.core.CatalogArtifactTag} CatalogArtifactTag instance
                 */
                CatalogArtifactTag.create = function create(properties) {
                    return new CatalogArtifactTag(properties);
                };
    
                /**
                 * Encodes the specified CatalogArtifactTag message. Does not implicitly {@link nebulaidl.core.CatalogArtifactTag.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.CatalogArtifactTag
                 * @static
                 * @param {nebulaidl.core.ICatalogArtifactTag} message CatalogArtifactTag message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CatalogArtifactTag.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.artifactId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    return writer;
                };
    
                /**
                 * Decodes a CatalogArtifactTag message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.CatalogArtifactTag
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.CatalogArtifactTag} CatalogArtifactTag
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CatalogArtifactTag.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.CatalogArtifactTag();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.artifactId = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CatalogArtifactTag message.
                 * @function verify
                 * @memberof nebulaidl.core.CatalogArtifactTag
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CatalogArtifactTag.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                        if (!$util.isString(message.artifactId))
                            return "artifactId: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };
    
                return CatalogArtifactTag;
            })();
    
            core.CatalogMetadata = (function() {
    
                /**
                 * Properties of a CatalogMetadata.
                 * @memberof nebulaidl.core
                 * @interface ICatalogMetadata
                 * @property {nebulaidl.core.IIdentifier|null} [datasetId] CatalogMetadata datasetId
                 * @property {nebulaidl.core.ICatalogArtifactTag|null} [artifactTag] CatalogMetadata artifactTag
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [sourceTaskExecution] CatalogMetadata sourceTaskExecution
                 */
    
                /**
                 * Constructs a new CatalogMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a CatalogMetadata.
                 * @implements ICatalogMetadata
                 * @constructor
                 * @param {nebulaidl.core.ICatalogMetadata=} [properties] Properties to set
                 */
                function CatalogMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CatalogMetadata datasetId.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} datasetId
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @instance
                 */
                CatalogMetadata.prototype.datasetId = null;
    
                /**
                 * CatalogMetadata artifactTag.
                 * @member {nebulaidl.core.ICatalogArtifactTag|null|undefined} artifactTag
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @instance
                 */
                CatalogMetadata.prototype.artifactTag = null;
    
                /**
                 * CatalogMetadata sourceTaskExecution.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} sourceTaskExecution
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @instance
                 */
                CatalogMetadata.prototype.sourceTaskExecution = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * CatalogMetadata sourceExecution.
                 * @member {"sourceTaskExecution"|undefined} sourceExecution
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @instance
                 */
                Object.defineProperty(CatalogMetadata.prototype, "sourceExecution", {
                    get: $util.oneOfGetter($oneOfFields = ["sourceTaskExecution"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new CatalogMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @static
                 * @param {nebulaidl.core.ICatalogMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.CatalogMetadata} CatalogMetadata instance
                 */
                CatalogMetadata.create = function create(properties) {
                    return new CatalogMetadata(properties);
                };
    
                /**
                 * Encodes the specified CatalogMetadata message. Does not implicitly {@link nebulaidl.core.CatalogMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @static
                 * @param {nebulaidl.core.ICatalogMetadata} message CatalogMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CatalogMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.datasetId != null && message.hasOwnProperty("datasetId"))
                        $root.nebulaidl.core.Identifier.encode(message.datasetId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.artifactTag != null && message.hasOwnProperty("artifactTag"))
                        $root.nebulaidl.core.CatalogArtifactTag.encode(message.artifactTag, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.sourceTaskExecution != null && message.hasOwnProperty("sourceTaskExecution"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.sourceTaskExecution, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CatalogMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.CatalogMetadata} CatalogMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CatalogMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.CatalogMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.datasetId = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.artifactTag = $root.nebulaidl.core.CatalogArtifactTag.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.sourceTaskExecution = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CatalogMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.CatalogMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CatalogMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.datasetId != null && message.hasOwnProperty("datasetId")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.datasetId);
                        if (error)
                            return "datasetId." + error;
                    }
                    if (message.artifactTag != null && message.hasOwnProperty("artifactTag")) {
                        var error = $root.nebulaidl.core.CatalogArtifactTag.verify(message.artifactTag);
                        if (error)
                            return "artifactTag." + error;
                    }
                    if (message.sourceTaskExecution != null && message.hasOwnProperty("sourceTaskExecution")) {
                        properties.sourceExecution = 1;
                        {
                            var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.sourceTaskExecution);
                            if (error)
                                return "sourceTaskExecution." + error;
                        }
                    }
                    return null;
                };
    
                return CatalogMetadata;
            })();
    
            core.CatalogReservation = (function() {
    
                /**
                 * Properties of a CatalogReservation.
                 * @memberof nebulaidl.core
                 * @interface ICatalogReservation
                 */
    
                /**
                 * Constructs a new CatalogReservation.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a CatalogReservation.
                 * @implements ICatalogReservation
                 * @constructor
                 * @param {nebulaidl.core.ICatalogReservation=} [properties] Properties to set
                 */
                function CatalogReservation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new CatalogReservation instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.CatalogReservation
                 * @static
                 * @param {nebulaidl.core.ICatalogReservation=} [properties] Properties to set
                 * @returns {nebulaidl.core.CatalogReservation} CatalogReservation instance
                 */
                CatalogReservation.create = function create(properties) {
                    return new CatalogReservation(properties);
                };
    
                /**
                 * Encodes the specified CatalogReservation message. Does not implicitly {@link nebulaidl.core.CatalogReservation.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.CatalogReservation
                 * @static
                 * @param {nebulaidl.core.ICatalogReservation} message CatalogReservation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CatalogReservation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a CatalogReservation message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.CatalogReservation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.CatalogReservation} CatalogReservation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CatalogReservation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.CatalogReservation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CatalogReservation message.
                 * @function verify
                 * @memberof nebulaidl.core.CatalogReservation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CatalogReservation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Status enum.
                 * @name nebulaidl.core.CatalogReservation.Status
                 * @enum {string}
                 * @property {number} RESERVATION_DISABLED=0 RESERVATION_DISABLED value
                 * @property {number} RESERVATION_ACQUIRED=1 RESERVATION_ACQUIRED value
                 * @property {number} RESERVATION_EXISTS=2 RESERVATION_EXISTS value
                 * @property {number} RESERVATION_RELEASED=3 RESERVATION_RELEASED value
                 * @property {number} RESERVATION_FAILURE=4 RESERVATION_FAILURE value
                 */
                CatalogReservation.Status = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "RESERVATION_DISABLED"] = 0;
                    values[valuesById[1] = "RESERVATION_ACQUIRED"] = 1;
                    values[valuesById[2] = "RESERVATION_EXISTS"] = 2;
                    values[valuesById[3] = "RESERVATION_RELEASED"] = 3;
                    values[valuesById[4] = "RESERVATION_FAILURE"] = 4;
                    return values;
                })();
    
                return CatalogReservation;
            })();
    
            /**
             * ResourceType enum.
             * @name nebulaidl.core.ResourceType
             * @enum {string}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} TASK=1 TASK value
             * @property {number} WORKFLOW=2 WORKFLOW value
             * @property {number} LAUNCH_PLAN=3 LAUNCH_PLAN value
             * @property {number} DATASET=4 DATASET value
             */
            core.ResourceType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "TASK"] = 1;
                values[valuesById[2] = "WORKFLOW"] = 2;
                values[valuesById[3] = "LAUNCH_PLAN"] = 3;
                values[valuesById[4] = "DATASET"] = 4;
                return values;
            })();
    
            core.Identifier = (function() {
    
                /**
                 * Properties of an Identifier.
                 * @memberof nebulaidl.core
                 * @interface IIdentifier
                 * @property {nebulaidl.core.ResourceType|null} [resourceType] Identifier resourceType
                 * @property {string|null} [project] Identifier project
                 * @property {string|null} [domain] Identifier domain
                 * @property {string|null} [name] Identifier name
                 * @property {string|null} [version] Identifier version
                 */
    
                /**
                 * Constructs a new Identifier.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an Identifier.
                 * @implements IIdentifier
                 * @constructor
                 * @param {nebulaidl.core.IIdentifier=} [properties] Properties to set
                 */
                function Identifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Identifier resourceType.
                 * @member {nebulaidl.core.ResourceType} resourceType
                 * @memberof nebulaidl.core.Identifier
                 * @instance
                 */
                Identifier.prototype.resourceType = 0;
    
                /**
                 * Identifier project.
                 * @member {string} project
                 * @memberof nebulaidl.core.Identifier
                 * @instance
                 */
                Identifier.prototype.project = "";
    
                /**
                 * Identifier domain.
                 * @member {string} domain
                 * @memberof nebulaidl.core.Identifier
                 * @instance
                 */
                Identifier.prototype.domain = "";
    
                /**
                 * Identifier name.
                 * @member {string} name
                 * @memberof nebulaidl.core.Identifier
                 * @instance
                 */
                Identifier.prototype.name = "";
    
                /**
                 * Identifier version.
                 * @member {string} version
                 * @memberof nebulaidl.core.Identifier
                 * @instance
                 */
                Identifier.prototype.version = "";
    
                /**
                 * Creates a new Identifier instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Identifier
                 * @static
                 * @param {nebulaidl.core.IIdentifier=} [properties] Properties to set
                 * @returns {nebulaidl.core.Identifier} Identifier instance
                 */
                Identifier.create = function create(properties) {
                    return new Identifier(properties);
                };
    
                /**
                 * Encodes the specified Identifier message. Does not implicitly {@link nebulaidl.core.Identifier.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Identifier
                 * @static
                 * @param {nebulaidl.core.IIdentifier} message Identifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Identifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.domain);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                    if (message.version != null && message.hasOwnProperty("version"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);
                    return writer;
                };
    
                /**
                 * Decodes an Identifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Identifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Identifier} Identifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Identifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Identifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        case 2:
                            message.project = reader.string();
                            break;
                        case 3:
                            message.domain = reader.string();
                            break;
                        case 4:
                            message.name = reader.string();
                            break;
                        case 5:
                            message.version = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Identifier message.
                 * @function verify
                 * @memberof nebulaidl.core.Identifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Identifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };
    
                return Identifier;
            })();
    
            core.WorkflowExecutionIdentifier = (function() {
    
                /**
                 * Properties of a WorkflowExecutionIdentifier.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowExecutionIdentifier
                 * @property {string|null} [project] WorkflowExecutionIdentifier project
                 * @property {string|null} [domain] WorkflowExecutionIdentifier domain
                 * @property {string|null} [name] WorkflowExecutionIdentifier name
                 */
    
                /**
                 * Constructs a new WorkflowExecutionIdentifier.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowExecutionIdentifier.
                 * @implements IWorkflowExecutionIdentifier
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowExecutionIdentifier=} [properties] Properties to set
                 */
                function WorkflowExecutionIdentifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionIdentifier project.
                 * @member {string} project
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @instance
                 */
                WorkflowExecutionIdentifier.prototype.project = "";
    
                /**
                 * WorkflowExecutionIdentifier domain.
                 * @member {string} domain
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @instance
                 */
                WorkflowExecutionIdentifier.prototype.domain = "";
    
                /**
                 * WorkflowExecutionIdentifier name.
                 * @member {string} name
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @instance
                 */
                WorkflowExecutionIdentifier.prototype.name = "";
    
                /**
                 * Creates a new WorkflowExecutionIdentifier instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @static
                 * @param {nebulaidl.core.IWorkflowExecutionIdentifier=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowExecutionIdentifier} WorkflowExecutionIdentifier instance
                 */
                WorkflowExecutionIdentifier.create = function create(properties) {
                    return new WorkflowExecutionIdentifier(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionIdentifier message. Does not implicitly {@link nebulaidl.core.WorkflowExecutionIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @static
                 * @param {nebulaidl.core.IWorkflowExecutionIdentifier} message WorkflowExecutionIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowExecutionIdentifier} WorkflowExecutionIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowExecutionIdentifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 4:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionIdentifier message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowExecutionIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };
    
                return WorkflowExecutionIdentifier;
            })();
    
            core.NodeExecutionIdentifier = (function() {
    
                /**
                 * Properties of a NodeExecutionIdentifier.
                 * @memberof nebulaidl.core
                 * @interface INodeExecutionIdentifier
                 * @property {string|null} [nodeId] NodeExecutionIdentifier nodeId
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [executionId] NodeExecutionIdentifier executionId
                 */
    
                /**
                 * Constructs a new NodeExecutionIdentifier.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a NodeExecutionIdentifier.
                 * @implements INodeExecutionIdentifier
                 * @constructor
                 * @param {nebulaidl.core.INodeExecutionIdentifier=} [properties] Properties to set
                 */
                function NodeExecutionIdentifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionIdentifier nodeId.
                 * @member {string} nodeId
                 * @memberof nebulaidl.core.NodeExecutionIdentifier
                 * @instance
                 */
                NodeExecutionIdentifier.prototype.nodeId = "";
    
                /**
                 * NodeExecutionIdentifier executionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
                 * @memberof nebulaidl.core.NodeExecutionIdentifier
                 * @instance
                 */
                NodeExecutionIdentifier.prototype.executionId = null;
    
                /**
                 * Creates a new NodeExecutionIdentifier instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.NodeExecutionIdentifier
                 * @static
                 * @param {nebulaidl.core.INodeExecutionIdentifier=} [properties] Properties to set
                 * @returns {nebulaidl.core.NodeExecutionIdentifier} NodeExecutionIdentifier instance
                 */
                NodeExecutionIdentifier.create = function create(properties) {
                    return new NodeExecutionIdentifier(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionIdentifier message. Does not implicitly {@link nebulaidl.core.NodeExecutionIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.NodeExecutionIdentifier
                 * @static
                 * @param {nebulaidl.core.INodeExecutionIdentifier} message NodeExecutionIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                    if (message.executionId != null && message.hasOwnProperty("executionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.NodeExecutionIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.NodeExecutionIdentifier} NodeExecutionIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.NodeExecutionIdentifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nodeId = reader.string();
                            break;
                        case 2:
                            message.executionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionIdentifier message.
                 * @function verify
                 * @memberof nebulaidl.core.NodeExecutionIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        if (!$util.isString(message.nodeId))
                            return "nodeId: string expected";
                    if (message.executionId != null && message.hasOwnProperty("executionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                        if (error)
                            return "executionId." + error;
                    }
                    return null;
                };
    
                return NodeExecutionIdentifier;
            })();
    
            core.TaskExecutionIdentifier = (function() {
    
                /**
                 * Properties of a TaskExecutionIdentifier.
                 * @memberof nebulaidl.core
                 * @interface ITaskExecutionIdentifier
                 * @property {nebulaidl.core.IIdentifier|null} [taskId] TaskExecutionIdentifier taskId
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [nodeExecutionId] TaskExecutionIdentifier nodeExecutionId
                 * @property {number|null} [retryAttempt] TaskExecutionIdentifier retryAttempt
                 */
    
                /**
                 * Constructs a new TaskExecutionIdentifier.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskExecutionIdentifier.
                 * @implements ITaskExecutionIdentifier
                 * @constructor
                 * @param {nebulaidl.core.ITaskExecutionIdentifier=} [properties] Properties to set
                 */
                function TaskExecutionIdentifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionIdentifier taskId.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} taskId
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @instance
                 */
                TaskExecutionIdentifier.prototype.taskId = null;
    
                /**
                 * TaskExecutionIdentifier nodeExecutionId.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} nodeExecutionId
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @instance
                 */
                TaskExecutionIdentifier.prototype.nodeExecutionId = null;
    
                /**
                 * TaskExecutionIdentifier retryAttempt.
                 * @member {number} retryAttempt
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @instance
                 */
                TaskExecutionIdentifier.prototype.retryAttempt = 0;
    
                /**
                 * Creates a new TaskExecutionIdentifier instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @static
                 * @param {nebulaidl.core.ITaskExecutionIdentifier=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskExecutionIdentifier} TaskExecutionIdentifier instance
                 */
                TaskExecutionIdentifier.create = function create(properties) {
                    return new TaskExecutionIdentifier(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionIdentifier message. Does not implicitly {@link nebulaidl.core.TaskExecutionIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @static
                 * @param {nebulaidl.core.ITaskExecutionIdentifier} message TaskExecutionIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        $root.nebulaidl.core.Identifier.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.nodeExecutionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryAttempt);
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskExecutionIdentifier} TaskExecutionIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskExecutionIdentifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskId = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.nodeExecutionId = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.retryAttempt = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionIdentifier message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskExecutionIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskId != null && message.hasOwnProperty("taskId")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.taskId);
                        if (error)
                            return "taskId." + error;
                    }
                    if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.nodeExecutionId);
                        if (error)
                            return "nodeExecutionId." + error;
                    }
                    if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                        if (!$util.isInteger(message.retryAttempt))
                            return "retryAttempt: integer expected";
                    return null;
                };
    
                return TaskExecutionIdentifier;
            })();
    
            core.SignalIdentifier = (function() {
    
                /**
                 * Properties of a SignalIdentifier.
                 * @memberof nebulaidl.core
                 * @interface ISignalIdentifier
                 * @property {string|null} [signalId] SignalIdentifier signalId
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [executionId] SignalIdentifier executionId
                 */
    
                /**
                 * Constructs a new SignalIdentifier.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a SignalIdentifier.
                 * @implements ISignalIdentifier
                 * @constructor
                 * @param {nebulaidl.core.ISignalIdentifier=} [properties] Properties to set
                 */
                function SignalIdentifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SignalIdentifier signalId.
                 * @member {string} signalId
                 * @memberof nebulaidl.core.SignalIdentifier
                 * @instance
                 */
                SignalIdentifier.prototype.signalId = "";
    
                /**
                 * SignalIdentifier executionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
                 * @memberof nebulaidl.core.SignalIdentifier
                 * @instance
                 */
                SignalIdentifier.prototype.executionId = null;
    
                /**
                 * Creates a new SignalIdentifier instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.SignalIdentifier
                 * @static
                 * @param {nebulaidl.core.ISignalIdentifier=} [properties] Properties to set
                 * @returns {nebulaidl.core.SignalIdentifier} SignalIdentifier instance
                 */
                SignalIdentifier.create = function create(properties) {
                    return new SignalIdentifier(properties);
                };
    
                /**
                 * Encodes the specified SignalIdentifier message. Does not implicitly {@link nebulaidl.core.SignalIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.SignalIdentifier
                 * @static
                 * @param {nebulaidl.core.ISignalIdentifier} message SignalIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signalId != null && message.hasOwnProperty("signalId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalId);
                    if (message.executionId != null && message.hasOwnProperty("executionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SignalIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.SignalIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.SignalIdentifier} SignalIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.SignalIdentifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.signalId = reader.string();
                            break;
                        case 2:
                            message.executionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalIdentifier message.
                 * @function verify
                 * @memberof nebulaidl.core.SignalIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signalId != null && message.hasOwnProperty("signalId"))
                        if (!$util.isString(message.signalId))
                            return "signalId: string expected";
                    if (message.executionId != null && message.hasOwnProperty("executionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                        if (error)
                            return "executionId." + error;
                    }
                    return null;
                };
    
                return SignalIdentifier;
            })();
    
            core.ConnectionSet = (function() {
    
                /**
                 * Properties of a ConnectionSet.
                 * @memberof nebulaidl.core
                 * @interface IConnectionSet
                 * @property {Object.<string,nebulaidl.core.ConnectionSet.IIdList>|null} [downstream] ConnectionSet downstream
                 * @property {Object.<string,nebulaidl.core.ConnectionSet.IIdList>|null} [upstream] ConnectionSet upstream
                 */
    
                /**
                 * Constructs a new ConnectionSet.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a ConnectionSet.
                 * @implements IConnectionSet
                 * @constructor
                 * @param {nebulaidl.core.IConnectionSet=} [properties] Properties to set
                 */
                function ConnectionSet(properties) {
                    this.downstream = {};
                    this.upstream = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectionSet downstream.
                 * @member {Object.<string,nebulaidl.core.ConnectionSet.IIdList>} downstream
                 * @memberof nebulaidl.core.ConnectionSet
                 * @instance
                 */
                ConnectionSet.prototype.downstream = $util.emptyObject;
    
                /**
                 * ConnectionSet upstream.
                 * @member {Object.<string,nebulaidl.core.ConnectionSet.IIdList>} upstream
                 * @memberof nebulaidl.core.ConnectionSet
                 * @instance
                 */
                ConnectionSet.prototype.upstream = $util.emptyObject;
    
                /**
                 * Creates a new ConnectionSet instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ConnectionSet
                 * @static
                 * @param {nebulaidl.core.IConnectionSet=} [properties] Properties to set
                 * @returns {nebulaidl.core.ConnectionSet} ConnectionSet instance
                 */
                ConnectionSet.create = function create(properties) {
                    return new ConnectionSet(properties);
                };
    
                /**
                 * Encodes the specified ConnectionSet message. Does not implicitly {@link nebulaidl.core.ConnectionSet.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ConnectionSet
                 * @static
                 * @param {nebulaidl.core.IConnectionSet} message ConnectionSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectionSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.downstream != null && message.hasOwnProperty("downstream"))
                        for (var keys = Object.keys(message.downstream), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.nebulaidl.core.ConnectionSet.IdList.encode(message.downstream[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.upstream != null && message.hasOwnProperty("upstream"))
                        for (var keys = Object.keys(message.upstream), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.nebulaidl.core.ConnectionSet.IdList.encode(message.upstream[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Decodes a ConnectionSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ConnectionSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ConnectionSet} ConnectionSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectionSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ConnectionSet(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 7:
                            reader.skip().pos++;
                            if (message.downstream === $util.emptyObject)
                                message.downstream = {};
                            key = reader.string();
                            reader.pos++;
                            message.downstream[key] = $root.nebulaidl.core.ConnectionSet.IdList.decode(reader, reader.uint32());
                            break;
                        case 8:
                            reader.skip().pos++;
                            if (message.upstream === $util.emptyObject)
                                message.upstream = {};
                            key = reader.string();
                            reader.pos++;
                            message.upstream[key] = $root.nebulaidl.core.ConnectionSet.IdList.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ConnectionSet message.
                 * @function verify
                 * @memberof nebulaidl.core.ConnectionSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectionSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.downstream != null && message.hasOwnProperty("downstream")) {
                        if (!$util.isObject(message.downstream))
                            return "downstream: object expected";
                        var key = Object.keys(message.downstream);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.nebulaidl.core.ConnectionSet.IdList.verify(message.downstream[key[i]]);
                            if (error)
                                return "downstream." + error;
                        }
                    }
                    if (message.upstream != null && message.hasOwnProperty("upstream")) {
                        if (!$util.isObject(message.upstream))
                            return "upstream: object expected";
                        var key = Object.keys(message.upstream);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.nebulaidl.core.ConnectionSet.IdList.verify(message.upstream[key[i]]);
                            if (error)
                                return "upstream." + error;
                        }
                    }
                    return null;
                };
    
                ConnectionSet.IdList = (function() {
    
                    /**
                     * Properties of an IdList.
                     * @memberof nebulaidl.core.ConnectionSet
                     * @interface IIdList
                     * @property {Array.<string>|null} [ids] IdList ids
                     */
    
                    /**
                     * Constructs a new IdList.
                     * @memberof nebulaidl.core.ConnectionSet
                     * @classdesc Represents an IdList.
                     * @implements IIdList
                     * @constructor
                     * @param {nebulaidl.core.ConnectionSet.IIdList=} [properties] Properties to set
                     */
                    function IdList(properties) {
                        this.ids = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * IdList ids.
                     * @member {Array.<string>} ids
                     * @memberof nebulaidl.core.ConnectionSet.IdList
                     * @instance
                     */
                    IdList.prototype.ids = $util.emptyArray;
    
                    /**
                     * Creates a new IdList instance using the specified properties.
                     * @function create
                     * @memberof nebulaidl.core.ConnectionSet.IdList
                     * @static
                     * @param {nebulaidl.core.ConnectionSet.IIdList=} [properties] Properties to set
                     * @returns {nebulaidl.core.ConnectionSet.IdList} IdList instance
                     */
                    IdList.create = function create(properties) {
                        return new IdList(properties);
                    };
    
                    /**
                     * Encodes the specified IdList message. Does not implicitly {@link nebulaidl.core.ConnectionSet.IdList.verify|verify} messages.
                     * @function encode
                     * @memberof nebulaidl.core.ConnectionSet.IdList
                     * @static
                     * @param {nebulaidl.core.ConnectionSet.IIdList} message IdList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IdList.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ids != null && message.ids.length)
                            for (var i = 0; i < message.ids.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ids[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes an IdList message from the specified reader or buffer.
                     * @function decode
                     * @memberof nebulaidl.core.ConnectionSet.IdList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {nebulaidl.core.ConnectionSet.IdList} IdList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IdList.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ConnectionSet.IdList();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.ids && message.ids.length))
                                    message.ids = [];
                                message.ids.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an IdList message.
                     * @function verify
                     * @memberof nebulaidl.core.ConnectionSet.IdList
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IdList.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ids != null && message.hasOwnProperty("ids")) {
                            if (!Array.isArray(message.ids))
                                return "ids: array expected";
                            for (var i = 0; i < message.ids.length; ++i)
                                if (!$util.isString(message.ids[i]))
                                    return "ids: string[] expected";
                        }
                        return null;
                    };
    
                    return IdList;
                })();
    
                return ConnectionSet;
            })();
    
            core.CompiledWorkflow = (function() {
    
                /**
                 * Properties of a CompiledWorkflow.
                 * @memberof nebulaidl.core
                 * @interface ICompiledWorkflow
                 * @property {nebulaidl.core.IWorkflowTemplate|null} [template] CompiledWorkflow template
                 * @property {nebulaidl.core.IConnectionSet|null} [connections] CompiledWorkflow connections
                 */
    
                /**
                 * Constructs a new CompiledWorkflow.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a CompiledWorkflow.
                 * @implements ICompiledWorkflow
                 * @constructor
                 * @param {nebulaidl.core.ICompiledWorkflow=} [properties] Properties to set
                 */
                function CompiledWorkflow(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CompiledWorkflow template.
                 * @member {nebulaidl.core.IWorkflowTemplate|null|undefined} template
                 * @memberof nebulaidl.core.CompiledWorkflow
                 * @instance
                 */
                CompiledWorkflow.prototype.template = null;
    
                /**
                 * CompiledWorkflow connections.
                 * @member {nebulaidl.core.IConnectionSet|null|undefined} connections
                 * @memberof nebulaidl.core.CompiledWorkflow
                 * @instance
                 */
                CompiledWorkflow.prototype.connections = null;
    
                /**
                 * Creates a new CompiledWorkflow instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.CompiledWorkflow
                 * @static
                 * @param {nebulaidl.core.ICompiledWorkflow=} [properties] Properties to set
                 * @returns {nebulaidl.core.CompiledWorkflow} CompiledWorkflow instance
                 */
                CompiledWorkflow.create = function create(properties) {
                    return new CompiledWorkflow(properties);
                };
    
                /**
                 * Encodes the specified CompiledWorkflow message. Does not implicitly {@link nebulaidl.core.CompiledWorkflow.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.CompiledWorkflow
                 * @static
                 * @param {nebulaidl.core.ICompiledWorkflow} message CompiledWorkflow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompiledWorkflow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.template != null && message.hasOwnProperty("template"))
                        $root.nebulaidl.core.WorkflowTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.connections != null && message.hasOwnProperty("connections"))
                        $root.nebulaidl.core.ConnectionSet.encode(message.connections, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CompiledWorkflow message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.CompiledWorkflow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.CompiledWorkflow} CompiledWorkflow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompiledWorkflow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.CompiledWorkflow();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.template = $root.nebulaidl.core.WorkflowTemplate.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.connections = $root.nebulaidl.core.ConnectionSet.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CompiledWorkflow message.
                 * @function verify
                 * @memberof nebulaidl.core.CompiledWorkflow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CompiledWorkflow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.template != null && message.hasOwnProperty("template")) {
                        var error = $root.nebulaidl.core.WorkflowTemplate.verify(message.template);
                        if (error)
                            return "template." + error;
                    }
                    if (message.connections != null && message.hasOwnProperty("connections")) {
                        var error = $root.nebulaidl.core.ConnectionSet.verify(message.connections);
                        if (error)
                            return "connections." + error;
                    }
                    return null;
                };
    
                return CompiledWorkflow;
            })();
    
            core.CompiledTask = (function() {
    
                /**
                 * Properties of a CompiledTask.
                 * @memberof nebulaidl.core
                 * @interface ICompiledTask
                 * @property {nebulaidl.core.ITaskTemplate|null} [template] CompiledTask template
                 */
    
                /**
                 * Constructs a new CompiledTask.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a CompiledTask.
                 * @implements ICompiledTask
                 * @constructor
                 * @param {nebulaidl.core.ICompiledTask=} [properties] Properties to set
                 */
                function CompiledTask(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CompiledTask template.
                 * @member {nebulaidl.core.ITaskTemplate|null|undefined} template
                 * @memberof nebulaidl.core.CompiledTask
                 * @instance
                 */
                CompiledTask.prototype.template = null;
    
                /**
                 * Creates a new CompiledTask instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.CompiledTask
                 * @static
                 * @param {nebulaidl.core.ICompiledTask=} [properties] Properties to set
                 * @returns {nebulaidl.core.CompiledTask} CompiledTask instance
                 */
                CompiledTask.create = function create(properties) {
                    return new CompiledTask(properties);
                };
    
                /**
                 * Encodes the specified CompiledTask message. Does not implicitly {@link nebulaidl.core.CompiledTask.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.CompiledTask
                 * @static
                 * @param {nebulaidl.core.ICompiledTask} message CompiledTask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompiledTask.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.template != null && message.hasOwnProperty("template"))
                        $root.nebulaidl.core.TaskTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CompiledTask message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.CompiledTask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.CompiledTask} CompiledTask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompiledTask.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.CompiledTask();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.template = $root.nebulaidl.core.TaskTemplate.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CompiledTask message.
                 * @function verify
                 * @memberof nebulaidl.core.CompiledTask
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CompiledTask.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.template != null && message.hasOwnProperty("template")) {
                        var error = $root.nebulaidl.core.TaskTemplate.verify(message.template);
                        if (error)
                            return "template." + error;
                    }
                    return null;
                };
    
                return CompiledTask;
            })();
    
            core.CompiledWorkflowClosure = (function() {
    
                /**
                 * Properties of a CompiledWorkflowClosure.
                 * @memberof nebulaidl.core
                 * @interface ICompiledWorkflowClosure
                 * @property {nebulaidl.core.ICompiledWorkflow|null} [primary] CompiledWorkflowClosure primary
                 * @property {Array.<nebulaidl.core.ICompiledWorkflow>|null} [subWorkflows] CompiledWorkflowClosure subWorkflows
                 * @property {Array.<nebulaidl.core.ICompiledTask>|null} [tasks] CompiledWorkflowClosure tasks
                 */
    
                /**
                 * Constructs a new CompiledWorkflowClosure.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a CompiledWorkflowClosure.
                 * @implements ICompiledWorkflowClosure
                 * @constructor
                 * @param {nebulaidl.core.ICompiledWorkflowClosure=} [properties] Properties to set
                 */
                function CompiledWorkflowClosure(properties) {
                    this.subWorkflows = [];
                    this.tasks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CompiledWorkflowClosure primary.
                 * @member {nebulaidl.core.ICompiledWorkflow|null|undefined} primary
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @instance
                 */
                CompiledWorkflowClosure.prototype.primary = null;
    
                /**
                 * CompiledWorkflowClosure subWorkflows.
                 * @member {Array.<nebulaidl.core.ICompiledWorkflow>} subWorkflows
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @instance
                 */
                CompiledWorkflowClosure.prototype.subWorkflows = $util.emptyArray;
    
                /**
                 * CompiledWorkflowClosure tasks.
                 * @member {Array.<nebulaidl.core.ICompiledTask>} tasks
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @instance
                 */
                CompiledWorkflowClosure.prototype.tasks = $util.emptyArray;
    
                /**
                 * Creates a new CompiledWorkflowClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @static
                 * @param {nebulaidl.core.ICompiledWorkflowClosure=} [properties] Properties to set
                 * @returns {nebulaidl.core.CompiledWorkflowClosure} CompiledWorkflowClosure instance
                 */
                CompiledWorkflowClosure.create = function create(properties) {
                    return new CompiledWorkflowClosure(properties);
                };
    
                /**
                 * Encodes the specified CompiledWorkflowClosure message. Does not implicitly {@link nebulaidl.core.CompiledWorkflowClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @static
                 * @param {nebulaidl.core.ICompiledWorkflowClosure} message CompiledWorkflowClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompiledWorkflowClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.primary != null && message.hasOwnProperty("primary"))
                        $root.nebulaidl.core.CompiledWorkflow.encode(message.primary, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.subWorkflows != null && message.subWorkflows.length)
                        for (var i = 0; i < message.subWorkflows.length; ++i)
                            $root.nebulaidl.core.CompiledWorkflow.encode(message.subWorkflows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.tasks != null && message.tasks.length)
                        for (var i = 0; i < message.tasks.length; ++i)
                            $root.nebulaidl.core.CompiledTask.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CompiledWorkflowClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.CompiledWorkflowClosure} CompiledWorkflowClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompiledWorkflowClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.CompiledWorkflowClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.primary = $root.nebulaidl.core.CompiledWorkflow.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.subWorkflows && message.subWorkflows.length))
                                message.subWorkflows = [];
                            message.subWorkflows.push($root.nebulaidl.core.CompiledWorkflow.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.nebulaidl.core.CompiledTask.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CompiledWorkflowClosure message.
                 * @function verify
                 * @memberof nebulaidl.core.CompiledWorkflowClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CompiledWorkflowClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.primary != null && message.hasOwnProperty("primary")) {
                        var error = $root.nebulaidl.core.CompiledWorkflow.verify(message.primary);
                        if (error)
                            return "primary." + error;
                    }
                    if (message.subWorkflows != null && message.hasOwnProperty("subWorkflows")) {
                        if (!Array.isArray(message.subWorkflows))
                            return "subWorkflows: array expected";
                        for (var i = 0; i < message.subWorkflows.length; ++i) {
                            var error = $root.nebulaidl.core.CompiledWorkflow.verify(message.subWorkflows[i]);
                            if (error)
                                return "subWorkflows." + error;
                        }
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (var i = 0; i < message.tasks.length; ++i) {
                            var error = $root.nebulaidl.core.CompiledTask.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    return null;
                };
    
                return CompiledWorkflowClosure;
            })();
    
            core.IfBlock = (function() {
    
                /**
                 * Properties of an IfBlock.
                 * @memberof nebulaidl.core
                 * @interface IIfBlock
                 * @property {nebulaidl.core.IBooleanExpression|null} [condition] IfBlock condition
                 * @property {nebulaidl.core.INode|null} [thenNode] IfBlock thenNode
                 */
    
                /**
                 * Constructs a new IfBlock.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an IfBlock.
                 * @implements IIfBlock
                 * @constructor
                 * @param {nebulaidl.core.IIfBlock=} [properties] Properties to set
                 */
                function IfBlock(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IfBlock condition.
                 * @member {nebulaidl.core.IBooleanExpression|null|undefined} condition
                 * @memberof nebulaidl.core.IfBlock
                 * @instance
                 */
                IfBlock.prototype.condition = null;
    
                /**
                 * IfBlock thenNode.
                 * @member {nebulaidl.core.INode|null|undefined} thenNode
                 * @memberof nebulaidl.core.IfBlock
                 * @instance
                 */
                IfBlock.prototype.thenNode = null;
    
                /**
                 * Creates a new IfBlock instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.IfBlock
                 * @static
                 * @param {nebulaidl.core.IIfBlock=} [properties] Properties to set
                 * @returns {nebulaidl.core.IfBlock} IfBlock instance
                 */
                IfBlock.create = function create(properties) {
                    return new IfBlock(properties);
                };
    
                /**
                 * Encodes the specified IfBlock message. Does not implicitly {@link nebulaidl.core.IfBlock.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.IfBlock
                 * @static
                 * @param {nebulaidl.core.IIfBlock} message IfBlock message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IfBlock.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.condition != null && message.hasOwnProperty("condition"))
                        $root.nebulaidl.core.BooleanExpression.encode(message.condition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.thenNode != null && message.hasOwnProperty("thenNode"))
                        $root.nebulaidl.core.Node.encode(message.thenNode, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an IfBlock message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.IfBlock
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.IfBlock} IfBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IfBlock.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.IfBlock();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.condition = $root.nebulaidl.core.BooleanExpression.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.thenNode = $root.nebulaidl.core.Node.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an IfBlock message.
                 * @function verify
                 * @memberof nebulaidl.core.IfBlock
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IfBlock.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.condition != null && message.hasOwnProperty("condition")) {
                        var error = $root.nebulaidl.core.BooleanExpression.verify(message.condition);
                        if (error)
                            return "condition." + error;
                    }
                    if (message.thenNode != null && message.hasOwnProperty("thenNode")) {
                        var error = $root.nebulaidl.core.Node.verify(message.thenNode);
                        if (error)
                            return "thenNode." + error;
                    }
                    return null;
                };
    
                return IfBlock;
            })();
    
            core.IfElseBlock = (function() {
    
                /**
                 * Properties of an IfElseBlock.
                 * @memberof nebulaidl.core
                 * @interface IIfElseBlock
                 * @property {nebulaidl.core.IIfBlock|null} ["case"] IfElseBlock case
                 * @property {Array.<nebulaidl.core.IIfBlock>|null} [other] IfElseBlock other
                 * @property {nebulaidl.core.INode|null} [elseNode] IfElseBlock elseNode
                 * @property {nebulaidl.core.IError|null} [error] IfElseBlock error
                 */
    
                /**
                 * Constructs a new IfElseBlock.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an IfElseBlock.
                 * @implements IIfElseBlock
                 * @constructor
                 * @param {nebulaidl.core.IIfElseBlock=} [properties] Properties to set
                 */
                function IfElseBlock(properties) {
                    this.other = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IfElseBlock case.
                 * @member {nebulaidl.core.IIfBlock|null|undefined} case
                 * @memberof nebulaidl.core.IfElseBlock
                 * @instance
                 */
                IfElseBlock.prototype["case"] = null;
    
                /**
                 * IfElseBlock other.
                 * @member {Array.<nebulaidl.core.IIfBlock>} other
                 * @memberof nebulaidl.core.IfElseBlock
                 * @instance
                 */
                IfElseBlock.prototype.other = $util.emptyArray;
    
                /**
                 * IfElseBlock elseNode.
                 * @member {nebulaidl.core.INode|null|undefined} elseNode
                 * @memberof nebulaidl.core.IfElseBlock
                 * @instance
                 */
                IfElseBlock.prototype.elseNode = null;
    
                /**
                 * IfElseBlock error.
                 * @member {nebulaidl.core.IError|null|undefined} error
                 * @memberof nebulaidl.core.IfElseBlock
                 * @instance
                 */
                IfElseBlock.prototype.error = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * IfElseBlock default.
                 * @member {"elseNode"|"error"|undefined} default_
                 * @memberof nebulaidl.core.IfElseBlock
                 * @instance
                 */
                Object.defineProperty(IfElseBlock.prototype, "default", {
                    get: $util.oneOfGetter($oneOfFields = ["elseNode", "error"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new IfElseBlock instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.IfElseBlock
                 * @static
                 * @param {nebulaidl.core.IIfElseBlock=} [properties] Properties to set
                 * @returns {nebulaidl.core.IfElseBlock} IfElseBlock instance
                 */
                IfElseBlock.create = function create(properties) {
                    return new IfElseBlock(properties);
                };
    
                /**
                 * Encodes the specified IfElseBlock message. Does not implicitly {@link nebulaidl.core.IfElseBlock.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.IfElseBlock
                 * @static
                 * @param {nebulaidl.core.IIfElseBlock} message IfElseBlock message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IfElseBlock.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["case"] != null && message.hasOwnProperty("case"))
                        $root.nebulaidl.core.IfBlock.encode(message["case"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.other != null && message.other.length)
                        for (var i = 0; i < message.other.length; ++i)
                            $root.nebulaidl.core.IfBlock.encode(message.other[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.elseNode != null && message.hasOwnProperty("elseNode"))
                        $root.nebulaidl.core.Node.encode(message.elseNode, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.Error.encode(message.error, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an IfElseBlock message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.IfElseBlock
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.IfElseBlock} IfElseBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IfElseBlock.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.IfElseBlock();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["case"] = $root.nebulaidl.core.IfBlock.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.other && message.other.length))
                                message.other = [];
                            message.other.push($root.nebulaidl.core.IfBlock.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.elseNode = $root.nebulaidl.core.Node.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.error = $root.nebulaidl.core.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an IfElseBlock message.
                 * @function verify
                 * @memberof nebulaidl.core.IfElseBlock
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IfElseBlock.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message["case"] != null && message.hasOwnProperty("case")) {
                        var error = $root.nebulaidl.core.IfBlock.verify(message["case"]);
                        if (error)
                            return "case." + error;
                    }
                    if (message.other != null && message.hasOwnProperty("other")) {
                        if (!Array.isArray(message.other))
                            return "other: array expected";
                        for (var i = 0; i < message.other.length; ++i) {
                            var error = $root.nebulaidl.core.IfBlock.verify(message.other[i]);
                            if (error)
                                return "other." + error;
                        }
                    }
                    if (message.elseNode != null && message.hasOwnProperty("elseNode")) {
                        properties["default"] = 1;
                        {
                            var error = $root.nebulaidl.core.Node.verify(message.elseNode);
                            if (error)
                                return "elseNode." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties["default"] === 1)
                            return "default: multiple values";
                        properties["default"] = 1;
                        {
                            var error = $root.nebulaidl.core.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    return null;
                };
    
                return IfElseBlock;
            })();
    
            core.BranchNode = (function() {
    
                /**
                 * Properties of a BranchNode.
                 * @memberof nebulaidl.core
                 * @interface IBranchNode
                 * @property {nebulaidl.core.IIfElseBlock|null} [ifElse] BranchNode ifElse
                 */
    
                /**
                 * Constructs a new BranchNode.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BranchNode.
                 * @implements IBranchNode
                 * @constructor
                 * @param {nebulaidl.core.IBranchNode=} [properties] Properties to set
                 */
                function BranchNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BranchNode ifElse.
                 * @member {nebulaidl.core.IIfElseBlock|null|undefined} ifElse
                 * @memberof nebulaidl.core.BranchNode
                 * @instance
                 */
                BranchNode.prototype.ifElse = null;
    
                /**
                 * Creates a new BranchNode instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BranchNode
                 * @static
                 * @param {nebulaidl.core.IBranchNode=} [properties] Properties to set
                 * @returns {nebulaidl.core.BranchNode} BranchNode instance
                 */
                BranchNode.create = function create(properties) {
                    return new BranchNode(properties);
                };
    
                /**
                 * Encodes the specified BranchNode message. Does not implicitly {@link nebulaidl.core.BranchNode.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BranchNode
                 * @static
                 * @param {nebulaidl.core.IBranchNode} message BranchNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BranchNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ifElse != null && message.hasOwnProperty("ifElse"))
                        $root.nebulaidl.core.IfElseBlock.encode(message.ifElse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a BranchNode message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BranchNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BranchNode} BranchNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BranchNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BranchNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ifElse = $root.nebulaidl.core.IfElseBlock.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BranchNode message.
                 * @function verify
                 * @memberof nebulaidl.core.BranchNode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BranchNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ifElse != null && message.hasOwnProperty("ifElse")) {
                        var error = $root.nebulaidl.core.IfElseBlock.verify(message.ifElse);
                        if (error)
                            return "ifElse." + error;
                    }
                    return null;
                };
    
                return BranchNode;
            })();
    
            core.TaskNode = (function() {
    
                /**
                 * Properties of a TaskNode.
                 * @memberof nebulaidl.core
                 * @interface ITaskNode
                 * @property {nebulaidl.core.IIdentifier|null} [referenceId] TaskNode referenceId
                 * @property {nebulaidl.core.ITaskNodeOverrides|null} [overrides] TaskNode overrides
                 */
    
                /**
                 * Constructs a new TaskNode.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskNode.
                 * @implements ITaskNode
                 * @constructor
                 * @param {nebulaidl.core.ITaskNode=} [properties] Properties to set
                 */
                function TaskNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskNode referenceId.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} referenceId
                 * @memberof nebulaidl.core.TaskNode
                 * @instance
                 */
                TaskNode.prototype.referenceId = null;
    
                /**
                 * TaskNode overrides.
                 * @member {nebulaidl.core.ITaskNodeOverrides|null|undefined} overrides
                 * @memberof nebulaidl.core.TaskNode
                 * @instance
                 */
                TaskNode.prototype.overrides = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * TaskNode reference.
                 * @member {"referenceId"|undefined} reference
                 * @memberof nebulaidl.core.TaskNode
                 * @instance
                 */
                Object.defineProperty(TaskNode.prototype, "reference", {
                    get: $util.oneOfGetter($oneOfFields = ["referenceId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new TaskNode instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskNode
                 * @static
                 * @param {nebulaidl.core.ITaskNode=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskNode} TaskNode instance
                 */
                TaskNode.create = function create(properties) {
                    return new TaskNode(properties);
                };
    
                /**
                 * Encodes the specified TaskNode message. Does not implicitly {@link nebulaidl.core.TaskNode.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskNode
                 * @static
                 * @param {nebulaidl.core.ITaskNode} message TaskNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.referenceId != null && message.hasOwnProperty("referenceId"))
                        $root.nebulaidl.core.Identifier.encode(message.referenceId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.overrides != null && message.hasOwnProperty("overrides"))
                        $root.nebulaidl.core.TaskNodeOverrides.encode(message.overrides, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskNode message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskNode} TaskNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.referenceId = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.overrides = $root.nebulaidl.core.TaskNodeOverrides.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskNode message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskNode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.referenceId != null && message.hasOwnProperty("referenceId")) {
                        properties.reference = 1;
                        {
                            var error = $root.nebulaidl.core.Identifier.verify(message.referenceId);
                            if (error)
                                return "referenceId." + error;
                        }
                    }
                    if (message.overrides != null && message.hasOwnProperty("overrides")) {
                        var error = $root.nebulaidl.core.TaskNodeOverrides.verify(message.overrides);
                        if (error)
                            return "overrides." + error;
                    }
                    return null;
                };
    
                return TaskNode;
            })();
    
            core.WorkflowNode = (function() {
    
                /**
                 * Properties of a WorkflowNode.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowNode
                 * @property {nebulaidl.core.IIdentifier|null} [launchplanRef] WorkflowNode launchplanRef
                 * @property {nebulaidl.core.IIdentifier|null} [subWorkflowRef] WorkflowNode subWorkflowRef
                 */
    
                /**
                 * Constructs a new WorkflowNode.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowNode.
                 * @implements IWorkflowNode
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowNode=} [properties] Properties to set
                 */
                function WorkflowNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowNode launchplanRef.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} launchplanRef
                 * @memberof nebulaidl.core.WorkflowNode
                 * @instance
                 */
                WorkflowNode.prototype.launchplanRef = null;
    
                /**
                 * WorkflowNode subWorkflowRef.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} subWorkflowRef
                 * @memberof nebulaidl.core.WorkflowNode
                 * @instance
                 */
                WorkflowNode.prototype.subWorkflowRef = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * WorkflowNode reference.
                 * @member {"launchplanRef"|"subWorkflowRef"|undefined} reference
                 * @memberof nebulaidl.core.WorkflowNode
                 * @instance
                 */
                Object.defineProperty(WorkflowNode.prototype, "reference", {
                    get: $util.oneOfGetter($oneOfFields = ["launchplanRef", "subWorkflowRef"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new WorkflowNode instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowNode
                 * @static
                 * @param {nebulaidl.core.IWorkflowNode=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowNode} WorkflowNode instance
                 */
                WorkflowNode.create = function create(properties) {
                    return new WorkflowNode(properties);
                };
    
                /**
                 * Encodes the specified WorkflowNode message. Does not implicitly {@link nebulaidl.core.WorkflowNode.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowNode
                 * @static
                 * @param {nebulaidl.core.IWorkflowNode} message WorkflowNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.launchplanRef != null && message.hasOwnProperty("launchplanRef"))
                        $root.nebulaidl.core.Identifier.encode(message.launchplanRef, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.subWorkflowRef != null && message.hasOwnProperty("subWorkflowRef"))
                        $root.nebulaidl.core.Identifier.encode(message.subWorkflowRef, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowNode message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowNode} WorkflowNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.launchplanRef = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.subWorkflowRef = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowNode message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowNode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.launchplanRef != null && message.hasOwnProperty("launchplanRef")) {
                        properties.reference = 1;
                        {
                            var error = $root.nebulaidl.core.Identifier.verify(message.launchplanRef);
                            if (error)
                                return "launchplanRef." + error;
                        }
                    }
                    if (message.subWorkflowRef != null && message.hasOwnProperty("subWorkflowRef")) {
                        if (properties.reference === 1)
                            return "reference: multiple values";
                        properties.reference = 1;
                        {
                            var error = $root.nebulaidl.core.Identifier.verify(message.subWorkflowRef);
                            if (error)
                                return "subWorkflowRef." + error;
                        }
                    }
                    return null;
                };
    
                return WorkflowNode;
            })();
    
            core.ApproveCondition = (function() {
    
                /**
                 * Properties of an ApproveCondition.
                 * @memberof nebulaidl.core
                 * @interface IApproveCondition
                 * @property {string|null} [signalId] ApproveCondition signalId
                 */
    
                /**
                 * Constructs a new ApproveCondition.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an ApproveCondition.
                 * @implements IApproveCondition
                 * @constructor
                 * @param {nebulaidl.core.IApproveCondition=} [properties] Properties to set
                 */
                function ApproveCondition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ApproveCondition signalId.
                 * @member {string} signalId
                 * @memberof nebulaidl.core.ApproveCondition
                 * @instance
                 */
                ApproveCondition.prototype.signalId = "";
    
                /**
                 * Creates a new ApproveCondition instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ApproveCondition
                 * @static
                 * @param {nebulaidl.core.IApproveCondition=} [properties] Properties to set
                 * @returns {nebulaidl.core.ApproveCondition} ApproveCondition instance
                 */
                ApproveCondition.create = function create(properties) {
                    return new ApproveCondition(properties);
                };
    
                /**
                 * Encodes the specified ApproveCondition message. Does not implicitly {@link nebulaidl.core.ApproveCondition.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ApproveCondition
                 * @static
                 * @param {nebulaidl.core.IApproveCondition} message ApproveCondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApproveCondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signalId != null && message.hasOwnProperty("signalId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalId);
                    return writer;
                };
    
                /**
                 * Decodes an ApproveCondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ApproveCondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ApproveCondition} ApproveCondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApproveCondition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ApproveCondition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.signalId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ApproveCondition message.
                 * @function verify
                 * @memberof nebulaidl.core.ApproveCondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ApproveCondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signalId != null && message.hasOwnProperty("signalId"))
                        if (!$util.isString(message.signalId))
                            return "signalId: string expected";
                    return null;
                };
    
                return ApproveCondition;
            })();
    
            core.SignalCondition = (function() {
    
                /**
                 * Properties of a SignalCondition.
                 * @memberof nebulaidl.core
                 * @interface ISignalCondition
                 * @property {string|null} [signalId] SignalCondition signalId
                 * @property {nebulaidl.core.ILiteralType|null} [type] SignalCondition type
                 * @property {string|null} [outputVariableName] SignalCondition outputVariableName
                 */
    
                /**
                 * Constructs a new SignalCondition.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a SignalCondition.
                 * @implements ISignalCondition
                 * @constructor
                 * @param {nebulaidl.core.ISignalCondition=} [properties] Properties to set
                 */
                function SignalCondition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SignalCondition signalId.
                 * @member {string} signalId
                 * @memberof nebulaidl.core.SignalCondition
                 * @instance
                 */
                SignalCondition.prototype.signalId = "";
    
                /**
                 * SignalCondition type.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} type
                 * @memberof nebulaidl.core.SignalCondition
                 * @instance
                 */
                SignalCondition.prototype.type = null;
    
                /**
                 * SignalCondition outputVariableName.
                 * @member {string} outputVariableName
                 * @memberof nebulaidl.core.SignalCondition
                 * @instance
                 */
                SignalCondition.prototype.outputVariableName = "";
    
                /**
                 * Creates a new SignalCondition instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.SignalCondition
                 * @static
                 * @param {nebulaidl.core.ISignalCondition=} [properties] Properties to set
                 * @returns {nebulaidl.core.SignalCondition} SignalCondition instance
                 */
                SignalCondition.create = function create(properties) {
                    return new SignalCondition(properties);
                };
    
                /**
                 * Encodes the specified SignalCondition message. Does not implicitly {@link nebulaidl.core.SignalCondition.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.SignalCondition
                 * @static
                 * @param {nebulaidl.core.ISignalCondition} message SignalCondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalCondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signalId != null && message.hasOwnProperty("signalId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalId);
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.LiteralType.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.outputVariableName != null && message.hasOwnProperty("outputVariableName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputVariableName);
                    return writer;
                };
    
                /**
                 * Decodes a SignalCondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.SignalCondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.SignalCondition} SignalCondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalCondition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.SignalCondition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.signalId = reader.string();
                            break;
                        case 2:
                            message.type = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.outputVariableName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalCondition message.
                 * @function verify
                 * @memberof nebulaidl.core.SignalCondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalCondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signalId != null && message.hasOwnProperty("signalId"))
                        if (!$util.isString(message.signalId))
                            return "signalId: string expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.LiteralType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    if (message.outputVariableName != null && message.hasOwnProperty("outputVariableName"))
                        if (!$util.isString(message.outputVariableName))
                            return "outputVariableName: string expected";
                    return null;
                };
    
                return SignalCondition;
            })();
    
            core.SleepCondition = (function() {
    
                /**
                 * Properties of a SleepCondition.
                 * @memberof nebulaidl.core
                 * @interface ISleepCondition
                 * @property {google.protobuf.IDuration|null} [duration] SleepCondition duration
                 */
    
                /**
                 * Constructs a new SleepCondition.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a SleepCondition.
                 * @implements ISleepCondition
                 * @constructor
                 * @param {nebulaidl.core.ISleepCondition=} [properties] Properties to set
                 */
                function SleepCondition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SleepCondition duration.
                 * @member {google.protobuf.IDuration|null|undefined} duration
                 * @memberof nebulaidl.core.SleepCondition
                 * @instance
                 */
                SleepCondition.prototype.duration = null;
    
                /**
                 * Creates a new SleepCondition instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.SleepCondition
                 * @static
                 * @param {nebulaidl.core.ISleepCondition=} [properties] Properties to set
                 * @returns {nebulaidl.core.SleepCondition} SleepCondition instance
                 */
                SleepCondition.create = function create(properties) {
                    return new SleepCondition(properties);
                };
    
                /**
                 * Encodes the specified SleepCondition message. Does not implicitly {@link nebulaidl.core.SleepCondition.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.SleepCondition
                 * @static
                 * @param {nebulaidl.core.ISleepCondition} message SleepCondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SleepCondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SleepCondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.SleepCondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.SleepCondition} SleepCondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SleepCondition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.SleepCondition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SleepCondition message.
                 * @function verify
                 * @memberof nebulaidl.core.SleepCondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SleepCondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    return null;
                };
    
                return SleepCondition;
            })();
    
            core.GateNode = (function() {
    
                /**
                 * Properties of a GateNode.
                 * @memberof nebulaidl.core
                 * @interface IGateNode
                 * @property {nebulaidl.core.IApproveCondition|null} [approve] GateNode approve
                 * @property {nebulaidl.core.ISignalCondition|null} [signal] GateNode signal
                 * @property {nebulaidl.core.ISleepCondition|null} [sleep] GateNode sleep
                 */
    
                /**
                 * Constructs a new GateNode.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a GateNode.
                 * @implements IGateNode
                 * @constructor
                 * @param {nebulaidl.core.IGateNode=} [properties] Properties to set
                 */
                function GateNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GateNode approve.
                 * @member {nebulaidl.core.IApproveCondition|null|undefined} approve
                 * @memberof nebulaidl.core.GateNode
                 * @instance
                 */
                GateNode.prototype.approve = null;
    
                /**
                 * GateNode signal.
                 * @member {nebulaidl.core.ISignalCondition|null|undefined} signal
                 * @memberof nebulaidl.core.GateNode
                 * @instance
                 */
                GateNode.prototype.signal = null;
    
                /**
                 * GateNode sleep.
                 * @member {nebulaidl.core.ISleepCondition|null|undefined} sleep
                 * @memberof nebulaidl.core.GateNode
                 * @instance
                 */
                GateNode.prototype.sleep = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * GateNode condition.
                 * @member {"approve"|"signal"|"sleep"|undefined} condition
                 * @memberof nebulaidl.core.GateNode
                 * @instance
                 */
                Object.defineProperty(GateNode.prototype, "condition", {
                    get: $util.oneOfGetter($oneOfFields = ["approve", "signal", "sleep"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new GateNode instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.GateNode
                 * @static
                 * @param {nebulaidl.core.IGateNode=} [properties] Properties to set
                 * @returns {nebulaidl.core.GateNode} GateNode instance
                 */
                GateNode.create = function create(properties) {
                    return new GateNode(properties);
                };
    
                /**
                 * Encodes the specified GateNode message. Does not implicitly {@link nebulaidl.core.GateNode.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.GateNode
                 * @static
                 * @param {nebulaidl.core.IGateNode} message GateNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GateNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.approve != null && message.hasOwnProperty("approve"))
                        $root.nebulaidl.core.ApproveCondition.encode(message.approve, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.signal != null && message.hasOwnProperty("signal"))
                        $root.nebulaidl.core.SignalCondition.encode(message.signal, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.sleep != null && message.hasOwnProperty("sleep"))
                        $root.nebulaidl.core.SleepCondition.encode(message.sleep, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GateNode message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.GateNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.GateNode} GateNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GateNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.GateNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.approve = $root.nebulaidl.core.ApproveCondition.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.signal = $root.nebulaidl.core.SignalCondition.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.sleep = $root.nebulaidl.core.SleepCondition.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GateNode message.
                 * @function verify
                 * @memberof nebulaidl.core.GateNode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GateNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.approve != null && message.hasOwnProperty("approve")) {
                        properties.condition = 1;
                        {
                            var error = $root.nebulaidl.core.ApproveCondition.verify(message.approve);
                            if (error)
                                return "approve." + error;
                        }
                    }
                    if (message.signal != null && message.hasOwnProperty("signal")) {
                        if (properties.condition === 1)
                            return "condition: multiple values";
                        properties.condition = 1;
                        {
                            var error = $root.nebulaidl.core.SignalCondition.verify(message.signal);
                            if (error)
                                return "signal." + error;
                        }
                    }
                    if (message.sleep != null && message.hasOwnProperty("sleep")) {
                        if (properties.condition === 1)
                            return "condition: multiple values";
                        properties.condition = 1;
                        {
                            var error = $root.nebulaidl.core.SleepCondition.verify(message.sleep);
                            if (error)
                                return "sleep." + error;
                        }
                    }
                    return null;
                };
    
                return GateNode;
            })();
    
            core.ArrayNode = (function() {
    
                /**
                 * Properties of an ArrayNode.
                 * @memberof nebulaidl.core
                 * @interface IArrayNode
                 * @property {nebulaidl.core.INode|null} [node] ArrayNode node
                 * @property {number|null} [parallelism] ArrayNode parallelism
                 * @property {number|null} [minSuccesses] ArrayNode minSuccesses
                 * @property {number|null} [minSuccessRatio] ArrayNode minSuccessRatio
                 */
    
                /**
                 * Constructs a new ArrayNode.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an ArrayNode.
                 * @implements IArrayNode
                 * @constructor
                 * @param {nebulaidl.core.IArrayNode=} [properties] Properties to set
                 */
                function ArrayNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ArrayNode node.
                 * @member {nebulaidl.core.INode|null|undefined} node
                 * @memberof nebulaidl.core.ArrayNode
                 * @instance
                 */
                ArrayNode.prototype.node = null;
    
                /**
                 * ArrayNode parallelism.
                 * @member {number} parallelism
                 * @memberof nebulaidl.core.ArrayNode
                 * @instance
                 */
                ArrayNode.prototype.parallelism = 0;
    
                /**
                 * ArrayNode minSuccesses.
                 * @member {number} minSuccesses
                 * @memberof nebulaidl.core.ArrayNode
                 * @instance
                 */
                ArrayNode.prototype.minSuccesses = 0;
    
                /**
                 * ArrayNode minSuccessRatio.
                 * @member {number} minSuccessRatio
                 * @memberof nebulaidl.core.ArrayNode
                 * @instance
                 */
                ArrayNode.prototype.minSuccessRatio = 0;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * ArrayNode successCriteria.
                 * @member {"minSuccesses"|"minSuccessRatio"|undefined} successCriteria
                 * @memberof nebulaidl.core.ArrayNode
                 * @instance
                 */
                Object.defineProperty(ArrayNode.prototype, "successCriteria", {
                    get: $util.oneOfGetter($oneOfFields = ["minSuccesses", "minSuccessRatio"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new ArrayNode instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ArrayNode
                 * @static
                 * @param {nebulaidl.core.IArrayNode=} [properties] Properties to set
                 * @returns {nebulaidl.core.ArrayNode} ArrayNode instance
                 */
                ArrayNode.create = function create(properties) {
                    return new ArrayNode(properties);
                };
    
                /**
                 * Encodes the specified ArrayNode message. Does not implicitly {@link nebulaidl.core.ArrayNode.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ArrayNode
                 * @static
                 * @param {nebulaidl.core.IArrayNode} message ArrayNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node != null && message.hasOwnProperty("node"))
                        $root.nebulaidl.core.Node.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.parallelism != null && message.hasOwnProperty("parallelism"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.parallelism);
                    if (message.minSuccesses != null && message.hasOwnProperty("minSuccesses"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.minSuccesses);
                    if (message.minSuccessRatio != null && message.hasOwnProperty("minSuccessRatio"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.minSuccessRatio);
                    return writer;
                };
    
                /**
                 * Decodes an ArrayNode message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ArrayNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ArrayNode} ArrayNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ArrayNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node = $root.nebulaidl.core.Node.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.parallelism = reader.uint32();
                            break;
                        case 3:
                            message.minSuccesses = reader.uint32();
                            break;
                        case 4:
                            message.minSuccessRatio = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ArrayNode message.
                 * @function verify
                 * @memberof nebulaidl.core.ArrayNode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArrayNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.node != null && message.hasOwnProperty("node")) {
                        var error = $root.nebulaidl.core.Node.verify(message.node);
                        if (error)
                            return "node." + error;
                    }
                    if (message.parallelism != null && message.hasOwnProperty("parallelism"))
                        if (!$util.isInteger(message.parallelism))
                            return "parallelism: integer expected";
                    if (message.minSuccesses != null && message.hasOwnProperty("minSuccesses")) {
                        properties.successCriteria = 1;
                        if (!$util.isInteger(message.minSuccesses))
                            return "minSuccesses: integer expected";
                    }
                    if (message.minSuccessRatio != null && message.hasOwnProperty("minSuccessRatio")) {
                        if (properties.successCriteria === 1)
                            return "successCriteria: multiple values";
                        properties.successCriteria = 1;
                        if (typeof message.minSuccessRatio !== "number")
                            return "minSuccessRatio: number expected";
                    }
                    return null;
                };
    
                return ArrayNode;
            })();
    
            core.NodeMetadata = (function() {
    
                /**
                 * Properties of a NodeMetadata.
                 * @memberof nebulaidl.core
                 * @interface INodeMetadata
                 * @property {string|null} [name] NodeMetadata name
                 * @property {google.protobuf.IDuration|null} [timeout] NodeMetadata timeout
                 * @property {nebulaidl.core.IRetryStrategy|null} [retries] NodeMetadata retries
                 * @property {boolean|null} [interruptible] NodeMetadata interruptible
                 */
    
                /**
                 * Constructs a new NodeMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a NodeMetadata.
                 * @implements INodeMetadata
                 * @constructor
                 * @param {nebulaidl.core.INodeMetadata=} [properties] Properties to set
                 */
                function NodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeMetadata name.
                 * @member {string} name
                 * @memberof nebulaidl.core.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.name = "";
    
                /**
                 * NodeMetadata timeout.
                 * @member {google.protobuf.IDuration|null|undefined} timeout
                 * @memberof nebulaidl.core.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.timeout = null;
    
                /**
                 * NodeMetadata retries.
                 * @member {nebulaidl.core.IRetryStrategy|null|undefined} retries
                 * @memberof nebulaidl.core.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.retries = null;
    
                /**
                 * NodeMetadata interruptible.
                 * @member {boolean} interruptible
                 * @memberof nebulaidl.core.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.interruptible = false;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * NodeMetadata interruptibleValue.
                 * @member {"interruptible"|undefined} interruptibleValue
                 * @memberof nebulaidl.core.NodeMetadata
                 * @instance
                 */
                Object.defineProperty(NodeMetadata.prototype, "interruptibleValue", {
                    get: $util.oneOfGetter($oneOfFields = ["interruptible"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.NodeMetadata
                 * @static
                 * @param {nebulaidl.core.INodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.NodeMetadata} NodeMetadata instance
                 */
                NodeMetadata.create = function create(properties) {
                    return new NodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified NodeMetadata message. Does not implicitly {@link nebulaidl.core.NodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.NodeMetadata
                 * @static
                 * @param {nebulaidl.core.INodeMetadata} message NodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.timeout != null && message.hasOwnProperty("timeout"))
                        $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.retries != null && message.hasOwnProperty("retries"))
                        $root.nebulaidl.core.RetryStrategy.encode(message.retries, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.interruptible);
                    return writer;
                };
    
                /**
                 * Decodes a NodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.NodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.NodeMetadata} NodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.NodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.retries = $root.nebulaidl.core.RetryStrategy.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.interruptible = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.NodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.timeout != null && message.hasOwnProperty("timeout")) {
                        var error = $root.google.protobuf.Duration.verify(message.timeout);
                        if (error)
                            return "timeout." + error;
                    }
                    if (message.retries != null && message.hasOwnProperty("retries")) {
                        var error = $root.nebulaidl.core.RetryStrategy.verify(message.retries);
                        if (error)
                            return "retries." + error;
                    }
                    if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                        properties.interruptibleValue = 1;
                        if (typeof message.interruptible !== "boolean")
                            return "interruptible: boolean expected";
                    }
                    return null;
                };
    
                return NodeMetadata;
            })();
    
            core.Alias = (function() {
    
                /**
                 * Properties of an Alias.
                 * @memberof nebulaidl.core
                 * @interface IAlias
                 * @property {string|null} ["var"] Alias var
                 * @property {string|null} [alias] Alias alias
                 */
    
                /**
                 * Constructs a new Alias.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an Alias.
                 * @implements IAlias
                 * @constructor
                 * @param {nebulaidl.core.IAlias=} [properties] Properties to set
                 */
                function Alias(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Alias var.
                 * @member {string} var
                 * @memberof nebulaidl.core.Alias
                 * @instance
                 */
                Alias.prototype["var"] = "";
    
                /**
                 * Alias alias.
                 * @member {string} alias
                 * @memberof nebulaidl.core.Alias
                 * @instance
                 */
                Alias.prototype.alias = "";
    
                /**
                 * Creates a new Alias instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Alias
                 * @static
                 * @param {nebulaidl.core.IAlias=} [properties] Properties to set
                 * @returns {nebulaidl.core.Alias} Alias instance
                 */
                Alias.create = function create(properties) {
                    return new Alias(properties);
                };
    
                /**
                 * Encodes the specified Alias message. Does not implicitly {@link nebulaidl.core.Alias.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Alias
                 * @static
                 * @param {nebulaidl.core.IAlias} message Alias message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Alias.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message["var"]);
                    if (message.alias != null && message.hasOwnProperty("alias"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
                    return writer;
                };
    
                /**
                 * Decodes an Alias message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Alias
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Alias} Alias
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Alias.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Alias();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["var"] = reader.string();
                            break;
                        case 2:
                            message.alias = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Alias message.
                 * @function verify
                 * @memberof nebulaidl.core.Alias
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Alias.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        if (!$util.isString(message["var"]))
                            return "var: string expected";
                    if (message.alias != null && message.hasOwnProperty("alias"))
                        if (!$util.isString(message.alias))
                            return "alias: string expected";
                    return null;
                };
    
                return Alias;
            })();
    
            core.Node = (function() {
    
                /**
                 * Properties of a Node.
                 * @memberof nebulaidl.core
                 * @interface INode
                 * @property {string|null} [id] Node id
                 * @property {nebulaidl.core.INodeMetadata|null} [metadata] Node metadata
                 * @property {Array.<nebulaidl.core.IBinding>|null} [inputs] Node inputs
                 * @property {Array.<string>|null} [upstreamNodeIds] Node upstreamNodeIds
                 * @property {Array.<nebulaidl.core.IAlias>|null} [outputAliases] Node outputAliases
                 * @property {nebulaidl.core.ITaskNode|null} [taskNode] Node taskNode
                 * @property {nebulaidl.core.IWorkflowNode|null} [workflowNode] Node workflowNode
                 * @property {nebulaidl.core.IBranchNode|null} [branchNode] Node branchNode
                 * @property {nebulaidl.core.IGateNode|null} [gateNode] Node gateNode
                 * @property {nebulaidl.core.IArrayNode|null} [arrayNode] Node arrayNode
                 */
    
                /**
                 * Constructs a new Node.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Node.
                 * @implements INode
                 * @constructor
                 * @param {nebulaidl.core.INode=} [properties] Properties to set
                 */
                function Node(properties) {
                    this.inputs = [];
                    this.upstreamNodeIds = [];
                    this.outputAliases = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Node id.
                 * @member {string} id
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.id = "";
    
                /**
                 * Node metadata.
                 * @member {nebulaidl.core.INodeMetadata|null|undefined} metadata
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.metadata = null;
    
                /**
                 * Node inputs.
                 * @member {Array.<nebulaidl.core.IBinding>} inputs
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.inputs = $util.emptyArray;
    
                /**
                 * Node upstreamNodeIds.
                 * @member {Array.<string>} upstreamNodeIds
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.upstreamNodeIds = $util.emptyArray;
    
                /**
                 * Node outputAliases.
                 * @member {Array.<nebulaidl.core.IAlias>} outputAliases
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.outputAliases = $util.emptyArray;
    
                /**
                 * Node taskNode.
                 * @member {nebulaidl.core.ITaskNode|null|undefined} taskNode
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.taskNode = null;
    
                /**
                 * Node workflowNode.
                 * @member {nebulaidl.core.IWorkflowNode|null|undefined} workflowNode
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.workflowNode = null;
    
                /**
                 * Node branchNode.
                 * @member {nebulaidl.core.IBranchNode|null|undefined} branchNode
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.branchNode = null;
    
                /**
                 * Node gateNode.
                 * @member {nebulaidl.core.IGateNode|null|undefined} gateNode
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.gateNode = null;
    
                /**
                 * Node arrayNode.
                 * @member {nebulaidl.core.IArrayNode|null|undefined} arrayNode
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Node.prototype.arrayNode = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Node target.
                 * @member {"taskNode"|"workflowNode"|"branchNode"|"gateNode"|"arrayNode"|undefined} target
                 * @memberof nebulaidl.core.Node
                 * @instance
                 */
                Object.defineProperty(Node.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["taskNode", "workflowNode", "branchNode", "gateNode", "arrayNode"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Node instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Node
                 * @static
                 * @param {nebulaidl.core.INode=} [properties] Properties to set
                 * @returns {nebulaidl.core.Node} Node instance
                 */
                Node.create = function create(properties) {
                    return new Node(properties);
                };
    
                /**
                 * Encodes the specified Node message. Does not implicitly {@link nebulaidl.core.Node.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Node
                 * @static
                 * @param {nebulaidl.core.INode} message Node message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Node.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.core.NodeMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.inputs != null && message.inputs.length)
                        for (var i = 0; i < message.inputs.length; ++i)
                            $root.nebulaidl.core.Binding.encode(message.inputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.upstreamNodeIds != null && message.upstreamNodeIds.length)
                        for (var i = 0; i < message.upstreamNodeIds.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.upstreamNodeIds[i]);
                    if (message.outputAliases != null && message.outputAliases.length)
                        for (var i = 0; i < message.outputAliases.length; ++i)
                            $root.nebulaidl.core.Alias.encode(message.outputAliases[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.taskNode != null && message.hasOwnProperty("taskNode"))
                        $root.nebulaidl.core.TaskNode.encode(message.taskNode, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.workflowNode != null && message.hasOwnProperty("workflowNode"))
                        $root.nebulaidl.core.WorkflowNode.encode(message.workflowNode, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.branchNode != null && message.hasOwnProperty("branchNode"))
                        $root.nebulaidl.core.BranchNode.encode(message.branchNode, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.gateNode != null && message.hasOwnProperty("gateNode"))
                        $root.nebulaidl.core.GateNode.encode(message.gateNode, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.arrayNode != null && message.hasOwnProperty("arrayNode"))
                        $root.nebulaidl.core.ArrayNode.encode(message.arrayNode, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Node message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Node
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Node} Node
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Node.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Node();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.metadata = $root.nebulaidl.core.NodeMetadata.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.inputs && message.inputs.length))
                                message.inputs = [];
                            message.inputs.push($root.nebulaidl.core.Binding.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.upstreamNodeIds && message.upstreamNodeIds.length))
                                message.upstreamNodeIds = [];
                            message.upstreamNodeIds.push(reader.string());
                            break;
                        case 5:
                            if (!(message.outputAliases && message.outputAliases.length))
                                message.outputAliases = [];
                            message.outputAliases.push($root.nebulaidl.core.Alias.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.taskNode = $root.nebulaidl.core.TaskNode.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.workflowNode = $root.nebulaidl.core.WorkflowNode.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.branchNode = $root.nebulaidl.core.BranchNode.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.gateNode = $root.nebulaidl.core.GateNode.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.arrayNode = $root.nebulaidl.core.ArrayNode.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Node message.
                 * @function verify
                 * @memberof nebulaidl.core.Node
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Node.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.core.NodeMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        if (!Array.isArray(message.inputs))
                            return "inputs: array expected";
                        for (var i = 0; i < message.inputs.length; ++i) {
                            var error = $root.nebulaidl.core.Binding.verify(message.inputs[i]);
                            if (error)
                                return "inputs." + error;
                        }
                    }
                    if (message.upstreamNodeIds != null && message.hasOwnProperty("upstreamNodeIds")) {
                        if (!Array.isArray(message.upstreamNodeIds))
                            return "upstreamNodeIds: array expected";
                        for (var i = 0; i < message.upstreamNodeIds.length; ++i)
                            if (!$util.isString(message.upstreamNodeIds[i]))
                                return "upstreamNodeIds: string[] expected";
                    }
                    if (message.outputAliases != null && message.hasOwnProperty("outputAliases")) {
                        if (!Array.isArray(message.outputAliases))
                            return "outputAliases: array expected";
                        for (var i = 0; i < message.outputAliases.length; ++i) {
                            var error = $root.nebulaidl.core.Alias.verify(message.outputAliases[i]);
                            if (error)
                                return "outputAliases." + error;
                        }
                    }
                    if (message.taskNode != null && message.hasOwnProperty("taskNode")) {
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.TaskNode.verify(message.taskNode);
                            if (error)
                                return "taskNode." + error;
                        }
                    }
                    if (message.workflowNode != null && message.hasOwnProperty("workflowNode")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.WorkflowNode.verify(message.workflowNode);
                            if (error)
                                return "workflowNode." + error;
                        }
                    }
                    if (message.branchNode != null && message.hasOwnProperty("branchNode")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.BranchNode.verify(message.branchNode);
                            if (error)
                                return "branchNode." + error;
                        }
                    }
                    if (message.gateNode != null && message.hasOwnProperty("gateNode")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.GateNode.verify(message.gateNode);
                            if (error)
                                return "gateNode." + error;
                        }
                    }
                    if (message.arrayNode != null && message.hasOwnProperty("arrayNode")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.ArrayNode.verify(message.arrayNode);
                            if (error)
                                return "arrayNode." + error;
                        }
                    }
                    return null;
                };
    
                return Node;
            })();
    
            core.WorkflowMetadata = (function() {
    
                /**
                 * Properties of a WorkflowMetadata.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowMetadata
                 * @property {nebulaidl.core.IQualityOfService|null} [qualityOfService] WorkflowMetadata qualityOfService
                 * @property {nebulaidl.core.WorkflowMetadata.OnFailurePolicy|null} [onFailure] WorkflowMetadata onFailure
                 * @property {Object.<string,string>|null} [tags] WorkflowMetadata tags
                 */
    
                /**
                 * Constructs a new WorkflowMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowMetadata.
                 * @implements IWorkflowMetadata
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowMetadata=} [properties] Properties to set
                 */
                function WorkflowMetadata(properties) {
                    this.tags = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowMetadata qualityOfService.
                 * @member {nebulaidl.core.IQualityOfService|null|undefined} qualityOfService
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @instance
                 */
                WorkflowMetadata.prototype.qualityOfService = null;
    
                /**
                 * WorkflowMetadata onFailure.
                 * @member {nebulaidl.core.WorkflowMetadata.OnFailurePolicy} onFailure
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @instance
                 */
                WorkflowMetadata.prototype.onFailure = 0;
    
                /**
                 * WorkflowMetadata tags.
                 * @member {Object.<string,string>} tags
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @instance
                 */
                WorkflowMetadata.prototype.tags = $util.emptyObject;
    
                /**
                 * Creates a new WorkflowMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @static
                 * @param {nebulaidl.core.IWorkflowMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowMetadata} WorkflowMetadata instance
                 */
                WorkflowMetadata.create = function create(properties) {
                    return new WorkflowMetadata(properties);
                };
    
                /**
                 * Encodes the specified WorkflowMetadata message. Does not implicitly {@link nebulaidl.core.WorkflowMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @static
                 * @param {nebulaidl.core.IWorkflowMetadata} message WorkflowMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService"))
                        $root.nebulaidl.core.QualityOfService.encode(message.qualityOfService, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.onFailure);
                    if (message.tags != null && message.hasOwnProperty("tags"))
                        for (var keys = Object.keys(message.tags), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.tags[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowMetadata} WorkflowMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowMetadata(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.qualityOfService = $root.nebulaidl.core.QualityOfService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.onFailure = reader.int32();
                            break;
                        case 3:
                            reader.skip().pos++;
                            if (message.tags === $util.emptyObject)
                                message.tags = {};
                            key = reader.string();
                            reader.pos++;
                            message.tags[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService")) {
                        var error = $root.nebulaidl.core.QualityOfService.verify(message.qualityOfService);
                        if (error)
                            return "qualityOfService." + error;
                    }
                    if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                        switch (message.onFailure) {
                        default:
                            return "onFailure: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!$util.isObject(message.tags))
                            return "tags: object expected";
                        var key = Object.keys(message.tags);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.tags[key[i]]))
                                return "tags: string{k:string} expected";
                    }
                    return null;
                };
    
                /**
                 * OnFailurePolicy enum.
                 * @name nebulaidl.core.WorkflowMetadata.OnFailurePolicy
                 * @enum {string}
                 * @property {number} FAIL_IMMEDIATELY=0 FAIL_IMMEDIATELY value
                 * @property {number} FAIL_AFTER_EXECUTABLE_NODES_COMPLETE=1 FAIL_AFTER_EXECUTABLE_NODES_COMPLETE value
                 */
                WorkflowMetadata.OnFailurePolicy = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "FAIL_IMMEDIATELY"] = 0;
                    values[valuesById[1] = "FAIL_AFTER_EXECUTABLE_NODES_COMPLETE"] = 1;
                    return values;
                })();
    
                return WorkflowMetadata;
            })();
    
            core.WorkflowMetadataDefaults = (function() {
    
                /**
                 * Properties of a WorkflowMetadataDefaults.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowMetadataDefaults
                 * @property {boolean|null} [interruptible] WorkflowMetadataDefaults interruptible
                 */
    
                /**
                 * Constructs a new WorkflowMetadataDefaults.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowMetadataDefaults.
                 * @implements IWorkflowMetadataDefaults
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowMetadataDefaults=} [properties] Properties to set
                 */
                function WorkflowMetadataDefaults(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowMetadataDefaults interruptible.
                 * @member {boolean} interruptible
                 * @memberof nebulaidl.core.WorkflowMetadataDefaults
                 * @instance
                 */
                WorkflowMetadataDefaults.prototype.interruptible = false;
    
                /**
                 * Creates a new WorkflowMetadataDefaults instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowMetadataDefaults
                 * @static
                 * @param {nebulaidl.core.IWorkflowMetadataDefaults=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowMetadataDefaults} WorkflowMetadataDefaults instance
                 */
                WorkflowMetadataDefaults.create = function create(properties) {
                    return new WorkflowMetadataDefaults(properties);
                };
    
                /**
                 * Encodes the specified WorkflowMetadataDefaults message. Does not implicitly {@link nebulaidl.core.WorkflowMetadataDefaults.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowMetadataDefaults
                 * @static
                 * @param {nebulaidl.core.IWorkflowMetadataDefaults} message WorkflowMetadataDefaults message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowMetadataDefaults.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.interruptible);
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowMetadataDefaults message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowMetadataDefaults
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowMetadataDefaults} WorkflowMetadataDefaults
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowMetadataDefaults.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowMetadataDefaults();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.interruptible = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowMetadataDefaults message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowMetadataDefaults
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowMetadataDefaults.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        if (typeof message.interruptible !== "boolean")
                            return "interruptible: boolean expected";
                    return null;
                };
    
                return WorkflowMetadataDefaults;
            })();
    
            core.WorkflowTemplate = (function() {
    
                /**
                 * Properties of a WorkflowTemplate.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowTemplate
                 * @property {nebulaidl.core.IIdentifier|null} [id] WorkflowTemplate id
                 * @property {nebulaidl.core.IWorkflowMetadata|null} [metadata] WorkflowTemplate metadata
                 * @property {nebulaidl.core.ITypedInterface|null} ["interface"] WorkflowTemplate interface
                 * @property {Array.<nebulaidl.core.INode>|null} [nodes] WorkflowTemplate nodes
                 * @property {Array.<nebulaidl.core.IBinding>|null} [outputs] WorkflowTemplate outputs
                 * @property {nebulaidl.core.INode|null} [failureNode] WorkflowTemplate failureNode
                 * @property {nebulaidl.core.IWorkflowMetadataDefaults|null} [metadataDefaults] WorkflowTemplate metadataDefaults
                 */
    
                /**
                 * Constructs a new WorkflowTemplate.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowTemplate.
                 * @implements IWorkflowTemplate
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowTemplate=} [properties] Properties to set
                 */
                function WorkflowTemplate(properties) {
                    this.nodes = [];
                    this.outputs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowTemplate id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype.id = null;
    
                /**
                 * WorkflowTemplate metadata.
                 * @member {nebulaidl.core.IWorkflowMetadata|null|undefined} metadata
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype.metadata = null;
    
                /**
                 * WorkflowTemplate interface.
                 * @member {nebulaidl.core.ITypedInterface|null|undefined} interface
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype["interface"] = null;
    
                /**
                 * WorkflowTemplate nodes.
                 * @member {Array.<nebulaidl.core.INode>} nodes
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype.nodes = $util.emptyArray;
    
                /**
                 * WorkflowTemplate outputs.
                 * @member {Array.<nebulaidl.core.IBinding>} outputs
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype.outputs = $util.emptyArray;
    
                /**
                 * WorkflowTemplate failureNode.
                 * @member {nebulaidl.core.INode|null|undefined} failureNode
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype.failureNode = null;
    
                /**
                 * WorkflowTemplate metadataDefaults.
                 * @member {nebulaidl.core.IWorkflowMetadataDefaults|null|undefined} metadataDefaults
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @instance
                 */
                WorkflowTemplate.prototype.metadataDefaults = null;
    
                /**
                 * Creates a new WorkflowTemplate instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @static
                 * @param {nebulaidl.core.IWorkflowTemplate=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowTemplate} WorkflowTemplate instance
                 */
                WorkflowTemplate.create = function create(properties) {
                    return new WorkflowTemplate(properties);
                };
    
                /**
                 * Encodes the specified WorkflowTemplate message. Does not implicitly {@link nebulaidl.core.WorkflowTemplate.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @static
                 * @param {nebulaidl.core.IWorkflowTemplate} message WorkflowTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowTemplate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.core.WorkflowMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message["interface"] != null && message.hasOwnProperty("interface"))
                        $root.nebulaidl.core.TypedInterface.encode(message["interface"], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.nodes != null && message.nodes.length)
                        for (var i = 0; i < message.nodes.length; ++i)
                            $root.nebulaidl.core.Node.encode(message.nodes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.outputs != null && message.outputs.length)
                        for (var i = 0; i < message.outputs.length; ++i)
                            $root.nebulaidl.core.Binding.encode(message.outputs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.failureNode != null && message.hasOwnProperty("failureNode"))
                        $root.nebulaidl.core.Node.encode(message.failureNode, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.metadataDefaults != null && message.hasOwnProperty("metadataDefaults"))
                        $root.nebulaidl.core.WorkflowMetadataDefaults.encode(message.metadataDefaults, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowTemplate message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowTemplate} WorkflowTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowTemplate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowTemplate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.metadata = $root.nebulaidl.core.WorkflowMetadata.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message["interface"] = $root.nebulaidl.core.TypedInterface.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.nebulaidl.core.Node.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.outputs && message.outputs.length))
                                message.outputs = [];
                            message.outputs.push($root.nebulaidl.core.Binding.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.failureNode = $root.nebulaidl.core.Node.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.metadataDefaults = $root.nebulaidl.core.WorkflowMetadataDefaults.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowTemplate message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowTemplate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowTemplate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.core.WorkflowMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message["interface"] != null && message.hasOwnProperty("interface")) {
                        var error = $root.nebulaidl.core.TypedInterface.verify(message["interface"]);
                        if (error)
                            return "interface." + error;
                    }
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (var i = 0; i < message.nodes.length; ++i) {
                            var error = $root.nebulaidl.core.Node.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        if (!Array.isArray(message.outputs))
                            return "outputs: array expected";
                        for (var i = 0; i < message.outputs.length; ++i) {
                            var error = $root.nebulaidl.core.Binding.verify(message.outputs[i]);
                            if (error)
                                return "outputs." + error;
                        }
                    }
                    if (message.failureNode != null && message.hasOwnProperty("failureNode")) {
                        var error = $root.nebulaidl.core.Node.verify(message.failureNode);
                        if (error)
                            return "failureNode." + error;
                    }
                    if (message.metadataDefaults != null && message.hasOwnProperty("metadataDefaults")) {
                        var error = $root.nebulaidl.core.WorkflowMetadataDefaults.verify(message.metadataDefaults);
                        if (error)
                            return "metadataDefaults." + error;
                    }
                    return null;
                };
    
                return WorkflowTemplate;
            })();
    
            core.TaskNodeOverrides = (function() {
    
                /**
                 * Properties of a TaskNodeOverrides.
                 * @memberof nebulaidl.core
                 * @interface ITaskNodeOverrides
                 * @property {nebulaidl.core.IResources|null} [resources] TaskNodeOverrides resources
                 */
    
                /**
                 * Constructs a new TaskNodeOverrides.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskNodeOverrides.
                 * @implements ITaskNodeOverrides
                 * @constructor
                 * @param {nebulaidl.core.ITaskNodeOverrides=} [properties] Properties to set
                 */
                function TaskNodeOverrides(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskNodeOverrides resources.
                 * @member {nebulaidl.core.IResources|null|undefined} resources
                 * @memberof nebulaidl.core.TaskNodeOverrides
                 * @instance
                 */
                TaskNodeOverrides.prototype.resources = null;
    
                /**
                 * Creates a new TaskNodeOverrides instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskNodeOverrides
                 * @static
                 * @param {nebulaidl.core.ITaskNodeOverrides=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskNodeOverrides} TaskNodeOverrides instance
                 */
                TaskNodeOverrides.create = function create(properties) {
                    return new TaskNodeOverrides(properties);
                };
    
                /**
                 * Encodes the specified TaskNodeOverrides message. Does not implicitly {@link nebulaidl.core.TaskNodeOverrides.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskNodeOverrides
                 * @static
                 * @param {nebulaidl.core.ITaskNodeOverrides} message TaskNodeOverrides message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskNodeOverrides.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resources != null && message.hasOwnProperty("resources"))
                        $root.nebulaidl.core.Resources.encode(message.resources, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskNodeOverrides message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskNodeOverrides
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskNodeOverrides} TaskNodeOverrides
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskNodeOverrides.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskNodeOverrides();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resources = $root.nebulaidl.core.Resources.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskNodeOverrides message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskNodeOverrides
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskNodeOverrides.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        var error = $root.nebulaidl.core.Resources.verify(message.resources);
                        if (error)
                            return "resources." + error;
                    }
                    return null;
                };
    
                return TaskNodeOverrides;
            })();
    
            core.ComparisonExpression = (function() {
    
                /**
                 * Properties of a ComparisonExpression.
                 * @memberof nebulaidl.core
                 * @interface IComparisonExpression
                 * @property {nebulaidl.core.ComparisonExpression.Operator|null} [operator] ComparisonExpression operator
                 * @property {nebulaidl.core.IOperand|null} [leftValue] ComparisonExpression leftValue
                 * @property {nebulaidl.core.IOperand|null} [rightValue] ComparisonExpression rightValue
                 */
    
                /**
                 * Constructs a new ComparisonExpression.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a ComparisonExpression.
                 * @implements IComparisonExpression
                 * @constructor
                 * @param {nebulaidl.core.IComparisonExpression=} [properties] Properties to set
                 */
                function ComparisonExpression(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ComparisonExpression operator.
                 * @member {nebulaidl.core.ComparisonExpression.Operator} operator
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @instance
                 */
                ComparisonExpression.prototype.operator = 0;
    
                /**
                 * ComparisonExpression leftValue.
                 * @member {nebulaidl.core.IOperand|null|undefined} leftValue
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @instance
                 */
                ComparisonExpression.prototype.leftValue = null;
    
                /**
                 * ComparisonExpression rightValue.
                 * @member {nebulaidl.core.IOperand|null|undefined} rightValue
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @instance
                 */
                ComparisonExpression.prototype.rightValue = null;
    
                /**
                 * Creates a new ComparisonExpression instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @static
                 * @param {nebulaidl.core.IComparisonExpression=} [properties] Properties to set
                 * @returns {nebulaidl.core.ComparisonExpression} ComparisonExpression instance
                 */
                ComparisonExpression.create = function create(properties) {
                    return new ComparisonExpression(properties);
                };
    
                /**
                 * Encodes the specified ComparisonExpression message. Does not implicitly {@link nebulaidl.core.ComparisonExpression.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @static
                 * @param {nebulaidl.core.IComparisonExpression} message ComparisonExpression message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ComparisonExpression.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operator);
                    if (message.leftValue != null && message.hasOwnProperty("leftValue"))
                        $root.nebulaidl.core.Operand.encode(message.leftValue, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rightValue != null && message.hasOwnProperty("rightValue"))
                        $root.nebulaidl.core.Operand.encode(message.rightValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ComparisonExpression message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ComparisonExpression} ComparisonExpression
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ComparisonExpression.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ComparisonExpression();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.operator = reader.int32();
                            break;
                        case 2:
                            message.leftValue = $root.nebulaidl.core.Operand.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rightValue = $root.nebulaidl.core.Operand.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ComparisonExpression message.
                 * @function verify
                 * @memberof nebulaidl.core.ComparisonExpression
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ComparisonExpression.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        switch (message.operator) {
                        default:
                            return "operator: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.leftValue != null && message.hasOwnProperty("leftValue")) {
                        var error = $root.nebulaidl.core.Operand.verify(message.leftValue);
                        if (error)
                            return "leftValue." + error;
                    }
                    if (message.rightValue != null && message.hasOwnProperty("rightValue")) {
                        var error = $root.nebulaidl.core.Operand.verify(message.rightValue);
                        if (error)
                            return "rightValue." + error;
                    }
                    return null;
                };
    
                /**
                 * Operator enum.
                 * @name nebulaidl.core.ComparisonExpression.Operator
                 * @enum {string}
                 * @property {number} EQ=0 EQ value
                 * @property {number} NEQ=1 NEQ value
                 * @property {number} GT=2 GT value
                 * @property {number} GTE=3 GTE value
                 * @property {number} LT=4 LT value
                 * @property {number} LTE=5 LTE value
                 */
                ComparisonExpression.Operator = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "EQ"] = 0;
                    values[valuesById[1] = "NEQ"] = 1;
                    values[valuesById[2] = "GT"] = 2;
                    values[valuesById[3] = "GTE"] = 3;
                    values[valuesById[4] = "LT"] = 4;
                    values[valuesById[5] = "LTE"] = 5;
                    return values;
                })();
    
                return ComparisonExpression;
            })();
    
            core.Operand = (function() {
    
                /**
                 * Properties of an Operand.
                 * @memberof nebulaidl.core
                 * @interface IOperand
                 * @property {nebulaidl.core.IPrimitive|null} [primitive] Operand primitive
                 * @property {string|null} ["var"] Operand var
                 * @property {nebulaidl.core.IScalar|null} [scalar] Operand scalar
                 */
    
                /**
                 * Constructs a new Operand.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an Operand.
                 * @implements IOperand
                 * @constructor
                 * @param {nebulaidl.core.IOperand=} [properties] Properties to set
                 */
                function Operand(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Operand primitive.
                 * @member {nebulaidl.core.IPrimitive|null|undefined} primitive
                 * @memberof nebulaidl.core.Operand
                 * @instance
                 */
                Operand.prototype.primitive = null;
    
                /**
                 * Operand var.
                 * @member {string} var
                 * @memberof nebulaidl.core.Operand
                 * @instance
                 */
                Operand.prototype["var"] = "";
    
                /**
                 * Operand scalar.
                 * @member {nebulaidl.core.IScalar|null|undefined} scalar
                 * @memberof nebulaidl.core.Operand
                 * @instance
                 */
                Operand.prototype.scalar = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Operand val.
                 * @member {"primitive"|"var"|"scalar"|undefined} val
                 * @memberof nebulaidl.core.Operand
                 * @instance
                 */
                Object.defineProperty(Operand.prototype, "val", {
                    get: $util.oneOfGetter($oneOfFields = ["primitive", "var", "scalar"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Operand instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Operand
                 * @static
                 * @param {nebulaidl.core.IOperand=} [properties] Properties to set
                 * @returns {nebulaidl.core.Operand} Operand instance
                 */
                Operand.create = function create(properties) {
                    return new Operand(properties);
                };
    
                /**
                 * Encodes the specified Operand message. Does not implicitly {@link nebulaidl.core.Operand.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Operand
                 * @static
                 * @param {nebulaidl.core.IOperand} message Operand message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Operand.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.primitive != null && message.hasOwnProperty("primitive"))
                        $root.nebulaidl.core.Primitive.encode(message.primitive, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["var"]);
                    if (message.scalar != null && message.hasOwnProperty("scalar"))
                        $root.nebulaidl.core.Scalar.encode(message.scalar, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an Operand message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Operand
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Operand} Operand
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Operand.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Operand();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.primitive = $root.nebulaidl.core.Primitive.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message["var"] = reader.string();
                            break;
                        case 3:
                            message.scalar = $root.nebulaidl.core.Scalar.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Operand message.
                 * @function verify
                 * @memberof nebulaidl.core.Operand
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Operand.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.primitive != null && message.hasOwnProperty("primitive")) {
                        properties.val = 1;
                        {
                            var error = $root.nebulaidl.core.Primitive.verify(message.primitive);
                            if (error)
                                return "primitive." + error;
                        }
                    }
                    if (message["var"] != null && message.hasOwnProperty("var")) {
                        if (properties.val === 1)
                            return "val: multiple values";
                        properties.val = 1;
                        if (!$util.isString(message["var"]))
                            return "var: string expected";
                    }
                    if (message.scalar != null && message.hasOwnProperty("scalar")) {
                        if (properties.val === 1)
                            return "val: multiple values";
                        properties.val = 1;
                        {
                            var error = $root.nebulaidl.core.Scalar.verify(message.scalar);
                            if (error)
                                return "scalar." + error;
                        }
                    }
                    return null;
                };
    
                return Operand;
            })();
    
            core.BooleanExpression = (function() {
    
                /**
                 * Properties of a BooleanExpression.
                 * @memberof nebulaidl.core
                 * @interface IBooleanExpression
                 * @property {nebulaidl.core.IConjunctionExpression|null} [conjunction] BooleanExpression conjunction
                 * @property {nebulaidl.core.IComparisonExpression|null} [comparison] BooleanExpression comparison
                 */
    
                /**
                 * Constructs a new BooleanExpression.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BooleanExpression.
                 * @implements IBooleanExpression
                 * @constructor
                 * @param {nebulaidl.core.IBooleanExpression=} [properties] Properties to set
                 */
                function BooleanExpression(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BooleanExpression conjunction.
                 * @member {nebulaidl.core.IConjunctionExpression|null|undefined} conjunction
                 * @memberof nebulaidl.core.BooleanExpression
                 * @instance
                 */
                BooleanExpression.prototype.conjunction = null;
    
                /**
                 * BooleanExpression comparison.
                 * @member {nebulaidl.core.IComparisonExpression|null|undefined} comparison
                 * @memberof nebulaidl.core.BooleanExpression
                 * @instance
                 */
                BooleanExpression.prototype.comparison = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * BooleanExpression expr.
                 * @member {"conjunction"|"comparison"|undefined} expr
                 * @memberof nebulaidl.core.BooleanExpression
                 * @instance
                 */
                Object.defineProperty(BooleanExpression.prototype, "expr", {
                    get: $util.oneOfGetter($oneOfFields = ["conjunction", "comparison"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new BooleanExpression instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BooleanExpression
                 * @static
                 * @param {nebulaidl.core.IBooleanExpression=} [properties] Properties to set
                 * @returns {nebulaidl.core.BooleanExpression} BooleanExpression instance
                 */
                BooleanExpression.create = function create(properties) {
                    return new BooleanExpression(properties);
                };
    
                /**
                 * Encodes the specified BooleanExpression message. Does not implicitly {@link nebulaidl.core.BooleanExpression.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BooleanExpression
                 * @static
                 * @param {nebulaidl.core.IBooleanExpression} message BooleanExpression message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BooleanExpression.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.conjunction != null && message.hasOwnProperty("conjunction"))
                        $root.nebulaidl.core.ConjunctionExpression.encode(message.conjunction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.comparison != null && message.hasOwnProperty("comparison"))
                        $root.nebulaidl.core.ComparisonExpression.encode(message.comparison, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a BooleanExpression message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BooleanExpression
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BooleanExpression} BooleanExpression
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BooleanExpression.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BooleanExpression();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.conjunction = $root.nebulaidl.core.ConjunctionExpression.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.comparison = $root.nebulaidl.core.ComparisonExpression.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BooleanExpression message.
                 * @function verify
                 * @memberof nebulaidl.core.BooleanExpression
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BooleanExpression.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.conjunction != null && message.hasOwnProperty("conjunction")) {
                        properties.expr = 1;
                        {
                            var error = $root.nebulaidl.core.ConjunctionExpression.verify(message.conjunction);
                            if (error)
                                return "conjunction." + error;
                        }
                    }
                    if (message.comparison != null && message.hasOwnProperty("comparison")) {
                        if (properties.expr === 1)
                            return "expr: multiple values";
                        properties.expr = 1;
                        {
                            var error = $root.nebulaidl.core.ComparisonExpression.verify(message.comparison);
                            if (error)
                                return "comparison." + error;
                        }
                    }
                    return null;
                };
    
                return BooleanExpression;
            })();
    
            core.ConjunctionExpression = (function() {
    
                /**
                 * Properties of a ConjunctionExpression.
                 * @memberof nebulaidl.core
                 * @interface IConjunctionExpression
                 * @property {nebulaidl.core.ConjunctionExpression.LogicalOperator|null} [operator] ConjunctionExpression operator
                 * @property {nebulaidl.core.IBooleanExpression|null} [leftExpression] ConjunctionExpression leftExpression
                 * @property {nebulaidl.core.IBooleanExpression|null} [rightExpression] ConjunctionExpression rightExpression
                 */
    
                /**
                 * Constructs a new ConjunctionExpression.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a ConjunctionExpression.
                 * @implements IConjunctionExpression
                 * @constructor
                 * @param {nebulaidl.core.IConjunctionExpression=} [properties] Properties to set
                 */
                function ConjunctionExpression(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConjunctionExpression operator.
                 * @member {nebulaidl.core.ConjunctionExpression.LogicalOperator} operator
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @instance
                 */
                ConjunctionExpression.prototype.operator = 0;
    
                /**
                 * ConjunctionExpression leftExpression.
                 * @member {nebulaidl.core.IBooleanExpression|null|undefined} leftExpression
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @instance
                 */
                ConjunctionExpression.prototype.leftExpression = null;
    
                /**
                 * ConjunctionExpression rightExpression.
                 * @member {nebulaidl.core.IBooleanExpression|null|undefined} rightExpression
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @instance
                 */
                ConjunctionExpression.prototype.rightExpression = null;
    
                /**
                 * Creates a new ConjunctionExpression instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @static
                 * @param {nebulaidl.core.IConjunctionExpression=} [properties] Properties to set
                 * @returns {nebulaidl.core.ConjunctionExpression} ConjunctionExpression instance
                 */
                ConjunctionExpression.create = function create(properties) {
                    return new ConjunctionExpression(properties);
                };
    
                /**
                 * Encodes the specified ConjunctionExpression message. Does not implicitly {@link nebulaidl.core.ConjunctionExpression.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @static
                 * @param {nebulaidl.core.IConjunctionExpression} message ConjunctionExpression message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConjunctionExpression.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operator);
                    if (message.leftExpression != null && message.hasOwnProperty("leftExpression"))
                        $root.nebulaidl.core.BooleanExpression.encode(message.leftExpression, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rightExpression != null && message.hasOwnProperty("rightExpression"))
                        $root.nebulaidl.core.BooleanExpression.encode(message.rightExpression, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ConjunctionExpression message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ConjunctionExpression} ConjunctionExpression
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConjunctionExpression.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ConjunctionExpression();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.operator = reader.int32();
                            break;
                        case 2:
                            message.leftExpression = $root.nebulaidl.core.BooleanExpression.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rightExpression = $root.nebulaidl.core.BooleanExpression.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ConjunctionExpression message.
                 * @function verify
                 * @memberof nebulaidl.core.ConjunctionExpression
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConjunctionExpression.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        switch (message.operator) {
                        default:
                            return "operator: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.leftExpression != null && message.hasOwnProperty("leftExpression")) {
                        var error = $root.nebulaidl.core.BooleanExpression.verify(message.leftExpression);
                        if (error)
                            return "leftExpression." + error;
                    }
                    if (message.rightExpression != null && message.hasOwnProperty("rightExpression")) {
                        var error = $root.nebulaidl.core.BooleanExpression.verify(message.rightExpression);
                        if (error)
                            return "rightExpression." + error;
                    }
                    return null;
                };
    
                /**
                 * LogicalOperator enum.
                 * @name nebulaidl.core.ConjunctionExpression.LogicalOperator
                 * @enum {string}
                 * @property {number} AND=0 AND value
                 * @property {number} OR=1 OR value
                 */
                ConjunctionExpression.LogicalOperator = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "AND"] = 0;
                    values[valuesById[1] = "OR"] = 1;
                    return values;
                })();
    
                return ConjunctionExpression;
            })();
    
            core.Primitive = (function() {
    
                /**
                 * Properties of a Primitive.
                 * @memberof nebulaidl.core
                 * @interface IPrimitive
                 * @property {Long|null} [integer] Primitive integer
                 * @property {number|null} [floatValue] Primitive floatValue
                 * @property {string|null} [stringValue] Primitive stringValue
                 * @property {boolean|null} [boolean] Primitive boolean
                 * @property {google.protobuf.ITimestamp|null} [datetime] Primitive datetime
                 * @property {google.protobuf.IDuration|null} [duration] Primitive duration
                 */
    
                /**
                 * Constructs a new Primitive.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Primitive.
                 * @implements IPrimitive
                 * @constructor
                 * @param {nebulaidl.core.IPrimitive=} [properties] Properties to set
                 */
                function Primitive(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Primitive integer.
                 * @member {Long} integer
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Primitive.prototype.integer = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Primitive floatValue.
                 * @member {number} floatValue
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Primitive.prototype.floatValue = 0;
    
                /**
                 * Primitive stringValue.
                 * @member {string} stringValue
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Primitive.prototype.stringValue = "";
    
                /**
                 * Primitive boolean.
                 * @member {boolean} boolean
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Primitive.prototype.boolean = false;
    
                /**
                 * Primitive datetime.
                 * @member {google.protobuf.ITimestamp|null|undefined} datetime
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Primitive.prototype.datetime = null;
    
                /**
                 * Primitive duration.
                 * @member {google.protobuf.IDuration|null|undefined} duration
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Primitive.prototype.duration = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Primitive value.
                 * @member {"integer"|"floatValue"|"stringValue"|"boolean"|"datetime"|"duration"|undefined} value
                 * @memberof nebulaidl.core.Primitive
                 * @instance
                 */
                Object.defineProperty(Primitive.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["integer", "floatValue", "stringValue", "boolean", "datetime", "duration"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Primitive instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Primitive
                 * @static
                 * @param {nebulaidl.core.IPrimitive=} [properties] Properties to set
                 * @returns {nebulaidl.core.Primitive} Primitive instance
                 */
                Primitive.create = function create(properties) {
                    return new Primitive(properties);
                };
    
                /**
                 * Encodes the specified Primitive message. Does not implicitly {@link nebulaidl.core.Primitive.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Primitive
                 * @static
                 * @param {nebulaidl.core.IPrimitive} message Primitive message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Primitive.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.integer != null && message.hasOwnProperty("integer"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.integer);
                    if (message.floatValue != null && message.hasOwnProperty("floatValue"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.floatValue);
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                    if (message.boolean != null && message.hasOwnProperty("boolean"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolean);
                    if (message.datetime != null && message.hasOwnProperty("datetime"))
                        $root.google.protobuf.Timestamp.encode(message.datetime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Primitive message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Primitive
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Primitive} Primitive
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Primitive.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Primitive();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.integer = reader.int64();
                            break;
                        case 2:
                            message.floatValue = reader.double();
                            break;
                        case 3:
                            message.stringValue = reader.string();
                            break;
                        case 4:
                            message.boolean = reader.bool();
                            break;
                        case 5:
                            message.datetime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Primitive message.
                 * @function verify
                 * @memberof nebulaidl.core.Primitive
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Primitive.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.integer != null && message.hasOwnProperty("integer")) {
                        properties.value = 1;
                        if (!$util.isInteger(message.integer) && !(message.integer && $util.isInteger(message.integer.low) && $util.isInteger(message.integer.high)))
                            return "integer: integer|Long expected";
                    }
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        if (typeof message.floatValue !== "number")
                            return "floatValue: number expected";
                    }
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    if (message.boolean != null && message.hasOwnProperty("boolean")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        if (typeof message.boolean !== "boolean")
                            return "boolean: boolean expected";
                    }
                    if (message.datetime != null && message.hasOwnProperty("datetime")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.google.protobuf.Timestamp.verify(message.datetime);
                            if (error)
                                return "datetime." + error;
                        }
                    }
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.google.protobuf.Duration.verify(message.duration);
                            if (error)
                                return "duration." + error;
                        }
                    }
                    return null;
                };
    
                return Primitive;
            })();
    
            core.Void = (function() {
    
                /**
                 * Properties of a Void.
                 * @memberof nebulaidl.core
                 * @interface IVoid
                 */
    
                /**
                 * Constructs a new Void.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Void.
                 * @implements IVoid
                 * @constructor
                 * @param {nebulaidl.core.IVoid=} [properties] Properties to set
                 */
                function Void(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Void instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Void
                 * @static
                 * @param {nebulaidl.core.IVoid=} [properties] Properties to set
                 * @returns {nebulaidl.core.Void} Void instance
                 */
                Void.create = function create(properties) {
                    return new Void(properties);
                };
    
                /**
                 * Encodes the specified Void message. Does not implicitly {@link nebulaidl.core.Void.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Void
                 * @static
                 * @param {nebulaidl.core.IVoid} message Void message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Void.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a Void message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Void
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Void} Void
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Void.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Void();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Void message.
                 * @function verify
                 * @memberof nebulaidl.core.Void
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Void.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return Void;
            })();
    
            core.Blob = (function() {
    
                /**
                 * Properties of a Blob.
                 * @memberof nebulaidl.core
                 * @interface IBlob
                 * @property {nebulaidl.core.IBlobMetadata|null} [metadata] Blob metadata
                 * @property {string|null} [uri] Blob uri
                 */
    
                /**
                 * Constructs a new Blob.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Blob.
                 * @implements IBlob
                 * @constructor
                 * @param {nebulaidl.core.IBlob=} [properties] Properties to set
                 */
                function Blob(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Blob metadata.
                 * @member {nebulaidl.core.IBlobMetadata|null|undefined} metadata
                 * @memberof nebulaidl.core.Blob
                 * @instance
                 */
                Blob.prototype.metadata = null;
    
                /**
                 * Blob uri.
                 * @member {string} uri
                 * @memberof nebulaidl.core.Blob
                 * @instance
                 */
                Blob.prototype.uri = "";
    
                /**
                 * Creates a new Blob instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Blob
                 * @static
                 * @param {nebulaidl.core.IBlob=} [properties] Properties to set
                 * @returns {nebulaidl.core.Blob} Blob instance
                 */
                Blob.create = function create(properties) {
                    return new Blob(properties);
                };
    
                /**
                 * Encodes the specified Blob message. Does not implicitly {@link nebulaidl.core.Blob.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Blob
                 * @static
                 * @param {nebulaidl.core.IBlob} message Blob message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Blob.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.core.BlobMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.uri);
                    return writer;
                };
    
                /**
                 * Decodes a Blob message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Blob
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Blob} Blob
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Blob.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Blob();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.metadata = $root.nebulaidl.core.BlobMetadata.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.uri = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Blob message.
                 * @function verify
                 * @memberof nebulaidl.core.Blob
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Blob.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.core.BlobMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    return null;
                };
    
                return Blob;
            })();
    
            core.BlobMetadata = (function() {
    
                /**
                 * Properties of a BlobMetadata.
                 * @memberof nebulaidl.core
                 * @interface IBlobMetadata
                 * @property {nebulaidl.core.IBlobType|null} [type] BlobMetadata type
                 */
    
                /**
                 * Constructs a new BlobMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BlobMetadata.
                 * @implements IBlobMetadata
                 * @constructor
                 * @param {nebulaidl.core.IBlobMetadata=} [properties] Properties to set
                 */
                function BlobMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BlobMetadata type.
                 * @member {nebulaidl.core.IBlobType|null|undefined} type
                 * @memberof nebulaidl.core.BlobMetadata
                 * @instance
                 */
                BlobMetadata.prototype.type = null;
    
                /**
                 * Creates a new BlobMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BlobMetadata
                 * @static
                 * @param {nebulaidl.core.IBlobMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.BlobMetadata} BlobMetadata instance
                 */
                BlobMetadata.create = function create(properties) {
                    return new BlobMetadata(properties);
                };
    
                /**
                 * Encodes the specified BlobMetadata message. Does not implicitly {@link nebulaidl.core.BlobMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BlobMetadata
                 * @static
                 * @param {nebulaidl.core.IBlobMetadata} message BlobMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlobMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.BlobType.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a BlobMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BlobMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BlobMetadata} BlobMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlobMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BlobMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = $root.nebulaidl.core.BlobType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BlobMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.BlobMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlobMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.BlobType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    return null;
                };
    
                return BlobMetadata;
            })();
    
            core.Binary = (function() {
    
                /**
                 * Properties of a Binary.
                 * @memberof nebulaidl.core
                 * @interface IBinary
                 * @property {Uint8Array|null} [value] Binary value
                 * @property {string|null} [tag] Binary tag
                 */
    
                /**
                 * Constructs a new Binary.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Binary.
                 * @implements IBinary
                 * @constructor
                 * @param {nebulaidl.core.IBinary=} [properties] Properties to set
                 */
                function Binary(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Binary value.
                 * @member {Uint8Array} value
                 * @memberof nebulaidl.core.Binary
                 * @instance
                 */
                Binary.prototype.value = $util.newBuffer([]);
    
                /**
                 * Binary tag.
                 * @member {string} tag
                 * @memberof nebulaidl.core.Binary
                 * @instance
                 */
                Binary.prototype.tag = "";
    
                /**
                 * Creates a new Binary instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Binary
                 * @static
                 * @param {nebulaidl.core.IBinary=} [properties] Properties to set
                 * @returns {nebulaidl.core.Binary} Binary instance
                 */
                Binary.create = function create(properties) {
                    return new Binary(properties);
                };
    
                /**
                 * Encodes the specified Binary message. Does not implicitly {@link nebulaidl.core.Binary.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Binary
                 * @static
                 * @param {nebulaidl.core.IBinary} message Binary message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Binary.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    if (message.tag != null && message.hasOwnProperty("tag"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.tag);
                    return writer;
                };
    
                /**
                 * Decodes a Binary message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Binary
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Binary} Binary
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Binary.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Binary();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        case 2:
                            message.tag = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Binary message.
                 * @function verify
                 * @memberof nebulaidl.core.Binary
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Binary.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    if (message.tag != null && message.hasOwnProperty("tag"))
                        if (!$util.isString(message.tag))
                            return "tag: string expected";
                    return null;
                };
    
                return Binary;
            })();
    
            core.Schema = (function() {
    
                /**
                 * Properties of a Schema.
                 * @memberof nebulaidl.core
                 * @interface ISchema
                 * @property {string|null} [uri] Schema uri
                 * @property {nebulaidl.core.ISchemaType|null} [type] Schema type
                 */
    
                /**
                 * Constructs a new Schema.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Schema.
                 * @implements ISchema
                 * @constructor
                 * @param {nebulaidl.core.ISchema=} [properties] Properties to set
                 */
                function Schema(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Schema uri.
                 * @member {string} uri
                 * @memberof nebulaidl.core.Schema
                 * @instance
                 */
                Schema.prototype.uri = "";
    
                /**
                 * Schema type.
                 * @member {nebulaidl.core.ISchemaType|null|undefined} type
                 * @memberof nebulaidl.core.Schema
                 * @instance
                 */
                Schema.prototype.type = null;
    
                /**
                 * Creates a new Schema instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Schema
                 * @static
                 * @param {nebulaidl.core.ISchema=} [properties] Properties to set
                 * @returns {nebulaidl.core.Schema} Schema instance
                 */
                Schema.create = function create(properties) {
                    return new Schema(properties);
                };
    
                /**
                 * Encodes the specified Schema message. Does not implicitly {@link nebulaidl.core.Schema.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Schema
                 * @static
                 * @param {nebulaidl.core.ISchema} message Schema message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Schema.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.SchemaType.encode(message.type, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Schema message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Schema
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Schema} Schema
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Schema.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Schema();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.type = $root.nebulaidl.core.SchemaType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Schema message.
                 * @function verify
                 * @memberof nebulaidl.core.Schema
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Schema.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.SchemaType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    return null;
                };
    
                return Schema;
            })();
    
            core.Union = (function() {
    
                /**
                 * Properties of an Union.
                 * @memberof nebulaidl.core
                 * @interface IUnion
                 * @property {nebulaidl.core.ILiteral|null} [value] Union value
                 * @property {nebulaidl.core.ILiteralType|null} [type] Union type
                 */
    
                /**
                 * Constructs a new Union.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an Union.
                 * @implements IUnion
                 * @constructor
                 * @param {nebulaidl.core.IUnion=} [properties] Properties to set
                 */
                function Union(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Union value.
                 * @member {nebulaidl.core.ILiteral|null|undefined} value
                 * @memberof nebulaidl.core.Union
                 * @instance
                 */
                Union.prototype.value = null;
    
                /**
                 * Union type.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} type
                 * @memberof nebulaidl.core.Union
                 * @instance
                 */
                Union.prototype.type = null;
    
                /**
                 * Creates a new Union instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Union
                 * @static
                 * @param {nebulaidl.core.IUnion=} [properties] Properties to set
                 * @returns {nebulaidl.core.Union} Union instance
                 */
                Union.create = function create(properties) {
                    return new Union(properties);
                };
    
                /**
                 * Encodes the specified Union message. Does not implicitly {@link nebulaidl.core.Union.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Union
                 * @static
                 * @param {nebulaidl.core.IUnion} message Union message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Union.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        $root.nebulaidl.core.Literal.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.LiteralType.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an Union message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Union
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Union} Union
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Union.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Union();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.nebulaidl.core.Literal.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.type = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Union message.
                 * @function verify
                 * @memberof nebulaidl.core.Union
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Union.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.nebulaidl.core.Literal.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.LiteralType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    return null;
                };
    
                return Union;
            })();
    
            core.StructuredDatasetMetadata = (function() {
    
                /**
                 * Properties of a StructuredDatasetMetadata.
                 * @memberof nebulaidl.core
                 * @interface IStructuredDatasetMetadata
                 * @property {nebulaidl.core.IStructuredDatasetType|null} [structuredDatasetType] StructuredDatasetMetadata structuredDatasetType
                 */
    
                /**
                 * Constructs a new StructuredDatasetMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a StructuredDatasetMetadata.
                 * @implements IStructuredDatasetMetadata
                 * @constructor
                 * @param {nebulaidl.core.IStructuredDatasetMetadata=} [properties] Properties to set
                 */
                function StructuredDatasetMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StructuredDatasetMetadata structuredDatasetType.
                 * @member {nebulaidl.core.IStructuredDatasetType|null|undefined} structuredDatasetType
                 * @memberof nebulaidl.core.StructuredDatasetMetadata
                 * @instance
                 */
                StructuredDatasetMetadata.prototype.structuredDatasetType = null;
    
                /**
                 * Creates a new StructuredDatasetMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.StructuredDatasetMetadata
                 * @static
                 * @param {nebulaidl.core.IStructuredDatasetMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.StructuredDatasetMetadata} StructuredDatasetMetadata instance
                 */
                StructuredDatasetMetadata.create = function create(properties) {
                    return new StructuredDatasetMetadata(properties);
                };
    
                /**
                 * Encodes the specified StructuredDatasetMetadata message. Does not implicitly {@link nebulaidl.core.StructuredDatasetMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.StructuredDatasetMetadata
                 * @static
                 * @param {nebulaidl.core.IStructuredDatasetMetadata} message StructuredDatasetMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StructuredDatasetMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.structuredDatasetType != null && message.hasOwnProperty("structuredDatasetType"))
                        $root.nebulaidl.core.StructuredDatasetType.encode(message.structuredDatasetType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a StructuredDatasetMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.StructuredDatasetMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.StructuredDatasetMetadata} StructuredDatasetMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StructuredDatasetMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.StructuredDatasetMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.structuredDatasetType = $root.nebulaidl.core.StructuredDatasetType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a StructuredDatasetMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.StructuredDatasetMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StructuredDatasetMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.structuredDatasetType != null && message.hasOwnProperty("structuredDatasetType")) {
                        var error = $root.nebulaidl.core.StructuredDatasetType.verify(message.structuredDatasetType);
                        if (error)
                            return "structuredDatasetType." + error;
                    }
                    return null;
                };
    
                return StructuredDatasetMetadata;
            })();
    
            core.StructuredDataset = (function() {
    
                /**
                 * Properties of a StructuredDataset.
                 * @memberof nebulaidl.core
                 * @interface IStructuredDataset
                 * @property {string|null} [uri] StructuredDataset uri
                 * @property {nebulaidl.core.IStructuredDatasetMetadata|null} [metadata] StructuredDataset metadata
                 */
    
                /**
                 * Constructs a new StructuredDataset.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a StructuredDataset.
                 * @implements IStructuredDataset
                 * @constructor
                 * @param {nebulaidl.core.IStructuredDataset=} [properties] Properties to set
                 */
                function StructuredDataset(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StructuredDataset uri.
                 * @member {string} uri
                 * @memberof nebulaidl.core.StructuredDataset
                 * @instance
                 */
                StructuredDataset.prototype.uri = "";
    
                /**
                 * StructuredDataset metadata.
                 * @member {nebulaidl.core.IStructuredDatasetMetadata|null|undefined} metadata
                 * @memberof nebulaidl.core.StructuredDataset
                 * @instance
                 */
                StructuredDataset.prototype.metadata = null;
    
                /**
                 * Creates a new StructuredDataset instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.StructuredDataset
                 * @static
                 * @param {nebulaidl.core.IStructuredDataset=} [properties] Properties to set
                 * @returns {nebulaidl.core.StructuredDataset} StructuredDataset instance
                 */
                StructuredDataset.create = function create(properties) {
                    return new StructuredDataset(properties);
                };
    
                /**
                 * Encodes the specified StructuredDataset message. Does not implicitly {@link nebulaidl.core.StructuredDataset.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.StructuredDataset
                 * @static
                 * @param {nebulaidl.core.IStructuredDataset} message StructuredDataset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StructuredDataset.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.core.StructuredDatasetMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a StructuredDataset message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.StructuredDataset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.StructuredDataset} StructuredDataset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StructuredDataset.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.StructuredDataset();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.metadata = $root.nebulaidl.core.StructuredDatasetMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a StructuredDataset message.
                 * @function verify
                 * @memberof nebulaidl.core.StructuredDataset
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StructuredDataset.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.core.StructuredDatasetMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                return StructuredDataset;
            })();
    
            core.Scalar = (function() {
    
                /**
                 * Properties of a Scalar.
                 * @memberof nebulaidl.core
                 * @interface IScalar
                 * @property {nebulaidl.core.IPrimitive|null} [primitive] Scalar primitive
                 * @property {nebulaidl.core.IBlob|null} [blob] Scalar blob
                 * @property {nebulaidl.core.IBinary|null} [binary] Scalar binary
                 * @property {nebulaidl.core.ISchema|null} [schema] Scalar schema
                 * @property {nebulaidl.core.IVoid|null} [noneType] Scalar noneType
                 * @property {nebulaidl.core.IError|null} [error] Scalar error
                 * @property {google.protobuf.IStruct|null} [generic] Scalar generic
                 * @property {nebulaidl.core.IStructuredDataset|null} [structuredDataset] Scalar structuredDataset
                 * @property {nebulaidl.core.IUnion|null} [union] Scalar union
                 */
    
                /**
                 * Constructs a new Scalar.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Scalar.
                 * @implements IScalar
                 * @constructor
                 * @param {nebulaidl.core.IScalar=} [properties] Properties to set
                 */
                function Scalar(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scalar primitive.
                 * @member {nebulaidl.core.IPrimitive|null|undefined} primitive
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.primitive = null;
    
                /**
                 * Scalar blob.
                 * @member {nebulaidl.core.IBlob|null|undefined} blob
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.blob = null;
    
                /**
                 * Scalar binary.
                 * @member {nebulaidl.core.IBinary|null|undefined} binary
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.binary = null;
    
                /**
                 * Scalar schema.
                 * @member {nebulaidl.core.ISchema|null|undefined} schema
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.schema = null;
    
                /**
                 * Scalar noneType.
                 * @member {nebulaidl.core.IVoid|null|undefined} noneType
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.noneType = null;
    
                /**
                 * Scalar error.
                 * @member {nebulaidl.core.IError|null|undefined} error
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.error = null;
    
                /**
                 * Scalar generic.
                 * @member {google.protobuf.IStruct|null|undefined} generic
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.generic = null;
    
                /**
                 * Scalar structuredDataset.
                 * @member {nebulaidl.core.IStructuredDataset|null|undefined} structuredDataset
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.structuredDataset = null;
    
                /**
                 * Scalar union.
                 * @member {nebulaidl.core.IUnion|null|undefined} union
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Scalar.prototype.union = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Scalar value.
                 * @member {"primitive"|"blob"|"binary"|"schema"|"noneType"|"error"|"generic"|"structuredDataset"|"union"|undefined} value
                 * @memberof nebulaidl.core.Scalar
                 * @instance
                 */
                Object.defineProperty(Scalar.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["primitive", "blob", "binary", "schema", "noneType", "error", "generic", "structuredDataset", "union"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Scalar instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Scalar
                 * @static
                 * @param {nebulaidl.core.IScalar=} [properties] Properties to set
                 * @returns {nebulaidl.core.Scalar} Scalar instance
                 */
                Scalar.create = function create(properties) {
                    return new Scalar(properties);
                };
    
                /**
                 * Encodes the specified Scalar message. Does not implicitly {@link nebulaidl.core.Scalar.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Scalar
                 * @static
                 * @param {nebulaidl.core.IScalar} message Scalar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Scalar.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.primitive != null && message.hasOwnProperty("primitive"))
                        $root.nebulaidl.core.Primitive.encode(message.primitive, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.blob != null && message.hasOwnProperty("blob"))
                        $root.nebulaidl.core.Blob.encode(message.blob, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.binary != null && message.hasOwnProperty("binary"))
                        $root.nebulaidl.core.Binary.encode(message.binary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.schema != null && message.hasOwnProperty("schema"))
                        $root.nebulaidl.core.Schema.encode(message.schema, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.noneType != null && message.hasOwnProperty("noneType"))
                        $root.nebulaidl.core.Void.encode(message.noneType, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.Error.encode(message.error, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.generic != null && message.hasOwnProperty("generic"))
                        $root.google.protobuf.Struct.encode(message.generic, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.structuredDataset != null && message.hasOwnProperty("structuredDataset"))
                        $root.nebulaidl.core.StructuredDataset.encode(message.structuredDataset, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.union != null && message.hasOwnProperty("union"))
                        $root.nebulaidl.core.Union.encode(message.union, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Scalar message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Scalar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Scalar} Scalar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Scalar.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Scalar();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.primitive = $root.nebulaidl.core.Primitive.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.blob = $root.nebulaidl.core.Blob.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.binary = $root.nebulaidl.core.Binary.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.schema = $root.nebulaidl.core.Schema.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.noneType = $root.nebulaidl.core.Void.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.error = $root.nebulaidl.core.Error.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.generic = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.structuredDataset = $root.nebulaidl.core.StructuredDataset.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.union = $root.nebulaidl.core.Union.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Scalar message.
                 * @function verify
                 * @memberof nebulaidl.core.Scalar
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Scalar.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.primitive != null && message.hasOwnProperty("primitive")) {
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Primitive.verify(message.primitive);
                            if (error)
                                return "primitive." + error;
                        }
                    }
                    if (message.blob != null && message.hasOwnProperty("blob")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Blob.verify(message.blob);
                            if (error)
                                return "blob." + error;
                        }
                    }
                    if (message.binary != null && message.hasOwnProperty("binary")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Binary.verify(message.binary);
                            if (error)
                                return "binary." + error;
                        }
                    }
                    if (message.schema != null && message.hasOwnProperty("schema")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Schema.verify(message.schema);
                            if (error)
                                return "schema." + error;
                        }
                    }
                    if (message.noneType != null && message.hasOwnProperty("noneType")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Void.verify(message.noneType);
                            if (error)
                                return "noneType." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.generic != null && message.hasOwnProperty("generic")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.google.protobuf.Struct.verify(message.generic);
                            if (error)
                                return "generic." + error;
                        }
                    }
                    if (message.structuredDataset != null && message.hasOwnProperty("structuredDataset")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.StructuredDataset.verify(message.structuredDataset);
                            if (error)
                                return "structuredDataset." + error;
                        }
                    }
                    if (message.union != null && message.hasOwnProperty("union")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Union.verify(message.union);
                            if (error)
                                return "union." + error;
                        }
                    }
                    return null;
                };
    
                return Scalar;
            })();
    
            core.Literal = (function() {
    
                /**
                 * Properties of a Literal.
                 * @memberof nebulaidl.core
                 * @interface ILiteral
                 * @property {nebulaidl.core.IScalar|null} [scalar] Literal scalar
                 * @property {nebulaidl.core.ILiteralCollection|null} [collection] Literal collection
                 * @property {nebulaidl.core.ILiteralMap|null} [map] Literal map
                 * @property {string|null} [hash] Literal hash
                 */
    
                /**
                 * Constructs a new Literal.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Literal.
                 * @implements ILiteral
                 * @constructor
                 * @param {nebulaidl.core.ILiteral=} [properties] Properties to set
                 */
                function Literal(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Literal scalar.
                 * @member {nebulaidl.core.IScalar|null|undefined} scalar
                 * @memberof nebulaidl.core.Literal
                 * @instance
                 */
                Literal.prototype.scalar = null;
    
                /**
                 * Literal collection.
                 * @member {nebulaidl.core.ILiteralCollection|null|undefined} collection
                 * @memberof nebulaidl.core.Literal
                 * @instance
                 */
                Literal.prototype.collection = null;
    
                /**
                 * Literal map.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} map
                 * @memberof nebulaidl.core.Literal
                 * @instance
                 */
                Literal.prototype.map = null;
    
                /**
                 * Literal hash.
                 * @member {string} hash
                 * @memberof nebulaidl.core.Literal
                 * @instance
                 */
                Literal.prototype.hash = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Literal value.
                 * @member {"scalar"|"collection"|"map"|undefined} value
                 * @memberof nebulaidl.core.Literal
                 * @instance
                 */
                Object.defineProperty(Literal.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["scalar", "collection", "map"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Literal instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Literal
                 * @static
                 * @param {nebulaidl.core.ILiteral=} [properties] Properties to set
                 * @returns {nebulaidl.core.Literal} Literal instance
                 */
                Literal.create = function create(properties) {
                    return new Literal(properties);
                };
    
                /**
                 * Encodes the specified Literal message. Does not implicitly {@link nebulaidl.core.Literal.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Literal
                 * @static
                 * @param {nebulaidl.core.ILiteral} message Literal message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Literal.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.scalar != null && message.hasOwnProperty("scalar"))
                        $root.nebulaidl.core.Scalar.encode(message.scalar, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        $root.nebulaidl.core.LiteralCollection.encode(message.collection, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.map != null && message.hasOwnProperty("map"))
                        $root.nebulaidl.core.LiteralMap.encode(message.map, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.hash);
                    return writer;
                };
    
                /**
                 * Decodes a Literal message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Literal
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Literal} Literal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Literal.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Literal();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.scalar = $root.nebulaidl.core.Scalar.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.collection = $root.nebulaidl.core.LiteralCollection.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.map = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.hash = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Literal message.
                 * @function verify
                 * @memberof nebulaidl.core.Literal
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Literal.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.scalar != null && message.hasOwnProperty("scalar")) {
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Scalar.verify(message.scalar);
                            if (error)
                                return "scalar." + error;
                        }
                    }
                    if (message.collection != null && message.hasOwnProperty("collection")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralCollection.verify(message.collection);
                            if (error)
                                return "collection." + error;
                        }
                    }
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.map);
                            if (error)
                                return "map." + error;
                        }
                    }
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!$util.isString(message.hash))
                            return "hash: string expected";
                    return null;
                };
    
                return Literal;
            })();
    
            core.LiteralCollection = (function() {
    
                /**
                 * Properties of a LiteralCollection.
                 * @memberof nebulaidl.core
                 * @interface ILiteralCollection
                 * @property {Array.<nebulaidl.core.ILiteral>|null} [literals] LiteralCollection literals
                 */
    
                /**
                 * Constructs a new LiteralCollection.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a LiteralCollection.
                 * @implements ILiteralCollection
                 * @constructor
                 * @param {nebulaidl.core.ILiteralCollection=} [properties] Properties to set
                 */
                function LiteralCollection(properties) {
                    this.literals = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LiteralCollection literals.
                 * @member {Array.<nebulaidl.core.ILiteral>} literals
                 * @memberof nebulaidl.core.LiteralCollection
                 * @instance
                 */
                LiteralCollection.prototype.literals = $util.emptyArray;
    
                /**
                 * Creates a new LiteralCollection instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.LiteralCollection
                 * @static
                 * @param {nebulaidl.core.ILiteralCollection=} [properties] Properties to set
                 * @returns {nebulaidl.core.LiteralCollection} LiteralCollection instance
                 */
                LiteralCollection.create = function create(properties) {
                    return new LiteralCollection(properties);
                };
    
                /**
                 * Encodes the specified LiteralCollection message. Does not implicitly {@link nebulaidl.core.LiteralCollection.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.LiteralCollection
                 * @static
                 * @param {nebulaidl.core.ILiteralCollection} message LiteralCollection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiteralCollection.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.literals != null && message.literals.length)
                        for (var i = 0; i < message.literals.length; ++i)
                            $root.nebulaidl.core.Literal.encode(message.literals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LiteralCollection message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.LiteralCollection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.LiteralCollection} LiteralCollection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiteralCollection.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.LiteralCollection();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.literals && message.literals.length))
                                message.literals = [];
                            message.literals.push($root.nebulaidl.core.Literal.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LiteralCollection message.
                 * @function verify
                 * @memberof nebulaidl.core.LiteralCollection
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LiteralCollection.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.literals != null && message.hasOwnProperty("literals")) {
                        if (!Array.isArray(message.literals))
                            return "literals: array expected";
                        for (var i = 0; i < message.literals.length; ++i) {
                            var error = $root.nebulaidl.core.Literal.verify(message.literals[i]);
                            if (error)
                                return "literals." + error;
                        }
                    }
                    return null;
                };
    
                return LiteralCollection;
            })();
    
            core.LiteralMap = (function() {
    
                /**
                 * Properties of a LiteralMap.
                 * @memberof nebulaidl.core
                 * @interface ILiteralMap
                 * @property {Object.<string,nebulaidl.core.ILiteral>|null} [literals] LiteralMap literals
                 */
    
                /**
                 * Constructs a new LiteralMap.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a LiteralMap.
                 * @implements ILiteralMap
                 * @constructor
                 * @param {nebulaidl.core.ILiteralMap=} [properties] Properties to set
                 */
                function LiteralMap(properties) {
                    this.literals = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LiteralMap literals.
                 * @member {Object.<string,nebulaidl.core.ILiteral>} literals
                 * @memberof nebulaidl.core.LiteralMap
                 * @instance
                 */
                LiteralMap.prototype.literals = $util.emptyObject;
    
                /**
                 * Creates a new LiteralMap instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.LiteralMap
                 * @static
                 * @param {nebulaidl.core.ILiteralMap=} [properties] Properties to set
                 * @returns {nebulaidl.core.LiteralMap} LiteralMap instance
                 */
                LiteralMap.create = function create(properties) {
                    return new LiteralMap(properties);
                };
    
                /**
                 * Encodes the specified LiteralMap message. Does not implicitly {@link nebulaidl.core.LiteralMap.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.LiteralMap
                 * @static
                 * @param {nebulaidl.core.ILiteralMap} message LiteralMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiteralMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.literals != null && message.hasOwnProperty("literals"))
                        for (var keys = Object.keys(message.literals), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.nebulaidl.core.Literal.encode(message.literals[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Decodes a LiteralMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.LiteralMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.LiteralMap} LiteralMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiteralMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.LiteralMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.literals === $util.emptyObject)
                                message.literals = {};
                            key = reader.string();
                            reader.pos++;
                            message.literals[key] = $root.nebulaidl.core.Literal.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LiteralMap message.
                 * @function verify
                 * @memberof nebulaidl.core.LiteralMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LiteralMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.literals != null && message.hasOwnProperty("literals")) {
                        if (!$util.isObject(message.literals))
                            return "literals: object expected";
                        var key = Object.keys(message.literals);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.nebulaidl.core.Literal.verify(message.literals[key[i]]);
                            if (error)
                                return "literals." + error;
                        }
                    }
                    return null;
                };
    
                return LiteralMap;
            })();
    
            core.BindingDataCollection = (function() {
    
                /**
                 * Properties of a BindingDataCollection.
                 * @memberof nebulaidl.core
                 * @interface IBindingDataCollection
                 * @property {Array.<nebulaidl.core.IBindingData>|null} [bindings] BindingDataCollection bindings
                 */
    
                /**
                 * Constructs a new BindingDataCollection.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BindingDataCollection.
                 * @implements IBindingDataCollection
                 * @constructor
                 * @param {nebulaidl.core.IBindingDataCollection=} [properties] Properties to set
                 */
                function BindingDataCollection(properties) {
                    this.bindings = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BindingDataCollection bindings.
                 * @member {Array.<nebulaidl.core.IBindingData>} bindings
                 * @memberof nebulaidl.core.BindingDataCollection
                 * @instance
                 */
                BindingDataCollection.prototype.bindings = $util.emptyArray;
    
                /**
                 * Creates a new BindingDataCollection instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BindingDataCollection
                 * @static
                 * @param {nebulaidl.core.IBindingDataCollection=} [properties] Properties to set
                 * @returns {nebulaidl.core.BindingDataCollection} BindingDataCollection instance
                 */
                BindingDataCollection.create = function create(properties) {
                    return new BindingDataCollection(properties);
                };
    
                /**
                 * Encodes the specified BindingDataCollection message. Does not implicitly {@link nebulaidl.core.BindingDataCollection.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BindingDataCollection
                 * @static
                 * @param {nebulaidl.core.IBindingDataCollection} message BindingDataCollection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BindingDataCollection.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bindings != null && message.bindings.length)
                        for (var i = 0; i < message.bindings.length; ++i)
                            $root.nebulaidl.core.BindingData.encode(message.bindings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a BindingDataCollection message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BindingDataCollection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BindingDataCollection} BindingDataCollection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BindingDataCollection.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BindingDataCollection();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.bindings && message.bindings.length))
                                message.bindings = [];
                            message.bindings.push($root.nebulaidl.core.BindingData.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BindingDataCollection message.
                 * @function verify
                 * @memberof nebulaidl.core.BindingDataCollection
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BindingDataCollection.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bindings != null && message.hasOwnProperty("bindings")) {
                        if (!Array.isArray(message.bindings))
                            return "bindings: array expected";
                        for (var i = 0; i < message.bindings.length; ++i) {
                            var error = $root.nebulaidl.core.BindingData.verify(message.bindings[i]);
                            if (error)
                                return "bindings." + error;
                        }
                    }
                    return null;
                };
    
                return BindingDataCollection;
            })();
    
            core.BindingDataMap = (function() {
    
                /**
                 * Properties of a BindingDataMap.
                 * @memberof nebulaidl.core
                 * @interface IBindingDataMap
                 * @property {Object.<string,nebulaidl.core.IBindingData>|null} [bindings] BindingDataMap bindings
                 */
    
                /**
                 * Constructs a new BindingDataMap.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BindingDataMap.
                 * @implements IBindingDataMap
                 * @constructor
                 * @param {nebulaidl.core.IBindingDataMap=} [properties] Properties to set
                 */
                function BindingDataMap(properties) {
                    this.bindings = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BindingDataMap bindings.
                 * @member {Object.<string,nebulaidl.core.IBindingData>} bindings
                 * @memberof nebulaidl.core.BindingDataMap
                 * @instance
                 */
                BindingDataMap.prototype.bindings = $util.emptyObject;
    
                /**
                 * Creates a new BindingDataMap instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BindingDataMap
                 * @static
                 * @param {nebulaidl.core.IBindingDataMap=} [properties] Properties to set
                 * @returns {nebulaidl.core.BindingDataMap} BindingDataMap instance
                 */
                BindingDataMap.create = function create(properties) {
                    return new BindingDataMap(properties);
                };
    
                /**
                 * Encodes the specified BindingDataMap message. Does not implicitly {@link nebulaidl.core.BindingDataMap.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BindingDataMap
                 * @static
                 * @param {nebulaidl.core.IBindingDataMap} message BindingDataMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BindingDataMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bindings != null && message.hasOwnProperty("bindings"))
                        for (var keys = Object.keys(message.bindings), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.nebulaidl.core.BindingData.encode(message.bindings[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Decodes a BindingDataMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BindingDataMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BindingDataMap} BindingDataMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BindingDataMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BindingDataMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.bindings === $util.emptyObject)
                                message.bindings = {};
                            key = reader.string();
                            reader.pos++;
                            message.bindings[key] = $root.nebulaidl.core.BindingData.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BindingDataMap message.
                 * @function verify
                 * @memberof nebulaidl.core.BindingDataMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BindingDataMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bindings != null && message.hasOwnProperty("bindings")) {
                        if (!$util.isObject(message.bindings))
                            return "bindings: object expected";
                        var key = Object.keys(message.bindings);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.nebulaidl.core.BindingData.verify(message.bindings[key[i]]);
                            if (error)
                                return "bindings." + error;
                        }
                    }
                    return null;
                };
    
                return BindingDataMap;
            })();
    
            core.UnionInfo = (function() {
    
                /**
                 * Properties of an UnionInfo.
                 * @memberof nebulaidl.core
                 * @interface IUnionInfo
                 * @property {nebulaidl.core.ILiteralType|null} [targetType] UnionInfo targetType
                 */
    
                /**
                 * Constructs a new UnionInfo.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an UnionInfo.
                 * @implements IUnionInfo
                 * @constructor
                 * @param {nebulaidl.core.IUnionInfo=} [properties] Properties to set
                 */
                function UnionInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UnionInfo targetType.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} targetType
                 * @memberof nebulaidl.core.UnionInfo
                 * @instance
                 */
                UnionInfo.prototype.targetType = null;
    
                /**
                 * Creates a new UnionInfo instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.UnionInfo
                 * @static
                 * @param {nebulaidl.core.IUnionInfo=} [properties] Properties to set
                 * @returns {nebulaidl.core.UnionInfo} UnionInfo instance
                 */
                UnionInfo.create = function create(properties) {
                    return new UnionInfo(properties);
                };
    
                /**
                 * Encodes the specified UnionInfo message. Does not implicitly {@link nebulaidl.core.UnionInfo.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.UnionInfo
                 * @static
                 * @param {nebulaidl.core.IUnionInfo} message UnionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnionInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetType != null && message.hasOwnProperty("targetType"))
                        $root.nebulaidl.core.LiteralType.encode(message.targetType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an UnionInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.UnionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.UnionInfo} UnionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnionInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.UnionInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.targetType = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an UnionInfo message.
                 * @function verify
                 * @memberof nebulaidl.core.UnionInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnionInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetType != null && message.hasOwnProperty("targetType")) {
                        var error = $root.nebulaidl.core.LiteralType.verify(message.targetType);
                        if (error)
                            return "targetType." + error;
                    }
                    return null;
                };
    
                return UnionInfo;
            })();
    
            core.BindingData = (function() {
    
                /**
                 * Properties of a BindingData.
                 * @memberof nebulaidl.core
                 * @interface IBindingData
                 * @property {nebulaidl.core.IScalar|null} [scalar] BindingData scalar
                 * @property {nebulaidl.core.IBindingDataCollection|null} [collection] BindingData collection
                 * @property {nebulaidl.core.IOutputReference|null} [promise] BindingData promise
                 * @property {nebulaidl.core.IBindingDataMap|null} [map] BindingData map
                 * @property {nebulaidl.core.IUnionInfo|null} [union] BindingData union
                 */
    
                /**
                 * Constructs a new BindingData.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BindingData.
                 * @implements IBindingData
                 * @constructor
                 * @param {nebulaidl.core.IBindingData=} [properties] Properties to set
                 */
                function BindingData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BindingData scalar.
                 * @member {nebulaidl.core.IScalar|null|undefined} scalar
                 * @memberof nebulaidl.core.BindingData
                 * @instance
                 */
                BindingData.prototype.scalar = null;
    
                /**
                 * BindingData collection.
                 * @member {nebulaidl.core.IBindingDataCollection|null|undefined} collection
                 * @memberof nebulaidl.core.BindingData
                 * @instance
                 */
                BindingData.prototype.collection = null;
    
                /**
                 * BindingData promise.
                 * @member {nebulaidl.core.IOutputReference|null|undefined} promise
                 * @memberof nebulaidl.core.BindingData
                 * @instance
                 */
                BindingData.prototype.promise = null;
    
                /**
                 * BindingData map.
                 * @member {nebulaidl.core.IBindingDataMap|null|undefined} map
                 * @memberof nebulaidl.core.BindingData
                 * @instance
                 */
                BindingData.prototype.map = null;
    
                /**
                 * BindingData union.
                 * @member {nebulaidl.core.IUnionInfo|null|undefined} union
                 * @memberof nebulaidl.core.BindingData
                 * @instance
                 */
                BindingData.prototype.union = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * BindingData value.
                 * @member {"scalar"|"collection"|"promise"|"map"|undefined} value
                 * @memberof nebulaidl.core.BindingData
                 * @instance
                 */
                Object.defineProperty(BindingData.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["scalar", "collection", "promise", "map"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new BindingData instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BindingData
                 * @static
                 * @param {nebulaidl.core.IBindingData=} [properties] Properties to set
                 * @returns {nebulaidl.core.BindingData} BindingData instance
                 */
                BindingData.create = function create(properties) {
                    return new BindingData(properties);
                };
    
                /**
                 * Encodes the specified BindingData message. Does not implicitly {@link nebulaidl.core.BindingData.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BindingData
                 * @static
                 * @param {nebulaidl.core.IBindingData} message BindingData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BindingData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.scalar != null && message.hasOwnProperty("scalar"))
                        $root.nebulaidl.core.Scalar.encode(message.scalar, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        $root.nebulaidl.core.BindingDataCollection.encode(message.collection, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.promise != null && message.hasOwnProperty("promise"))
                        $root.nebulaidl.core.OutputReference.encode(message.promise, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.map != null && message.hasOwnProperty("map"))
                        $root.nebulaidl.core.BindingDataMap.encode(message.map, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.union != null && message.hasOwnProperty("union"))
                        $root.nebulaidl.core.UnionInfo.encode(message.union, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a BindingData message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BindingData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BindingData} BindingData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BindingData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BindingData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.scalar = $root.nebulaidl.core.Scalar.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.collection = $root.nebulaidl.core.BindingDataCollection.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.promise = $root.nebulaidl.core.OutputReference.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.map = $root.nebulaidl.core.BindingDataMap.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.union = $root.nebulaidl.core.UnionInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BindingData message.
                 * @function verify
                 * @memberof nebulaidl.core.BindingData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BindingData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.scalar != null && message.hasOwnProperty("scalar")) {
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.Scalar.verify(message.scalar);
                            if (error)
                                return "scalar." + error;
                        }
                    }
                    if (message.collection != null && message.hasOwnProperty("collection")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.BindingDataCollection.verify(message.collection);
                            if (error)
                                return "collection." + error;
                        }
                    }
                    if (message.promise != null && message.hasOwnProperty("promise")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.OutputReference.verify(message.promise);
                            if (error)
                                return "promise." + error;
                        }
                    }
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.nebulaidl.core.BindingDataMap.verify(message.map);
                            if (error)
                                return "map." + error;
                        }
                    }
                    if (message.union != null && message.hasOwnProperty("union")) {
                        var error = $root.nebulaidl.core.UnionInfo.verify(message.union);
                        if (error)
                            return "union." + error;
                    }
                    return null;
                };
    
                return BindingData;
            })();
    
            core.Binding = (function() {
    
                /**
                 * Properties of a Binding.
                 * @memberof nebulaidl.core
                 * @interface IBinding
                 * @property {string|null} ["var"] Binding var
                 * @property {nebulaidl.core.IBindingData|null} [binding] Binding binding
                 */
    
                /**
                 * Constructs a new Binding.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Binding.
                 * @implements IBinding
                 * @constructor
                 * @param {nebulaidl.core.IBinding=} [properties] Properties to set
                 */
                function Binding(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Binding var.
                 * @member {string} var
                 * @memberof nebulaidl.core.Binding
                 * @instance
                 */
                Binding.prototype["var"] = "";
    
                /**
                 * Binding binding.
                 * @member {nebulaidl.core.IBindingData|null|undefined} binding
                 * @memberof nebulaidl.core.Binding
                 * @instance
                 */
                Binding.prototype.binding = null;
    
                /**
                 * Creates a new Binding instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Binding
                 * @static
                 * @param {nebulaidl.core.IBinding=} [properties] Properties to set
                 * @returns {nebulaidl.core.Binding} Binding instance
                 */
                Binding.create = function create(properties) {
                    return new Binding(properties);
                };
    
                /**
                 * Encodes the specified Binding message. Does not implicitly {@link nebulaidl.core.Binding.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Binding
                 * @static
                 * @param {nebulaidl.core.IBinding} message Binding message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Binding.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message["var"]);
                    if (message.binding != null && message.hasOwnProperty("binding"))
                        $root.nebulaidl.core.BindingData.encode(message.binding, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Binding message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Binding
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Binding} Binding
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Binding.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Binding();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["var"] = reader.string();
                            break;
                        case 2:
                            message.binding = $root.nebulaidl.core.BindingData.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Binding message.
                 * @function verify
                 * @memberof nebulaidl.core.Binding
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Binding.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        if (!$util.isString(message["var"]))
                            return "var: string expected";
                    if (message.binding != null && message.hasOwnProperty("binding")) {
                        var error = $root.nebulaidl.core.BindingData.verify(message.binding);
                        if (error)
                            return "binding." + error;
                    }
                    return null;
                };
    
                return Binding;
            })();
    
            core.KeyValuePair = (function() {
    
                /**
                 * Properties of a KeyValuePair.
                 * @memberof nebulaidl.core
                 * @interface IKeyValuePair
                 * @property {string|null} [key] KeyValuePair key
                 * @property {string|null} [value] KeyValuePair value
                 */
    
                /**
                 * Constructs a new KeyValuePair.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a KeyValuePair.
                 * @implements IKeyValuePair
                 * @constructor
                 * @param {nebulaidl.core.IKeyValuePair=} [properties] Properties to set
                 */
                function KeyValuePair(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * KeyValuePair key.
                 * @member {string} key
                 * @memberof nebulaidl.core.KeyValuePair
                 * @instance
                 */
                KeyValuePair.prototype.key = "";
    
                /**
                 * KeyValuePair value.
                 * @member {string} value
                 * @memberof nebulaidl.core.KeyValuePair
                 * @instance
                 */
                KeyValuePair.prototype.value = "";
    
                /**
                 * Creates a new KeyValuePair instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.KeyValuePair
                 * @static
                 * @param {nebulaidl.core.IKeyValuePair=} [properties] Properties to set
                 * @returns {nebulaidl.core.KeyValuePair} KeyValuePair instance
                 */
                KeyValuePair.create = function create(properties) {
                    return new KeyValuePair(properties);
                };
    
                /**
                 * Encodes the specified KeyValuePair message. Does not implicitly {@link nebulaidl.core.KeyValuePair.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.KeyValuePair
                 * @static
                 * @param {nebulaidl.core.IKeyValuePair} message KeyValuePair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyValuePair.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && message.hasOwnProperty("key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a KeyValuePair message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.KeyValuePair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.KeyValuePair} KeyValuePair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyValuePair.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.KeyValuePair();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a KeyValuePair message.
                 * @function verify
                 * @memberof nebulaidl.core.KeyValuePair
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeyValuePair.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
    
                return KeyValuePair;
            })();
    
            core.RetryStrategy = (function() {
    
                /**
                 * Properties of a RetryStrategy.
                 * @memberof nebulaidl.core
                 * @interface IRetryStrategy
                 * @property {number|null} [retries] RetryStrategy retries
                 */
    
                /**
                 * Constructs a new RetryStrategy.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a RetryStrategy.
                 * @implements IRetryStrategy
                 * @constructor
                 * @param {nebulaidl.core.IRetryStrategy=} [properties] Properties to set
                 */
                function RetryStrategy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RetryStrategy retries.
                 * @member {number} retries
                 * @memberof nebulaidl.core.RetryStrategy
                 * @instance
                 */
                RetryStrategy.prototype.retries = 0;
    
                /**
                 * Creates a new RetryStrategy instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.RetryStrategy
                 * @static
                 * @param {nebulaidl.core.IRetryStrategy=} [properties] Properties to set
                 * @returns {nebulaidl.core.RetryStrategy} RetryStrategy instance
                 */
                RetryStrategy.create = function create(properties) {
                    return new RetryStrategy(properties);
                };
    
                /**
                 * Encodes the specified RetryStrategy message. Does not implicitly {@link nebulaidl.core.RetryStrategy.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.RetryStrategy
                 * @static
                 * @param {nebulaidl.core.IRetryStrategy} message RetryStrategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RetryStrategy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.retries != null && message.hasOwnProperty("retries"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.retries);
                    return writer;
                };
    
                /**
                 * Decodes a RetryStrategy message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.RetryStrategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.RetryStrategy} RetryStrategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RetryStrategy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.RetryStrategy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 5:
                            message.retries = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a RetryStrategy message.
                 * @function verify
                 * @memberof nebulaidl.core.RetryStrategy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RetryStrategy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.retries != null && message.hasOwnProperty("retries"))
                        if (!$util.isInteger(message.retries))
                            return "retries: integer expected";
                    return null;
                };
    
                return RetryStrategy;
            })();
    
            /**
             * SimpleType enum.
             * @name nebulaidl.core.SimpleType
             * @enum {string}
             * @property {number} NONE=0 NONE value
             * @property {number} INTEGER=1 INTEGER value
             * @property {number} FLOAT=2 FLOAT value
             * @property {number} STRING=3 STRING value
             * @property {number} BOOLEAN=4 BOOLEAN value
             * @property {number} DATETIME=5 DATETIME value
             * @property {number} DURATION=6 DURATION value
             * @property {number} BINARY=7 BINARY value
             * @property {number} ERROR=8 ERROR value
             * @property {number} STRUCT=9 STRUCT value
             */
            core.SimpleType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "INTEGER"] = 1;
                values[valuesById[2] = "FLOAT"] = 2;
                values[valuesById[3] = "STRING"] = 3;
                values[valuesById[4] = "BOOLEAN"] = 4;
                values[valuesById[5] = "DATETIME"] = 5;
                values[valuesById[6] = "DURATION"] = 6;
                values[valuesById[7] = "BINARY"] = 7;
                values[valuesById[8] = "ERROR"] = 8;
                values[valuesById[9] = "STRUCT"] = 9;
                return values;
            })();
    
            core.SchemaType = (function() {
    
                /**
                 * Properties of a SchemaType.
                 * @memberof nebulaidl.core
                 * @interface ISchemaType
                 * @property {Array.<nebulaidl.core.SchemaType.ISchemaColumn>|null} [columns] SchemaType columns
                 */
    
                /**
                 * Constructs a new SchemaType.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a SchemaType.
                 * @implements ISchemaType
                 * @constructor
                 * @param {nebulaidl.core.ISchemaType=} [properties] Properties to set
                 */
                function SchemaType(properties) {
                    this.columns = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SchemaType columns.
                 * @member {Array.<nebulaidl.core.SchemaType.ISchemaColumn>} columns
                 * @memberof nebulaidl.core.SchemaType
                 * @instance
                 */
                SchemaType.prototype.columns = $util.emptyArray;
    
                /**
                 * Creates a new SchemaType instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.SchemaType
                 * @static
                 * @param {nebulaidl.core.ISchemaType=} [properties] Properties to set
                 * @returns {nebulaidl.core.SchemaType} SchemaType instance
                 */
                SchemaType.create = function create(properties) {
                    return new SchemaType(properties);
                };
    
                /**
                 * Encodes the specified SchemaType message. Does not implicitly {@link nebulaidl.core.SchemaType.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.SchemaType
                 * @static
                 * @param {nebulaidl.core.ISchemaType} message SchemaType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SchemaType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.columns != null && message.columns.length)
                        for (var i = 0; i < message.columns.length; ++i)
                            $root.nebulaidl.core.SchemaType.SchemaColumn.encode(message.columns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SchemaType message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.SchemaType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.SchemaType} SchemaType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SchemaType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.SchemaType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3:
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.nebulaidl.core.SchemaType.SchemaColumn.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SchemaType message.
                 * @function verify
                 * @memberof nebulaidl.core.SchemaType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SchemaType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.columns != null && message.hasOwnProperty("columns")) {
                        if (!Array.isArray(message.columns))
                            return "columns: array expected";
                        for (var i = 0; i < message.columns.length; ++i) {
                            var error = $root.nebulaidl.core.SchemaType.SchemaColumn.verify(message.columns[i]);
                            if (error)
                                return "columns." + error;
                        }
                    }
                    return null;
                };
    
                SchemaType.SchemaColumn = (function() {
    
                    /**
                     * Properties of a SchemaColumn.
                     * @memberof nebulaidl.core.SchemaType
                     * @interface ISchemaColumn
                     * @property {string|null} [name] SchemaColumn name
                     * @property {nebulaidl.core.SchemaType.SchemaColumn.SchemaColumnType|null} [type] SchemaColumn type
                     */
    
                    /**
                     * Constructs a new SchemaColumn.
                     * @memberof nebulaidl.core.SchemaType
                     * @classdesc Represents a SchemaColumn.
                     * @implements ISchemaColumn
                     * @constructor
                     * @param {nebulaidl.core.SchemaType.ISchemaColumn=} [properties] Properties to set
                     */
                    function SchemaColumn(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SchemaColumn name.
                     * @member {string} name
                     * @memberof nebulaidl.core.SchemaType.SchemaColumn
                     * @instance
                     */
                    SchemaColumn.prototype.name = "";
    
                    /**
                     * SchemaColumn type.
                     * @member {nebulaidl.core.SchemaType.SchemaColumn.SchemaColumnType} type
                     * @memberof nebulaidl.core.SchemaType.SchemaColumn
                     * @instance
                     */
                    SchemaColumn.prototype.type = 0;
    
                    /**
                     * Creates a new SchemaColumn instance using the specified properties.
                     * @function create
                     * @memberof nebulaidl.core.SchemaType.SchemaColumn
                     * @static
                     * @param {nebulaidl.core.SchemaType.ISchemaColumn=} [properties] Properties to set
                     * @returns {nebulaidl.core.SchemaType.SchemaColumn} SchemaColumn instance
                     */
                    SchemaColumn.create = function create(properties) {
                        return new SchemaColumn(properties);
                    };
    
                    /**
                     * Encodes the specified SchemaColumn message. Does not implicitly {@link nebulaidl.core.SchemaType.SchemaColumn.verify|verify} messages.
                     * @function encode
                     * @memberof nebulaidl.core.SchemaType.SchemaColumn
                     * @static
                     * @param {nebulaidl.core.SchemaType.ISchemaColumn} message SchemaColumn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SchemaColumn.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                        return writer;
                    };
    
                    /**
                     * Decodes a SchemaColumn message from the specified reader or buffer.
                     * @function decode
                     * @memberof nebulaidl.core.SchemaType.SchemaColumn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {nebulaidl.core.SchemaType.SchemaColumn} SchemaColumn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SchemaColumn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.SchemaType.SchemaColumn();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.type = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SchemaColumn message.
                     * @function verify
                     * @memberof nebulaidl.core.SchemaType.SchemaColumn
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SchemaColumn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * SchemaColumnType enum.
                     * @name nebulaidl.core.SchemaType.SchemaColumn.SchemaColumnType
                     * @enum {string}
                     * @property {number} INTEGER=0 INTEGER value
                     * @property {number} FLOAT=1 FLOAT value
                     * @property {number} STRING=2 STRING value
                     * @property {number} BOOLEAN=3 BOOLEAN value
                     * @property {number} DATETIME=4 DATETIME value
                     * @property {number} DURATION=5 DURATION value
                     */
                    SchemaColumn.SchemaColumnType = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "INTEGER"] = 0;
                        values[valuesById[1] = "FLOAT"] = 1;
                        values[valuesById[2] = "STRING"] = 2;
                        values[valuesById[3] = "BOOLEAN"] = 3;
                        values[valuesById[4] = "DATETIME"] = 4;
                        values[valuesById[5] = "DURATION"] = 5;
                        return values;
                    })();
    
                    return SchemaColumn;
                })();
    
                return SchemaType;
            })();
    
            core.StructuredDatasetType = (function() {
    
                /**
                 * Properties of a StructuredDatasetType.
                 * @memberof nebulaidl.core
                 * @interface IStructuredDatasetType
                 * @property {Array.<nebulaidl.core.StructuredDatasetType.IDatasetColumn>|null} [columns] StructuredDatasetType columns
                 * @property {string|null} [format] StructuredDatasetType format
                 * @property {string|null} [externalSchemaType] StructuredDatasetType externalSchemaType
                 * @property {Uint8Array|null} [externalSchemaBytes] StructuredDatasetType externalSchemaBytes
                 */
    
                /**
                 * Constructs a new StructuredDatasetType.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a StructuredDatasetType.
                 * @implements IStructuredDatasetType
                 * @constructor
                 * @param {nebulaidl.core.IStructuredDatasetType=} [properties] Properties to set
                 */
                function StructuredDatasetType(properties) {
                    this.columns = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StructuredDatasetType columns.
                 * @member {Array.<nebulaidl.core.StructuredDatasetType.IDatasetColumn>} columns
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @instance
                 */
                StructuredDatasetType.prototype.columns = $util.emptyArray;
    
                /**
                 * StructuredDatasetType format.
                 * @member {string} format
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @instance
                 */
                StructuredDatasetType.prototype.format = "";
    
                /**
                 * StructuredDatasetType externalSchemaType.
                 * @member {string} externalSchemaType
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @instance
                 */
                StructuredDatasetType.prototype.externalSchemaType = "";
    
                /**
                 * StructuredDatasetType externalSchemaBytes.
                 * @member {Uint8Array} externalSchemaBytes
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @instance
                 */
                StructuredDatasetType.prototype.externalSchemaBytes = $util.newBuffer([]);
    
                /**
                 * Creates a new StructuredDatasetType instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @static
                 * @param {nebulaidl.core.IStructuredDatasetType=} [properties] Properties to set
                 * @returns {nebulaidl.core.StructuredDatasetType} StructuredDatasetType instance
                 */
                StructuredDatasetType.create = function create(properties) {
                    return new StructuredDatasetType(properties);
                };
    
                /**
                 * Encodes the specified StructuredDatasetType message. Does not implicitly {@link nebulaidl.core.StructuredDatasetType.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @static
                 * @param {nebulaidl.core.IStructuredDatasetType} message StructuredDatasetType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StructuredDatasetType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.columns != null && message.columns.length)
                        for (var i = 0; i < message.columns.length; ++i)
                            $root.nebulaidl.core.StructuredDatasetType.DatasetColumn.encode(message.columns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.format != null && message.hasOwnProperty("format"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.format);
                    if (message.externalSchemaType != null && message.hasOwnProperty("externalSchemaType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.externalSchemaType);
                    if (message.externalSchemaBytes != null && message.hasOwnProperty("externalSchemaBytes"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.externalSchemaBytes);
                    return writer;
                };
    
                /**
                 * Decodes a StructuredDatasetType message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.StructuredDatasetType} StructuredDatasetType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StructuredDatasetType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.StructuredDatasetType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.nebulaidl.core.StructuredDatasetType.DatasetColumn.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.format = reader.string();
                            break;
                        case 3:
                            message.externalSchemaType = reader.string();
                            break;
                        case 4:
                            message.externalSchemaBytes = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a StructuredDatasetType message.
                 * @function verify
                 * @memberof nebulaidl.core.StructuredDatasetType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StructuredDatasetType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.columns != null && message.hasOwnProperty("columns")) {
                        if (!Array.isArray(message.columns))
                            return "columns: array expected";
                        for (var i = 0; i < message.columns.length; ++i) {
                            var error = $root.nebulaidl.core.StructuredDatasetType.DatasetColumn.verify(message.columns[i]);
                            if (error)
                                return "columns." + error;
                        }
                    }
                    if (message.format != null && message.hasOwnProperty("format"))
                        if (!$util.isString(message.format))
                            return "format: string expected";
                    if (message.externalSchemaType != null && message.hasOwnProperty("externalSchemaType"))
                        if (!$util.isString(message.externalSchemaType))
                            return "externalSchemaType: string expected";
                    if (message.externalSchemaBytes != null && message.hasOwnProperty("externalSchemaBytes"))
                        if (!(message.externalSchemaBytes && typeof message.externalSchemaBytes.length === "number" || $util.isString(message.externalSchemaBytes)))
                            return "externalSchemaBytes: buffer expected";
                    return null;
                };
    
                StructuredDatasetType.DatasetColumn = (function() {
    
                    /**
                     * Properties of a DatasetColumn.
                     * @memberof nebulaidl.core.StructuredDatasetType
                     * @interface IDatasetColumn
                     * @property {string|null} [name] DatasetColumn name
                     * @property {nebulaidl.core.ILiteralType|null} [literalType] DatasetColumn literalType
                     */
    
                    /**
                     * Constructs a new DatasetColumn.
                     * @memberof nebulaidl.core.StructuredDatasetType
                     * @classdesc Represents a DatasetColumn.
                     * @implements IDatasetColumn
                     * @constructor
                     * @param {nebulaidl.core.StructuredDatasetType.IDatasetColumn=} [properties] Properties to set
                     */
                    function DatasetColumn(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DatasetColumn name.
                     * @member {string} name
                     * @memberof nebulaidl.core.StructuredDatasetType.DatasetColumn
                     * @instance
                     */
                    DatasetColumn.prototype.name = "";
    
                    /**
                     * DatasetColumn literalType.
                     * @member {nebulaidl.core.ILiteralType|null|undefined} literalType
                     * @memberof nebulaidl.core.StructuredDatasetType.DatasetColumn
                     * @instance
                     */
                    DatasetColumn.prototype.literalType = null;
    
                    /**
                     * Creates a new DatasetColumn instance using the specified properties.
                     * @function create
                     * @memberof nebulaidl.core.StructuredDatasetType.DatasetColumn
                     * @static
                     * @param {nebulaidl.core.StructuredDatasetType.IDatasetColumn=} [properties] Properties to set
                     * @returns {nebulaidl.core.StructuredDatasetType.DatasetColumn} DatasetColumn instance
                     */
                    DatasetColumn.create = function create(properties) {
                        return new DatasetColumn(properties);
                    };
    
                    /**
                     * Encodes the specified DatasetColumn message. Does not implicitly {@link nebulaidl.core.StructuredDatasetType.DatasetColumn.verify|verify} messages.
                     * @function encode
                     * @memberof nebulaidl.core.StructuredDatasetType.DatasetColumn
                     * @static
                     * @param {nebulaidl.core.StructuredDatasetType.IDatasetColumn} message DatasetColumn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DatasetColumn.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.literalType != null && message.hasOwnProperty("literalType"))
                            $root.nebulaidl.core.LiteralType.encode(message.literalType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a DatasetColumn message from the specified reader or buffer.
                     * @function decode
                     * @memberof nebulaidl.core.StructuredDatasetType.DatasetColumn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {nebulaidl.core.StructuredDatasetType.DatasetColumn} DatasetColumn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DatasetColumn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.StructuredDatasetType.DatasetColumn();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.literalType = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DatasetColumn message.
                     * @function verify
                     * @memberof nebulaidl.core.StructuredDatasetType.DatasetColumn
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DatasetColumn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.literalType != null && message.hasOwnProperty("literalType")) {
                            var error = $root.nebulaidl.core.LiteralType.verify(message.literalType);
                            if (error)
                                return "literalType." + error;
                        }
                        return null;
                    };
    
                    return DatasetColumn;
                })();
    
                return StructuredDatasetType;
            })();
    
            core.BlobType = (function() {
    
                /**
                 * Properties of a BlobType.
                 * @memberof nebulaidl.core
                 * @interface IBlobType
                 * @property {string|null} [format] BlobType format
                 * @property {nebulaidl.core.BlobType.BlobDimensionality|null} [dimensionality] BlobType dimensionality
                 */
    
                /**
                 * Constructs a new BlobType.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a BlobType.
                 * @implements IBlobType
                 * @constructor
                 * @param {nebulaidl.core.IBlobType=} [properties] Properties to set
                 */
                function BlobType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BlobType format.
                 * @member {string} format
                 * @memberof nebulaidl.core.BlobType
                 * @instance
                 */
                BlobType.prototype.format = "";
    
                /**
                 * BlobType dimensionality.
                 * @member {nebulaidl.core.BlobType.BlobDimensionality} dimensionality
                 * @memberof nebulaidl.core.BlobType
                 * @instance
                 */
                BlobType.prototype.dimensionality = 0;
    
                /**
                 * Creates a new BlobType instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.BlobType
                 * @static
                 * @param {nebulaidl.core.IBlobType=} [properties] Properties to set
                 * @returns {nebulaidl.core.BlobType} BlobType instance
                 */
                BlobType.create = function create(properties) {
                    return new BlobType(properties);
                };
    
                /**
                 * Encodes the specified BlobType message. Does not implicitly {@link nebulaidl.core.BlobType.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.BlobType
                 * @static
                 * @param {nebulaidl.core.IBlobType} message BlobType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlobType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.format != null && message.hasOwnProperty("format"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.format);
                    if (message.dimensionality != null && message.hasOwnProperty("dimensionality"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dimensionality);
                    return writer;
                };
    
                /**
                 * Decodes a BlobType message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.BlobType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.BlobType} BlobType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlobType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.BlobType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.format = reader.string();
                            break;
                        case 2:
                            message.dimensionality = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BlobType message.
                 * @function verify
                 * @memberof nebulaidl.core.BlobType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlobType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.format != null && message.hasOwnProperty("format"))
                        if (!$util.isString(message.format))
                            return "format: string expected";
                    if (message.dimensionality != null && message.hasOwnProperty("dimensionality"))
                        switch (message.dimensionality) {
                        default:
                            return "dimensionality: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * BlobDimensionality enum.
                 * @name nebulaidl.core.BlobType.BlobDimensionality
                 * @enum {string}
                 * @property {number} SINGLE=0 SINGLE value
                 * @property {number} MULTIPART=1 MULTIPART value
                 */
                BlobType.BlobDimensionality = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SINGLE"] = 0;
                    values[valuesById[1] = "MULTIPART"] = 1;
                    return values;
                })();
    
                return BlobType;
            })();
    
            core.EnumType = (function() {
    
                /**
                 * Properties of an EnumType.
                 * @memberof nebulaidl.core
                 * @interface IEnumType
                 * @property {Array.<string>|null} [values] EnumType values
                 */
    
                /**
                 * Constructs a new EnumType.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an EnumType.
                 * @implements IEnumType
                 * @constructor
                 * @param {nebulaidl.core.IEnumType=} [properties] Properties to set
                 */
                function EnumType(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumType values.
                 * @member {Array.<string>} values
                 * @memberof nebulaidl.core.EnumType
                 * @instance
                 */
                EnumType.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new EnumType instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.EnumType
                 * @static
                 * @param {nebulaidl.core.IEnumType=} [properties] Properties to set
                 * @returns {nebulaidl.core.EnumType} EnumType instance
                 */
                EnumType.create = function create(properties) {
                    return new EnumType(properties);
                };
    
                /**
                 * Encodes the specified EnumType message. Does not implicitly {@link nebulaidl.core.EnumType.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.EnumType
                 * @static
                 * @param {nebulaidl.core.IEnumType} message EnumType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.values[i]);
                    return writer;
                };
    
                /**
                 * Decodes an EnumType message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.EnumType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.EnumType} EnumType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.EnumType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EnumType message.
                 * @function verify
                 * @memberof nebulaidl.core.EnumType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i)
                            if (!$util.isString(message.values[i]))
                                return "values: string[] expected";
                    }
                    return null;
                };
    
                return EnumType;
            })();
    
            core.UnionType = (function() {
    
                /**
                 * Properties of an UnionType.
                 * @memberof nebulaidl.core
                 * @interface IUnionType
                 * @property {Array.<nebulaidl.core.ILiteralType>|null} [variants] UnionType variants
                 */
    
                /**
                 * Constructs a new UnionType.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an UnionType.
                 * @implements IUnionType
                 * @constructor
                 * @param {nebulaidl.core.IUnionType=} [properties] Properties to set
                 */
                function UnionType(properties) {
                    this.variants = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UnionType variants.
                 * @member {Array.<nebulaidl.core.ILiteralType>} variants
                 * @memberof nebulaidl.core.UnionType
                 * @instance
                 */
                UnionType.prototype.variants = $util.emptyArray;
    
                /**
                 * Creates a new UnionType instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.UnionType
                 * @static
                 * @param {nebulaidl.core.IUnionType=} [properties] Properties to set
                 * @returns {nebulaidl.core.UnionType} UnionType instance
                 */
                UnionType.create = function create(properties) {
                    return new UnionType(properties);
                };
    
                /**
                 * Encodes the specified UnionType message. Does not implicitly {@link nebulaidl.core.UnionType.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.UnionType
                 * @static
                 * @param {nebulaidl.core.IUnionType} message UnionType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnionType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.variants != null && message.variants.length)
                        for (var i = 0; i < message.variants.length; ++i)
                            $root.nebulaidl.core.LiteralType.encode(message.variants[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an UnionType message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.UnionType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.UnionType} UnionType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnionType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.UnionType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.variants && message.variants.length))
                                message.variants = [];
                            message.variants.push($root.nebulaidl.core.LiteralType.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an UnionType message.
                 * @function verify
                 * @memberof nebulaidl.core.UnionType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnionType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.variants != null && message.hasOwnProperty("variants")) {
                        if (!Array.isArray(message.variants))
                            return "variants: array expected";
                        for (var i = 0; i < message.variants.length; ++i) {
                            var error = $root.nebulaidl.core.LiteralType.verify(message.variants[i]);
                            if (error)
                                return "variants." + error;
                        }
                    }
                    return null;
                };
    
                return UnionType;
            })();
    
            core.TypeStructure = (function() {
    
                /**
                 * Properties of a TypeStructure.
                 * @memberof nebulaidl.core
                 * @interface ITypeStructure
                 * @property {string|null} [tag] TypeStructure tag
                 */
    
                /**
                 * Constructs a new TypeStructure.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TypeStructure.
                 * @implements ITypeStructure
                 * @constructor
                 * @param {nebulaidl.core.ITypeStructure=} [properties] Properties to set
                 */
                function TypeStructure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TypeStructure tag.
                 * @member {string} tag
                 * @memberof nebulaidl.core.TypeStructure
                 * @instance
                 */
                TypeStructure.prototype.tag = "";
    
                /**
                 * Creates a new TypeStructure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TypeStructure
                 * @static
                 * @param {nebulaidl.core.ITypeStructure=} [properties] Properties to set
                 * @returns {nebulaidl.core.TypeStructure} TypeStructure instance
                 */
                TypeStructure.create = function create(properties) {
                    return new TypeStructure(properties);
                };
    
                /**
                 * Encodes the specified TypeStructure message. Does not implicitly {@link nebulaidl.core.TypeStructure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TypeStructure
                 * @static
                 * @param {nebulaidl.core.ITypeStructure} message TypeStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TypeStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tag != null && message.hasOwnProperty("tag"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.tag);
                    return writer;
                };
    
                /**
                 * Decodes a TypeStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TypeStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TypeStructure} TypeStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TypeStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TypeStructure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.tag = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TypeStructure message.
                 * @function verify
                 * @memberof nebulaidl.core.TypeStructure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TypeStructure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tag != null && message.hasOwnProperty("tag"))
                        if (!$util.isString(message.tag))
                            return "tag: string expected";
                    return null;
                };
    
                return TypeStructure;
            })();
    
            core.TypeAnnotation = (function() {
    
                /**
                 * Properties of a TypeAnnotation.
                 * @memberof nebulaidl.core
                 * @interface ITypeAnnotation
                 * @property {google.protobuf.IStruct|null} [annotations] TypeAnnotation annotations
                 */
    
                /**
                 * Constructs a new TypeAnnotation.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TypeAnnotation.
                 * @implements ITypeAnnotation
                 * @constructor
                 * @param {nebulaidl.core.ITypeAnnotation=} [properties] Properties to set
                 */
                function TypeAnnotation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TypeAnnotation annotations.
                 * @member {google.protobuf.IStruct|null|undefined} annotations
                 * @memberof nebulaidl.core.TypeAnnotation
                 * @instance
                 */
                TypeAnnotation.prototype.annotations = null;
    
                /**
                 * Creates a new TypeAnnotation instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TypeAnnotation
                 * @static
                 * @param {nebulaidl.core.ITypeAnnotation=} [properties] Properties to set
                 * @returns {nebulaidl.core.TypeAnnotation} TypeAnnotation instance
                 */
                TypeAnnotation.create = function create(properties) {
                    return new TypeAnnotation(properties);
                };
    
                /**
                 * Encodes the specified TypeAnnotation message. Does not implicitly {@link nebulaidl.core.TypeAnnotation.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TypeAnnotation
                 * @static
                 * @param {nebulaidl.core.ITypeAnnotation} message TypeAnnotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TypeAnnotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotations != null && message.hasOwnProperty("annotations"))
                        $root.google.protobuf.Struct.encode(message.annotations, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TypeAnnotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TypeAnnotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TypeAnnotation} TypeAnnotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TypeAnnotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TypeAnnotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.annotations = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TypeAnnotation message.
                 * @function verify
                 * @memberof nebulaidl.core.TypeAnnotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TypeAnnotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        var error = $root.google.protobuf.Struct.verify(message.annotations);
                        if (error)
                            return "annotations." + error;
                    }
                    return null;
                };
    
                return TypeAnnotation;
            })();
    
            core.LiteralType = (function() {
    
                /**
                 * Properties of a LiteralType.
                 * @memberof nebulaidl.core
                 * @interface ILiteralType
                 * @property {nebulaidl.core.SimpleType|null} [simple] LiteralType simple
                 * @property {nebulaidl.core.ISchemaType|null} [schema] LiteralType schema
                 * @property {nebulaidl.core.ILiteralType|null} [collectionType] LiteralType collectionType
                 * @property {nebulaidl.core.ILiteralType|null} [mapValueType] LiteralType mapValueType
                 * @property {nebulaidl.core.IBlobType|null} [blob] LiteralType blob
                 * @property {nebulaidl.core.IEnumType|null} [enumType] LiteralType enumType
                 * @property {nebulaidl.core.IStructuredDatasetType|null} [structuredDatasetType] LiteralType structuredDatasetType
                 * @property {nebulaidl.core.IUnionType|null} [unionType] LiteralType unionType
                 * @property {google.protobuf.IStruct|null} [metadata] LiteralType metadata
                 * @property {nebulaidl.core.ITypeAnnotation|null} [annotation] LiteralType annotation
                 * @property {nebulaidl.core.ITypeStructure|null} [structure] LiteralType structure
                 */
    
                /**
                 * Constructs a new LiteralType.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a LiteralType.
                 * @implements ILiteralType
                 * @constructor
                 * @param {nebulaidl.core.ILiteralType=} [properties] Properties to set
                 */
                function LiteralType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LiteralType simple.
                 * @member {nebulaidl.core.SimpleType} simple
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.simple = 0;
    
                /**
                 * LiteralType schema.
                 * @member {nebulaidl.core.ISchemaType|null|undefined} schema
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.schema = null;
    
                /**
                 * LiteralType collectionType.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} collectionType
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.collectionType = null;
    
                /**
                 * LiteralType mapValueType.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} mapValueType
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.mapValueType = null;
    
                /**
                 * LiteralType blob.
                 * @member {nebulaidl.core.IBlobType|null|undefined} blob
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.blob = null;
    
                /**
                 * LiteralType enumType.
                 * @member {nebulaidl.core.IEnumType|null|undefined} enumType
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.enumType = null;
    
                /**
                 * LiteralType structuredDatasetType.
                 * @member {nebulaidl.core.IStructuredDatasetType|null|undefined} structuredDatasetType
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.structuredDatasetType = null;
    
                /**
                 * LiteralType unionType.
                 * @member {nebulaidl.core.IUnionType|null|undefined} unionType
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.unionType = null;
    
                /**
                 * LiteralType metadata.
                 * @member {google.protobuf.IStruct|null|undefined} metadata
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.metadata = null;
    
                /**
                 * LiteralType annotation.
                 * @member {nebulaidl.core.ITypeAnnotation|null|undefined} annotation
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.annotation = null;
    
                /**
                 * LiteralType structure.
                 * @member {nebulaidl.core.ITypeStructure|null|undefined} structure
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                LiteralType.prototype.structure = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * LiteralType type.
                 * @member {"simple"|"schema"|"collectionType"|"mapValueType"|"blob"|"enumType"|"structuredDatasetType"|"unionType"|undefined} type
                 * @memberof nebulaidl.core.LiteralType
                 * @instance
                 */
                Object.defineProperty(LiteralType.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["simple", "schema", "collectionType", "mapValueType", "blob", "enumType", "structuredDatasetType", "unionType"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new LiteralType instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.LiteralType
                 * @static
                 * @param {nebulaidl.core.ILiteralType=} [properties] Properties to set
                 * @returns {nebulaidl.core.LiteralType} LiteralType instance
                 */
                LiteralType.create = function create(properties) {
                    return new LiteralType(properties);
                };
    
                /**
                 * Encodes the specified LiteralType message. Does not implicitly {@link nebulaidl.core.LiteralType.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.LiteralType
                 * @static
                 * @param {nebulaidl.core.ILiteralType} message LiteralType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiteralType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.simple != null && message.hasOwnProperty("simple"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simple);
                    if (message.schema != null && message.hasOwnProperty("schema"))
                        $root.nebulaidl.core.SchemaType.encode(message.schema, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.collectionType != null && message.hasOwnProperty("collectionType"))
                        $root.nebulaidl.core.LiteralType.encode(message.collectionType, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.mapValueType != null && message.hasOwnProperty("mapValueType"))
                        $root.nebulaidl.core.LiteralType.encode(message.mapValueType, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.blob != null && message.hasOwnProperty("blob"))
                        $root.nebulaidl.core.BlobType.encode(message.blob, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.google.protobuf.Struct.encode(message.metadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.enumType != null && message.hasOwnProperty("enumType"))
                        $root.nebulaidl.core.EnumType.encode(message.enumType, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.structuredDatasetType != null && message.hasOwnProperty("structuredDatasetType"))
                        $root.nebulaidl.core.StructuredDatasetType.encode(message.structuredDatasetType, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.annotation != null && message.hasOwnProperty("annotation"))
                        $root.nebulaidl.core.TypeAnnotation.encode(message.annotation, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.unionType != null && message.hasOwnProperty("unionType"))
                        $root.nebulaidl.core.UnionType.encode(message.unionType, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.structure != null && message.hasOwnProperty("structure"))
                        $root.nebulaidl.core.TypeStructure.encode(message.structure, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LiteralType message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.LiteralType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.LiteralType} LiteralType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiteralType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.LiteralType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.simple = reader.int32();
                            break;
                        case 2:
                            message.schema = $root.nebulaidl.core.SchemaType.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.collectionType = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.mapValueType = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.blob = $root.nebulaidl.core.BlobType.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.enumType = $root.nebulaidl.core.EnumType.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.structuredDatasetType = $root.nebulaidl.core.StructuredDatasetType.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.unionType = $root.nebulaidl.core.UnionType.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.metadata = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.annotation = $root.nebulaidl.core.TypeAnnotation.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.structure = $root.nebulaidl.core.TypeStructure.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LiteralType message.
                 * @function verify
                 * @memberof nebulaidl.core.LiteralType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LiteralType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.simple != null && message.hasOwnProperty("simple")) {
                        properties.type = 1;
                        switch (message.simple) {
                        default:
                            return "simple: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    }
                    if (message.schema != null && message.hasOwnProperty("schema")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.SchemaType.verify(message.schema);
                            if (error)
                                return "schema." + error;
                        }
                    }
                    if (message.collectionType != null && message.hasOwnProperty("collectionType")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralType.verify(message.collectionType);
                            if (error)
                                return "collectionType." + error;
                        }
                    }
                    if (message.mapValueType != null && message.hasOwnProperty("mapValueType")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralType.verify(message.mapValueType);
                            if (error)
                                return "mapValueType." + error;
                        }
                    }
                    if (message.blob != null && message.hasOwnProperty("blob")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.BlobType.verify(message.blob);
                            if (error)
                                return "blob." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.EnumType.verify(message.enumType);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.structuredDatasetType != null && message.hasOwnProperty("structuredDatasetType")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.StructuredDatasetType.verify(message.structuredDatasetType);
                            if (error)
                                return "structuredDatasetType." + error;
                        }
                    }
                    if (message.unionType != null && message.hasOwnProperty("unionType")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.core.UnionType.verify(message.unionType);
                            if (error)
                                return "unionType." + error;
                        }
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.google.protobuf.Struct.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.annotation != null && message.hasOwnProperty("annotation")) {
                        var error = $root.nebulaidl.core.TypeAnnotation.verify(message.annotation);
                        if (error)
                            return "annotation." + error;
                    }
                    if (message.structure != null && message.hasOwnProperty("structure")) {
                        var error = $root.nebulaidl.core.TypeStructure.verify(message.structure);
                        if (error)
                            return "structure." + error;
                    }
                    return null;
                };
    
                return LiteralType;
            })();
    
            core.OutputReference = (function() {
    
                /**
                 * Properties of an OutputReference.
                 * @memberof nebulaidl.core
                 * @interface IOutputReference
                 * @property {string|null} [nodeId] OutputReference nodeId
                 * @property {string|null} ["var"] OutputReference var
                 * @property {Array.<nebulaidl.core.IPromiseAttribute>|null} [attrPath] OutputReference attrPath
                 */
    
                /**
                 * Constructs a new OutputReference.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an OutputReference.
                 * @implements IOutputReference
                 * @constructor
                 * @param {nebulaidl.core.IOutputReference=} [properties] Properties to set
                 */
                function OutputReference(properties) {
                    this.attrPath = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OutputReference nodeId.
                 * @member {string} nodeId
                 * @memberof nebulaidl.core.OutputReference
                 * @instance
                 */
                OutputReference.prototype.nodeId = "";
    
                /**
                 * OutputReference var.
                 * @member {string} var
                 * @memberof nebulaidl.core.OutputReference
                 * @instance
                 */
                OutputReference.prototype["var"] = "";
    
                /**
                 * OutputReference attrPath.
                 * @member {Array.<nebulaidl.core.IPromiseAttribute>} attrPath
                 * @memberof nebulaidl.core.OutputReference
                 * @instance
                 */
                OutputReference.prototype.attrPath = $util.emptyArray;
    
                /**
                 * Creates a new OutputReference instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.OutputReference
                 * @static
                 * @param {nebulaidl.core.IOutputReference=} [properties] Properties to set
                 * @returns {nebulaidl.core.OutputReference} OutputReference instance
                 */
                OutputReference.create = function create(properties) {
                    return new OutputReference(properties);
                };
    
                /**
                 * Encodes the specified OutputReference message. Does not implicitly {@link nebulaidl.core.OutputReference.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.OutputReference
                 * @static
                 * @param {nebulaidl.core.IOutputReference} message OutputReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OutputReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["var"]);
                    if (message.attrPath != null && message.attrPath.length)
                        for (var i = 0; i < message.attrPath.length; ++i)
                            $root.nebulaidl.core.PromiseAttribute.encode(message.attrPath[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an OutputReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.OutputReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.OutputReference} OutputReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OutputReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.OutputReference();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nodeId = reader.string();
                            break;
                        case 2:
                            message["var"] = reader.string();
                            break;
                        case 3:
                            if (!(message.attrPath && message.attrPath.length))
                                message.attrPath = [];
                            message.attrPath.push($root.nebulaidl.core.PromiseAttribute.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an OutputReference message.
                 * @function verify
                 * @memberof nebulaidl.core.OutputReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OutputReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        if (!$util.isString(message.nodeId))
                            return "nodeId: string expected";
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        if (!$util.isString(message["var"]))
                            return "var: string expected";
                    if (message.attrPath != null && message.hasOwnProperty("attrPath")) {
                        if (!Array.isArray(message.attrPath))
                            return "attrPath: array expected";
                        for (var i = 0; i < message.attrPath.length; ++i) {
                            var error = $root.nebulaidl.core.PromiseAttribute.verify(message.attrPath[i]);
                            if (error)
                                return "attrPath." + error;
                        }
                    }
                    return null;
                };
    
                return OutputReference;
            })();
    
            core.PromiseAttribute = (function() {
    
                /**
                 * Properties of a PromiseAttribute.
                 * @memberof nebulaidl.core
                 * @interface IPromiseAttribute
                 * @property {string|null} [stringValue] PromiseAttribute stringValue
                 * @property {number|null} [intValue] PromiseAttribute intValue
                 */
    
                /**
                 * Constructs a new PromiseAttribute.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a PromiseAttribute.
                 * @implements IPromiseAttribute
                 * @constructor
                 * @param {nebulaidl.core.IPromiseAttribute=} [properties] Properties to set
                 */
                function PromiseAttribute(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PromiseAttribute stringValue.
                 * @member {string} stringValue
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @instance
                 */
                PromiseAttribute.prototype.stringValue = "";
    
                /**
                 * PromiseAttribute intValue.
                 * @member {number} intValue
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @instance
                 */
                PromiseAttribute.prototype.intValue = 0;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * PromiseAttribute value.
                 * @member {"stringValue"|"intValue"|undefined} value
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @instance
                 */
                Object.defineProperty(PromiseAttribute.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["stringValue", "intValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new PromiseAttribute instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @static
                 * @param {nebulaidl.core.IPromiseAttribute=} [properties] Properties to set
                 * @returns {nebulaidl.core.PromiseAttribute} PromiseAttribute instance
                 */
                PromiseAttribute.create = function create(properties) {
                    return new PromiseAttribute(properties);
                };
    
                /**
                 * Encodes the specified PromiseAttribute message. Does not implicitly {@link nebulaidl.core.PromiseAttribute.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @static
                 * @param {nebulaidl.core.IPromiseAttribute} message PromiseAttribute message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromiseAttribute.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);
                    if (message.intValue != null && message.hasOwnProperty("intValue"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.intValue);
                    return writer;
                };
    
                /**
                 * Decodes a PromiseAttribute message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.PromiseAttribute} PromiseAttribute
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromiseAttribute.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.PromiseAttribute();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringValue = reader.string();
                            break;
                        case 2:
                            message.intValue = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PromiseAttribute message.
                 * @function verify
                 * @memberof nebulaidl.core.PromiseAttribute
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PromiseAttribute.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        properties.value = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    if (message.intValue != null && message.hasOwnProperty("intValue")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        if (!$util.isInteger(message.intValue))
                            return "intValue: integer expected";
                    }
                    return null;
                };
    
                return PromiseAttribute;
            })();
    
            core.Error = (function() {
    
                /**
                 * Properties of an Error.
                 * @memberof nebulaidl.core
                 * @interface IError
                 * @property {string|null} [failedNodeId] Error failedNodeId
                 * @property {string|null} [message] Error message
                 */
    
                /**
                 * Constructs a new Error.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an Error.
                 * @implements IError
                 * @constructor
                 * @param {nebulaidl.core.IError=} [properties] Properties to set
                 */
                function Error(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Error failedNodeId.
                 * @member {string} failedNodeId
                 * @memberof nebulaidl.core.Error
                 * @instance
                 */
                Error.prototype.failedNodeId = "";
    
                /**
                 * Error message.
                 * @member {string} message
                 * @memberof nebulaidl.core.Error
                 * @instance
                 */
                Error.prototype.message = "";
    
                /**
                 * Creates a new Error instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Error
                 * @static
                 * @param {nebulaidl.core.IError=} [properties] Properties to set
                 * @returns {nebulaidl.core.Error} Error instance
                 */
                Error.create = function create(properties) {
                    return new Error(properties);
                };
    
                /**
                 * Encodes the specified Error message. Does not implicitly {@link nebulaidl.core.Error.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Error
                 * @static
                 * @param {nebulaidl.core.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.failedNodeId != null && message.hasOwnProperty("failedNodeId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.failedNodeId);
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    return writer;
                };
    
                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Error();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.failedNodeId = reader.string();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Error message.
                 * @function verify
                 * @memberof nebulaidl.core.Error
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Error.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.failedNodeId != null && message.hasOwnProperty("failedNodeId"))
                        if (!$util.isString(message.failedNodeId))
                            return "failedNodeId: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };
    
                return Error;
            })();
    
            core.WorkflowExecution = (function() {
    
                /**
                 * Properties of a WorkflowExecution.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowExecution
                 */
    
                /**
                 * Constructs a new WorkflowExecution.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowExecution.
                 * @implements IWorkflowExecution
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowExecution=} [properties] Properties to set
                 */
                function WorkflowExecution(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WorkflowExecution instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowExecution
                 * @static
                 * @param {nebulaidl.core.IWorkflowExecution=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowExecution} WorkflowExecution instance
                 */
                WorkflowExecution.create = function create(properties) {
                    return new WorkflowExecution(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecution message. Does not implicitly {@link nebulaidl.core.WorkflowExecution.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowExecution
                 * @static
                 * @param {nebulaidl.core.IWorkflowExecution} message WorkflowExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowExecution} WorkflowExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecution.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowExecution();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecution message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Phase enum.
                 * @name nebulaidl.core.WorkflowExecution.Phase
                 * @enum {string}
                 * @property {number} UNDEFINED=0 UNDEFINED value
                 * @property {number} QUEUED=1 QUEUED value
                 * @property {number} RUNNING=2 RUNNING value
                 * @property {number} SUCCEEDING=3 SUCCEEDING value
                 * @property {number} SUCCEEDED=4 SUCCEEDED value
                 * @property {number} FAILING=5 FAILING value
                 * @property {number} FAILED=6 FAILED value
                 * @property {number} ABORTED=7 ABORTED value
                 * @property {number} TIMED_OUT=8 TIMED_OUT value
                 * @property {number} ABORTING=9 ABORTING value
                 */
                WorkflowExecution.Phase = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "QUEUED"] = 1;
                    values[valuesById[2] = "RUNNING"] = 2;
                    values[valuesById[3] = "SUCCEEDING"] = 3;
                    values[valuesById[4] = "SUCCEEDED"] = 4;
                    values[valuesById[5] = "FAILING"] = 5;
                    values[valuesById[6] = "FAILED"] = 6;
                    values[valuesById[7] = "ABORTED"] = 7;
                    values[valuesById[8] = "TIMED_OUT"] = 8;
                    values[valuesById[9] = "ABORTING"] = 9;
                    return values;
                })();
    
                return WorkflowExecution;
            })();
    
            core.NodeExecution = (function() {
    
                /**
                 * Properties of a NodeExecution.
                 * @memberof nebulaidl.core
                 * @interface INodeExecution
                 */
    
                /**
                 * Constructs a new NodeExecution.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a NodeExecution.
                 * @implements INodeExecution
                 * @constructor
                 * @param {nebulaidl.core.INodeExecution=} [properties] Properties to set
                 */
                function NodeExecution(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new NodeExecution instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.NodeExecution
                 * @static
                 * @param {nebulaidl.core.INodeExecution=} [properties] Properties to set
                 * @returns {nebulaidl.core.NodeExecution} NodeExecution instance
                 */
                NodeExecution.create = function create(properties) {
                    return new NodeExecution(properties);
                };
    
                /**
                 * Encodes the specified NodeExecution message. Does not implicitly {@link nebulaidl.core.NodeExecution.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.NodeExecution
                 * @static
                 * @param {nebulaidl.core.INodeExecution} message NodeExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.NodeExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.NodeExecution} NodeExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecution.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.NodeExecution();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecution message.
                 * @function verify
                 * @memberof nebulaidl.core.NodeExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Phase enum.
                 * @name nebulaidl.core.NodeExecution.Phase
                 * @enum {string}
                 * @property {number} UNDEFINED=0 UNDEFINED value
                 * @property {number} QUEUED=1 QUEUED value
                 * @property {number} RUNNING=2 RUNNING value
                 * @property {number} SUCCEEDED=3 SUCCEEDED value
                 * @property {number} FAILING=4 FAILING value
                 * @property {number} FAILED=5 FAILED value
                 * @property {number} ABORTED=6 ABORTED value
                 * @property {number} SKIPPED=7 SKIPPED value
                 * @property {number} TIMED_OUT=8 TIMED_OUT value
                 * @property {number} DYNAMIC_RUNNING=9 DYNAMIC_RUNNING value
                 * @property {number} RECOVERED=10 RECOVERED value
                 */
                NodeExecution.Phase = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "QUEUED"] = 1;
                    values[valuesById[2] = "RUNNING"] = 2;
                    values[valuesById[3] = "SUCCEEDED"] = 3;
                    values[valuesById[4] = "FAILING"] = 4;
                    values[valuesById[5] = "FAILED"] = 5;
                    values[valuesById[6] = "ABORTED"] = 6;
                    values[valuesById[7] = "SKIPPED"] = 7;
                    values[valuesById[8] = "TIMED_OUT"] = 8;
                    values[valuesById[9] = "DYNAMIC_RUNNING"] = 9;
                    values[valuesById[10] = "RECOVERED"] = 10;
                    return values;
                })();
    
                return NodeExecution;
            })();
    
            core.TaskExecution = (function() {
    
                /**
                 * Properties of a TaskExecution.
                 * @memberof nebulaidl.core
                 * @interface ITaskExecution
                 */
    
                /**
                 * Constructs a new TaskExecution.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskExecution.
                 * @implements ITaskExecution
                 * @constructor
                 * @param {nebulaidl.core.ITaskExecution=} [properties] Properties to set
                 */
                function TaskExecution(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new TaskExecution instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskExecution
                 * @static
                 * @param {nebulaidl.core.ITaskExecution=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskExecution} TaskExecution instance
                 */
                TaskExecution.create = function create(properties) {
                    return new TaskExecution(properties);
                };
    
                /**
                 * Encodes the specified TaskExecution message. Does not implicitly {@link nebulaidl.core.TaskExecution.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskExecution
                 * @static
                 * @param {nebulaidl.core.ITaskExecution} message TaskExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskExecution} TaskExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecution.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskExecution();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecution message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Phase enum.
                 * @name nebulaidl.core.TaskExecution.Phase
                 * @enum {string}
                 * @property {number} UNDEFINED=0 UNDEFINED value
                 * @property {number} QUEUED=1 QUEUED value
                 * @property {number} RUNNING=2 RUNNING value
                 * @property {number} SUCCEEDED=3 SUCCEEDED value
                 * @property {number} ABORTED=4 ABORTED value
                 * @property {number} FAILED=5 FAILED value
                 * @property {number} INITIALIZING=6 INITIALIZING value
                 * @property {number} WAITING_FOR_RESOURCES=7 WAITING_FOR_RESOURCES value
                 */
                TaskExecution.Phase = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "QUEUED"] = 1;
                    values[valuesById[2] = "RUNNING"] = 2;
                    values[valuesById[3] = "SUCCEEDED"] = 3;
                    values[valuesById[4] = "ABORTED"] = 4;
                    values[valuesById[5] = "FAILED"] = 5;
                    values[valuesById[6] = "INITIALIZING"] = 6;
                    values[valuesById[7] = "WAITING_FOR_RESOURCES"] = 7;
                    return values;
                })();
    
                return TaskExecution;
            })();
    
            core.ExecutionError = (function() {
    
                /**
                 * Properties of an ExecutionError.
                 * @memberof nebulaidl.core
                 * @interface IExecutionError
                 * @property {string|null} [code] ExecutionError code
                 * @property {string|null} [message] ExecutionError message
                 * @property {string|null} [errorUri] ExecutionError errorUri
                 * @property {nebulaidl.core.ExecutionError.ErrorKind|null} [kind] ExecutionError kind
                 */
    
                /**
                 * Constructs a new ExecutionError.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an ExecutionError.
                 * @implements IExecutionError
                 * @constructor
                 * @param {nebulaidl.core.IExecutionError=} [properties] Properties to set
                 */
                function ExecutionError(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionError code.
                 * @member {string} code
                 * @memberof nebulaidl.core.ExecutionError
                 * @instance
                 */
                ExecutionError.prototype.code = "";
    
                /**
                 * ExecutionError message.
                 * @member {string} message
                 * @memberof nebulaidl.core.ExecutionError
                 * @instance
                 */
                ExecutionError.prototype.message = "";
    
                /**
                 * ExecutionError errorUri.
                 * @member {string} errorUri
                 * @memberof nebulaidl.core.ExecutionError
                 * @instance
                 */
                ExecutionError.prototype.errorUri = "";
    
                /**
                 * ExecutionError kind.
                 * @member {nebulaidl.core.ExecutionError.ErrorKind} kind
                 * @memberof nebulaidl.core.ExecutionError
                 * @instance
                 */
                ExecutionError.prototype.kind = 0;
    
                /**
                 * Creates a new ExecutionError instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ExecutionError
                 * @static
                 * @param {nebulaidl.core.IExecutionError=} [properties] Properties to set
                 * @returns {nebulaidl.core.ExecutionError} ExecutionError instance
                 */
                ExecutionError.create = function create(properties) {
                    return new ExecutionError(properties);
                };
    
                /**
                 * Encodes the specified ExecutionError message. Does not implicitly {@link nebulaidl.core.ExecutionError.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ExecutionError
                 * @static
                 * @param {nebulaidl.core.IExecutionError} message ExecutionError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && message.hasOwnProperty("code"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    if (message.errorUri != null && message.hasOwnProperty("errorUri"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorUri);
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.kind);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionError message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ExecutionError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ExecutionError} ExecutionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionError.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ExecutionError();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.string();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        case 3:
                            message.errorUri = reader.string();
                            break;
                        case 4:
                            message.kind = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionError message.
                 * @function verify
                 * @memberof nebulaidl.core.ExecutionError
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.errorUri != null && message.hasOwnProperty("errorUri"))
                        if (!$util.isString(message.errorUri))
                            return "errorUri: string expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        switch (message.kind) {
                        default:
                            return "kind: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * ErrorKind enum.
                 * @name nebulaidl.core.ExecutionError.ErrorKind
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} USER=1 USER value
                 * @property {number} SYSTEM=2 SYSTEM value
                 */
                ExecutionError.ErrorKind = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "USER"] = 1;
                    values[valuesById[2] = "SYSTEM"] = 2;
                    return values;
                })();
    
                return ExecutionError;
            })();
    
            core.TaskLog = (function() {
    
                /**
                 * Properties of a TaskLog.
                 * @memberof nebulaidl.core
                 * @interface ITaskLog
                 * @property {string|null} [uri] TaskLog uri
                 * @property {string|null} [name] TaskLog name
                 * @property {nebulaidl.core.TaskLog.MessageFormat|null} [messageFormat] TaskLog messageFormat
                 * @property {google.protobuf.IDuration|null} [ttl] TaskLog ttl
                 */
    
                /**
                 * Constructs a new TaskLog.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskLog.
                 * @implements ITaskLog
                 * @constructor
                 * @param {nebulaidl.core.ITaskLog=} [properties] Properties to set
                 */
                function TaskLog(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskLog uri.
                 * @member {string} uri
                 * @memberof nebulaidl.core.TaskLog
                 * @instance
                 */
                TaskLog.prototype.uri = "";
    
                /**
                 * TaskLog name.
                 * @member {string} name
                 * @memberof nebulaidl.core.TaskLog
                 * @instance
                 */
                TaskLog.prototype.name = "";
    
                /**
                 * TaskLog messageFormat.
                 * @member {nebulaidl.core.TaskLog.MessageFormat} messageFormat
                 * @memberof nebulaidl.core.TaskLog
                 * @instance
                 */
                TaskLog.prototype.messageFormat = 0;
    
                /**
                 * TaskLog ttl.
                 * @member {google.protobuf.IDuration|null|undefined} ttl
                 * @memberof nebulaidl.core.TaskLog
                 * @instance
                 */
                TaskLog.prototype.ttl = null;
    
                /**
                 * Creates a new TaskLog instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskLog
                 * @static
                 * @param {nebulaidl.core.ITaskLog=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskLog} TaskLog instance
                 */
                TaskLog.create = function create(properties) {
                    return new TaskLog(properties);
                };
    
                /**
                 * Encodes the specified TaskLog message. Does not implicitly {@link nebulaidl.core.TaskLog.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskLog
                 * @static
                 * @param {nebulaidl.core.ITaskLog} message TaskLog message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskLog.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.messageFormat != null && message.hasOwnProperty("messageFormat"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.messageFormat);
                    if (message.ttl != null && message.hasOwnProperty("ttl"))
                        $root.google.protobuf.Duration.encode(message.ttl, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskLog message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskLog
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskLog} TaskLog
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskLog.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskLog();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.messageFormat = reader.int32();
                            break;
                        case 4:
                            message.ttl = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskLog message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskLog
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskLog.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.messageFormat != null && message.hasOwnProperty("messageFormat"))
                        switch (message.messageFormat) {
                        default:
                            return "messageFormat: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.ttl != null && message.hasOwnProperty("ttl")) {
                        var error = $root.google.protobuf.Duration.verify(message.ttl);
                        if (error)
                            return "ttl." + error;
                    }
                    return null;
                };
    
                /**
                 * MessageFormat enum.
                 * @name nebulaidl.core.TaskLog.MessageFormat
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} CSV=1 CSV value
                 * @property {number} JSON=2 JSON value
                 */
                TaskLog.MessageFormat = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "CSV"] = 1;
                    values[valuesById[2] = "JSON"] = 2;
                    return values;
                })();
    
                return TaskLog;
            })();
    
            core.QualityOfServiceSpec = (function() {
    
                /**
                 * Properties of a QualityOfServiceSpec.
                 * @memberof nebulaidl.core
                 * @interface IQualityOfServiceSpec
                 * @property {google.protobuf.IDuration|null} [queueingBudget] QualityOfServiceSpec queueingBudget
                 */
    
                /**
                 * Constructs a new QualityOfServiceSpec.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a QualityOfServiceSpec.
                 * @implements IQualityOfServiceSpec
                 * @constructor
                 * @param {nebulaidl.core.IQualityOfServiceSpec=} [properties] Properties to set
                 */
                function QualityOfServiceSpec(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QualityOfServiceSpec queueingBudget.
                 * @member {google.protobuf.IDuration|null|undefined} queueingBudget
                 * @memberof nebulaidl.core.QualityOfServiceSpec
                 * @instance
                 */
                QualityOfServiceSpec.prototype.queueingBudget = null;
    
                /**
                 * Creates a new QualityOfServiceSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.QualityOfServiceSpec
                 * @static
                 * @param {nebulaidl.core.IQualityOfServiceSpec=} [properties] Properties to set
                 * @returns {nebulaidl.core.QualityOfServiceSpec} QualityOfServiceSpec instance
                 */
                QualityOfServiceSpec.create = function create(properties) {
                    return new QualityOfServiceSpec(properties);
                };
    
                /**
                 * Encodes the specified QualityOfServiceSpec message. Does not implicitly {@link nebulaidl.core.QualityOfServiceSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.QualityOfServiceSpec
                 * @static
                 * @param {nebulaidl.core.IQualityOfServiceSpec} message QualityOfServiceSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QualityOfServiceSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.queueingBudget != null && message.hasOwnProperty("queueingBudget"))
                        $root.google.protobuf.Duration.encode(message.queueingBudget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a QualityOfServiceSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.QualityOfServiceSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.QualityOfServiceSpec} QualityOfServiceSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QualityOfServiceSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.QualityOfServiceSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.queueingBudget = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a QualityOfServiceSpec message.
                 * @function verify
                 * @memberof nebulaidl.core.QualityOfServiceSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QualityOfServiceSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.queueingBudget != null && message.hasOwnProperty("queueingBudget")) {
                        var error = $root.google.protobuf.Duration.verify(message.queueingBudget);
                        if (error)
                            return "queueingBudget." + error;
                    }
                    return null;
                };
    
                return QualityOfServiceSpec;
            })();
    
            core.QualityOfService = (function() {
    
                /**
                 * Properties of a QualityOfService.
                 * @memberof nebulaidl.core
                 * @interface IQualityOfService
                 * @property {nebulaidl.core.QualityOfService.Tier|null} [tier] QualityOfService tier
                 * @property {nebulaidl.core.IQualityOfServiceSpec|null} [spec] QualityOfService spec
                 */
    
                /**
                 * Constructs a new QualityOfService.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a QualityOfService.
                 * @implements IQualityOfService
                 * @constructor
                 * @param {nebulaidl.core.IQualityOfService=} [properties] Properties to set
                 */
                function QualityOfService(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QualityOfService tier.
                 * @member {nebulaidl.core.QualityOfService.Tier} tier
                 * @memberof nebulaidl.core.QualityOfService
                 * @instance
                 */
                QualityOfService.prototype.tier = 0;
    
                /**
                 * QualityOfService spec.
                 * @member {nebulaidl.core.IQualityOfServiceSpec|null|undefined} spec
                 * @memberof nebulaidl.core.QualityOfService
                 * @instance
                 */
                QualityOfService.prototype.spec = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * QualityOfService designation.
                 * @member {"tier"|"spec"|undefined} designation
                 * @memberof nebulaidl.core.QualityOfService
                 * @instance
                 */
                Object.defineProperty(QualityOfService.prototype, "designation", {
                    get: $util.oneOfGetter($oneOfFields = ["tier", "spec"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new QualityOfService instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.QualityOfService
                 * @static
                 * @param {nebulaidl.core.IQualityOfService=} [properties] Properties to set
                 * @returns {nebulaidl.core.QualityOfService} QualityOfService instance
                 */
                QualityOfService.create = function create(properties) {
                    return new QualityOfService(properties);
                };
    
                /**
                 * Encodes the specified QualityOfService message. Does not implicitly {@link nebulaidl.core.QualityOfService.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.QualityOfService
                 * @static
                 * @param {nebulaidl.core.IQualityOfService} message QualityOfService message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QualityOfService.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tier != null && message.hasOwnProperty("tier"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tier);
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.core.QualityOfServiceSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a QualityOfService message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.QualityOfService
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.QualityOfService} QualityOfService
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QualityOfService.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.QualityOfService();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.tier = reader.int32();
                            break;
                        case 2:
                            message.spec = $root.nebulaidl.core.QualityOfServiceSpec.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a QualityOfService message.
                 * @function verify
                 * @memberof nebulaidl.core.QualityOfService
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QualityOfService.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.tier != null && message.hasOwnProperty("tier")) {
                        properties.designation = 1;
                        switch (message.tier) {
                        default:
                            return "tier: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        if (properties.designation === 1)
                            return "designation: multiple values";
                        properties.designation = 1;
                        {
                            var error = $root.nebulaidl.core.QualityOfServiceSpec.verify(message.spec);
                            if (error)
                                return "spec." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Tier enum.
                 * @name nebulaidl.core.QualityOfService.Tier
                 * @enum {string}
                 * @property {number} UNDEFINED=0 UNDEFINED value
                 * @property {number} HIGH=1 HIGH value
                 * @property {number} MEDIUM=2 MEDIUM value
                 * @property {number} LOW=3 LOW value
                 */
                QualityOfService.Tier = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "HIGH"] = 1;
                    values[valuesById[2] = "MEDIUM"] = 2;
                    values[valuesById[3] = "LOW"] = 3;
                    return values;
                })();
    
                return QualityOfService;
            })();
    
            core.Variable = (function() {
    
                /**
                 * Properties of a Variable.
                 * @memberof nebulaidl.core
                 * @interface IVariable
                 * @property {nebulaidl.core.ILiteralType|null} [type] Variable type
                 * @property {string|null} [description] Variable description
                 */
    
                /**
                 * Constructs a new Variable.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Variable.
                 * @implements IVariable
                 * @constructor
                 * @param {nebulaidl.core.IVariable=} [properties] Properties to set
                 */
                function Variable(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Variable type.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} type
                 * @memberof nebulaidl.core.Variable
                 * @instance
                 */
                Variable.prototype.type = null;
    
                /**
                 * Variable description.
                 * @member {string} description
                 * @memberof nebulaidl.core.Variable
                 * @instance
                 */
                Variable.prototype.description = "";
    
                /**
                 * Creates a new Variable instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Variable
                 * @static
                 * @param {nebulaidl.core.IVariable=} [properties] Properties to set
                 * @returns {nebulaidl.core.Variable} Variable instance
                 */
                Variable.create = function create(properties) {
                    return new Variable(properties);
                };
    
                /**
                 * Encodes the specified Variable message. Does not implicitly {@link nebulaidl.core.Variable.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Variable
                 * @static
                 * @param {nebulaidl.core.IVariable} message Variable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Variable.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.LiteralType.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    return writer;
                };
    
                /**
                 * Decodes a Variable message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Variable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Variable} Variable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Variable.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Variable();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Variable message.
                 * @function verify
                 * @memberof nebulaidl.core.Variable
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Variable.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.LiteralType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };
    
                return Variable;
            })();
    
            core.VariableMap = (function() {
    
                /**
                 * Properties of a VariableMap.
                 * @memberof nebulaidl.core
                 * @interface IVariableMap
                 * @property {Object.<string,nebulaidl.core.IVariable>|null} [variables] VariableMap variables
                 */
    
                /**
                 * Constructs a new VariableMap.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a VariableMap.
                 * @implements IVariableMap
                 * @constructor
                 * @param {nebulaidl.core.IVariableMap=} [properties] Properties to set
                 */
                function VariableMap(properties) {
                    this.variables = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * VariableMap variables.
                 * @member {Object.<string,nebulaidl.core.IVariable>} variables
                 * @memberof nebulaidl.core.VariableMap
                 * @instance
                 */
                VariableMap.prototype.variables = $util.emptyObject;
    
                /**
                 * Creates a new VariableMap instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.VariableMap
                 * @static
                 * @param {nebulaidl.core.IVariableMap=} [properties] Properties to set
                 * @returns {nebulaidl.core.VariableMap} VariableMap instance
                 */
                VariableMap.create = function create(properties) {
                    return new VariableMap(properties);
                };
    
                /**
                 * Encodes the specified VariableMap message. Does not implicitly {@link nebulaidl.core.VariableMap.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.VariableMap
                 * @static
                 * @param {nebulaidl.core.IVariableMap} message VariableMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VariableMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.variables != null && message.hasOwnProperty("variables"))
                        for (var keys = Object.keys(message.variables), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.nebulaidl.core.Variable.encode(message.variables[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Decodes a VariableMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.VariableMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.VariableMap} VariableMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VariableMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.VariableMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.variables === $util.emptyObject)
                                message.variables = {};
                            key = reader.string();
                            reader.pos++;
                            message.variables[key] = $root.nebulaidl.core.Variable.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a VariableMap message.
                 * @function verify
                 * @memberof nebulaidl.core.VariableMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VariableMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.variables != null && message.hasOwnProperty("variables")) {
                        if (!$util.isObject(message.variables))
                            return "variables: object expected";
                        var key = Object.keys(message.variables);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.nebulaidl.core.Variable.verify(message.variables[key[i]]);
                            if (error)
                                return "variables." + error;
                        }
                    }
                    return null;
                };
    
                return VariableMap;
            })();
    
            core.TypedInterface = (function() {
    
                /**
                 * Properties of a TypedInterface.
                 * @memberof nebulaidl.core
                 * @interface ITypedInterface
                 * @property {nebulaidl.core.IVariableMap|null} [inputs] TypedInterface inputs
                 * @property {nebulaidl.core.IVariableMap|null} [outputs] TypedInterface outputs
                 */
    
                /**
                 * Constructs a new TypedInterface.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TypedInterface.
                 * @implements ITypedInterface
                 * @constructor
                 * @param {nebulaidl.core.ITypedInterface=} [properties] Properties to set
                 */
                function TypedInterface(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TypedInterface inputs.
                 * @member {nebulaidl.core.IVariableMap|null|undefined} inputs
                 * @memberof nebulaidl.core.TypedInterface
                 * @instance
                 */
                TypedInterface.prototype.inputs = null;
    
                /**
                 * TypedInterface outputs.
                 * @member {nebulaidl.core.IVariableMap|null|undefined} outputs
                 * @memberof nebulaidl.core.TypedInterface
                 * @instance
                 */
                TypedInterface.prototype.outputs = null;
    
                /**
                 * Creates a new TypedInterface instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TypedInterface
                 * @static
                 * @param {nebulaidl.core.ITypedInterface=} [properties] Properties to set
                 * @returns {nebulaidl.core.TypedInterface} TypedInterface instance
                 */
                TypedInterface.create = function create(properties) {
                    return new TypedInterface(properties);
                };
    
                /**
                 * Encodes the specified TypedInterface message. Does not implicitly {@link nebulaidl.core.TypedInterface.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TypedInterface
                 * @static
                 * @param {nebulaidl.core.ITypedInterface} message TypedInterface message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TypedInterface.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.core.VariableMap.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.core.VariableMap.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TypedInterface message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TypedInterface
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TypedInterface} TypedInterface
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TypedInterface.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TypedInterface();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputs = $root.nebulaidl.core.VariableMap.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.outputs = $root.nebulaidl.core.VariableMap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TypedInterface message.
                 * @function verify
                 * @memberof nebulaidl.core.TypedInterface
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TypedInterface.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.core.VariableMap.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        var error = $root.nebulaidl.core.VariableMap.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                    return null;
                };
    
                return TypedInterface;
            })();
    
            core.Parameter = (function() {
    
                /**
                 * Properties of a Parameter.
                 * @memberof nebulaidl.core
                 * @interface IParameter
                 * @property {nebulaidl.core.IVariable|null} ["var"] Parameter var
                 * @property {nebulaidl.core.ILiteral|null} ["default"] Parameter default
                 * @property {boolean|null} [required] Parameter required
                 */
    
                /**
                 * Constructs a new Parameter.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Parameter.
                 * @implements IParameter
                 * @constructor
                 * @param {nebulaidl.core.IParameter=} [properties] Properties to set
                 */
                function Parameter(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Parameter var.
                 * @member {nebulaidl.core.IVariable|null|undefined} var
                 * @memberof nebulaidl.core.Parameter
                 * @instance
                 */
                Parameter.prototype["var"] = null;
    
                /**
                 * Parameter default.
                 * @member {nebulaidl.core.ILiteral|null|undefined} default
                 * @memberof nebulaidl.core.Parameter
                 * @instance
                 */
                Parameter.prototype["default"] = null;
    
                /**
                 * Parameter required.
                 * @member {boolean} required
                 * @memberof nebulaidl.core.Parameter
                 * @instance
                 */
                Parameter.prototype.required = false;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Parameter behavior.
                 * @member {"default"|"required"|undefined} behavior
                 * @memberof nebulaidl.core.Parameter
                 * @instance
                 */
                Object.defineProperty(Parameter.prototype, "behavior", {
                    get: $util.oneOfGetter($oneOfFields = ["default", "required"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Parameter instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Parameter
                 * @static
                 * @param {nebulaidl.core.IParameter=} [properties] Properties to set
                 * @returns {nebulaidl.core.Parameter} Parameter instance
                 */
                Parameter.create = function create(properties) {
                    return new Parameter(properties);
                };
    
                /**
                 * Encodes the specified Parameter message. Does not implicitly {@link nebulaidl.core.Parameter.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Parameter
                 * @static
                 * @param {nebulaidl.core.IParameter} message Parameter message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Parameter.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["var"] != null && message.hasOwnProperty("var"))
                        $root.nebulaidl.core.Variable.encode(message["var"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message["default"] != null && message.hasOwnProperty("default"))
                        $root.nebulaidl.core.Literal.encode(message["default"], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.required != null && message.hasOwnProperty("required"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.required);
                    return writer;
                };
    
                /**
                 * Decodes a Parameter message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Parameter
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Parameter} Parameter
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Parameter.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Parameter();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["var"] = $root.nebulaidl.core.Variable.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message["default"] = $root.nebulaidl.core.Literal.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.required = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Parameter message.
                 * @function verify
                 * @memberof nebulaidl.core.Parameter
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Parameter.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message["var"] != null && message.hasOwnProperty("var")) {
                        var error = $root.nebulaidl.core.Variable.verify(message["var"]);
                        if (error)
                            return "var." + error;
                    }
                    if (message["default"] != null && message.hasOwnProperty("default")) {
                        properties.behavior = 1;
                        {
                            var error = $root.nebulaidl.core.Literal.verify(message["default"]);
                            if (error)
                                return "default." + error;
                        }
                    }
                    if (message.required != null && message.hasOwnProperty("required")) {
                        if (properties.behavior === 1)
                            return "behavior: multiple values";
                        properties.behavior = 1;
                        if (typeof message.required !== "boolean")
                            return "required: boolean expected";
                    }
                    return null;
                };
    
                return Parameter;
            })();
    
            core.ParameterMap = (function() {
    
                /**
                 * Properties of a ParameterMap.
                 * @memberof nebulaidl.core
                 * @interface IParameterMap
                 * @property {Object.<string,nebulaidl.core.IParameter>|null} [parameters] ParameterMap parameters
                 */
    
                /**
                 * Constructs a new ParameterMap.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a ParameterMap.
                 * @implements IParameterMap
                 * @constructor
                 * @param {nebulaidl.core.IParameterMap=} [properties] Properties to set
                 */
                function ParameterMap(properties) {
                    this.parameters = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ParameterMap parameters.
                 * @member {Object.<string,nebulaidl.core.IParameter>} parameters
                 * @memberof nebulaidl.core.ParameterMap
                 * @instance
                 */
                ParameterMap.prototype.parameters = $util.emptyObject;
    
                /**
                 * Creates a new ParameterMap instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ParameterMap
                 * @static
                 * @param {nebulaidl.core.IParameterMap=} [properties] Properties to set
                 * @returns {nebulaidl.core.ParameterMap} ParameterMap instance
                 */
                ParameterMap.create = function create(properties) {
                    return new ParameterMap(properties);
                };
    
                /**
                 * Encodes the specified ParameterMap message. Does not implicitly {@link nebulaidl.core.ParameterMap.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ParameterMap
                 * @static
                 * @param {nebulaidl.core.IParameterMap} message ParameterMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParameterMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.parameters != null && message.hasOwnProperty("parameters"))
                        for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.nebulaidl.core.Parameter.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Decodes a ParameterMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ParameterMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ParameterMap} ParameterMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParameterMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ParameterMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.parameters === $util.emptyObject)
                                message.parameters = {};
                            key = reader.string();
                            reader.pos++;
                            message.parameters[key] = $root.nebulaidl.core.Parameter.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ParameterMap message.
                 * @function verify
                 * @memberof nebulaidl.core.ParameterMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ParameterMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!$util.isObject(message.parameters))
                            return "parameters: object expected";
                        var key = Object.keys(message.parameters);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.nebulaidl.core.Parameter.verify(message.parameters[key[i]]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    return null;
                };
    
                return ParameterMap;
            })();
    
            core.Resources = (function() {
    
                /**
                 * Properties of a Resources.
                 * @memberof nebulaidl.core
                 * @interface IResources
                 * @property {Array.<nebulaidl.core.Resources.IResourceEntry>|null} [requests] Resources requests
                 * @property {Array.<nebulaidl.core.Resources.IResourceEntry>|null} [limits] Resources limits
                 */
    
                /**
                 * Constructs a new Resources.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Resources.
                 * @implements IResources
                 * @constructor
                 * @param {nebulaidl.core.IResources=} [properties] Properties to set
                 */
                function Resources(properties) {
                    this.requests = [];
                    this.limits = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Resources requests.
                 * @member {Array.<nebulaidl.core.Resources.IResourceEntry>} requests
                 * @memberof nebulaidl.core.Resources
                 * @instance
                 */
                Resources.prototype.requests = $util.emptyArray;
    
                /**
                 * Resources limits.
                 * @member {Array.<nebulaidl.core.Resources.IResourceEntry>} limits
                 * @memberof nebulaidl.core.Resources
                 * @instance
                 */
                Resources.prototype.limits = $util.emptyArray;
    
                /**
                 * Creates a new Resources instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Resources
                 * @static
                 * @param {nebulaidl.core.IResources=} [properties] Properties to set
                 * @returns {nebulaidl.core.Resources} Resources instance
                 */
                Resources.create = function create(properties) {
                    return new Resources(properties);
                };
    
                /**
                 * Encodes the specified Resources message. Does not implicitly {@link nebulaidl.core.Resources.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Resources
                 * @static
                 * @param {nebulaidl.core.IResources} message Resources message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Resources.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requests != null && message.requests.length)
                        for (var i = 0; i < message.requests.length; ++i)
                            $root.nebulaidl.core.Resources.ResourceEntry.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limits != null && message.limits.length)
                        for (var i = 0; i < message.limits.length; ++i)
                            $root.nebulaidl.core.Resources.ResourceEntry.encode(message.limits[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Resources message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Resources
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Resources} Resources
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Resources.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Resources();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.requests && message.requests.length))
                                message.requests = [];
                            message.requests.push($root.nebulaidl.core.Resources.ResourceEntry.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.limits && message.limits.length))
                                message.limits = [];
                            message.limits.push($root.nebulaidl.core.Resources.ResourceEntry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Resources message.
                 * @function verify
                 * @memberof nebulaidl.core.Resources
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Resources.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requests != null && message.hasOwnProperty("requests")) {
                        if (!Array.isArray(message.requests))
                            return "requests: array expected";
                        for (var i = 0; i < message.requests.length; ++i) {
                            var error = $root.nebulaidl.core.Resources.ResourceEntry.verify(message.requests[i]);
                            if (error)
                                return "requests." + error;
                        }
                    }
                    if (message.limits != null && message.hasOwnProperty("limits")) {
                        if (!Array.isArray(message.limits))
                            return "limits: array expected";
                        for (var i = 0; i < message.limits.length; ++i) {
                            var error = $root.nebulaidl.core.Resources.ResourceEntry.verify(message.limits[i]);
                            if (error)
                                return "limits." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * ResourceName enum.
                 * @name nebulaidl.core.Resources.ResourceName
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} CPU=1 CPU value
                 * @property {number} GPU=2 GPU value
                 * @property {number} MEMORY=3 MEMORY value
                 * @property {number} STORAGE=4 STORAGE value
                 * @property {number} EPHEMERAL_STORAGE=5 EPHEMERAL_STORAGE value
                 */
                Resources.ResourceName = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "CPU"] = 1;
                    values[valuesById[2] = "GPU"] = 2;
                    values[valuesById[3] = "MEMORY"] = 3;
                    values[valuesById[4] = "STORAGE"] = 4;
                    values[valuesById[5] = "EPHEMERAL_STORAGE"] = 5;
                    return values;
                })();
    
                Resources.ResourceEntry = (function() {
    
                    /**
                     * Properties of a ResourceEntry.
                     * @memberof nebulaidl.core.Resources
                     * @interface IResourceEntry
                     * @property {nebulaidl.core.Resources.ResourceName|null} [name] ResourceEntry name
                     * @property {string|null} [value] ResourceEntry value
                     */
    
                    /**
                     * Constructs a new ResourceEntry.
                     * @memberof nebulaidl.core.Resources
                     * @classdesc Represents a ResourceEntry.
                     * @implements IResourceEntry
                     * @constructor
                     * @param {nebulaidl.core.Resources.IResourceEntry=} [properties] Properties to set
                     */
                    function ResourceEntry(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ResourceEntry name.
                     * @member {nebulaidl.core.Resources.ResourceName} name
                     * @memberof nebulaidl.core.Resources.ResourceEntry
                     * @instance
                     */
                    ResourceEntry.prototype.name = 0;
    
                    /**
                     * ResourceEntry value.
                     * @member {string} value
                     * @memberof nebulaidl.core.Resources.ResourceEntry
                     * @instance
                     */
                    ResourceEntry.prototype.value = "";
    
                    /**
                     * Creates a new ResourceEntry instance using the specified properties.
                     * @function create
                     * @memberof nebulaidl.core.Resources.ResourceEntry
                     * @static
                     * @param {nebulaidl.core.Resources.IResourceEntry=} [properties] Properties to set
                     * @returns {nebulaidl.core.Resources.ResourceEntry} ResourceEntry instance
                     */
                    ResourceEntry.create = function create(properties) {
                        return new ResourceEntry(properties);
                    };
    
                    /**
                     * Encodes the specified ResourceEntry message. Does not implicitly {@link nebulaidl.core.Resources.ResourceEntry.verify|verify} messages.
                     * @function encode
                     * @memberof nebulaidl.core.Resources.ResourceEntry
                     * @static
                     * @param {nebulaidl.core.Resources.IResourceEntry} message ResourceEntry message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ResourceEntry.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                        return writer;
                    };
    
                    /**
                     * Decodes a ResourceEntry message from the specified reader or buffer.
                     * @function decode
                     * @memberof nebulaidl.core.Resources.ResourceEntry
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {nebulaidl.core.Resources.ResourceEntry} ResourceEntry
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ResourceEntry.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Resources.ResourceEntry();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.int32();
                                break;
                            case 2:
                                message.value = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ResourceEntry message.
                     * @function verify
                     * @memberof nebulaidl.core.Resources.ResourceEntry
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ResourceEntry.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            switch (message.name) {
                            default:
                                return "name: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        return null;
                    };
    
                    return ResourceEntry;
                })();
    
                return Resources;
            })();
    
            core.RuntimeMetadata = (function() {
    
                /**
                 * Properties of a RuntimeMetadata.
                 * @memberof nebulaidl.core
                 * @interface IRuntimeMetadata
                 * @property {nebulaidl.core.RuntimeMetadata.RuntimeType|null} [type] RuntimeMetadata type
                 * @property {string|null} [version] RuntimeMetadata version
                 * @property {string|null} [flavor] RuntimeMetadata flavor
                 */
    
                /**
                 * Constructs a new RuntimeMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a RuntimeMetadata.
                 * @implements IRuntimeMetadata
                 * @constructor
                 * @param {nebulaidl.core.IRuntimeMetadata=} [properties] Properties to set
                 */
                function RuntimeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RuntimeMetadata type.
                 * @member {nebulaidl.core.RuntimeMetadata.RuntimeType} type
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @instance
                 */
                RuntimeMetadata.prototype.type = 0;
    
                /**
                 * RuntimeMetadata version.
                 * @member {string} version
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @instance
                 */
                RuntimeMetadata.prototype.version = "";
    
                /**
                 * RuntimeMetadata flavor.
                 * @member {string} flavor
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @instance
                 */
                RuntimeMetadata.prototype.flavor = "";
    
                /**
                 * Creates a new RuntimeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @static
                 * @param {nebulaidl.core.IRuntimeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.RuntimeMetadata} RuntimeMetadata instance
                 */
                RuntimeMetadata.create = function create(properties) {
                    return new RuntimeMetadata(properties);
                };
    
                /**
                 * Encodes the specified RuntimeMetadata message. Does not implicitly {@link nebulaidl.core.RuntimeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @static
                 * @param {nebulaidl.core.IRuntimeMetadata} message RuntimeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RuntimeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.version != null && message.hasOwnProperty("version"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                    if (message.flavor != null && message.hasOwnProperty("flavor"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.flavor);
                    return writer;
                };
    
                /**
                 * Decodes a RuntimeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.RuntimeMetadata} RuntimeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RuntimeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.RuntimeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.version = reader.string();
                            break;
                        case 3:
                            message.flavor = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a RuntimeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.RuntimeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RuntimeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    if (message.flavor != null && message.hasOwnProperty("flavor"))
                        if (!$util.isString(message.flavor))
                            return "flavor: string expected";
                    return null;
                };
    
                /**
                 * RuntimeType enum.
                 * @name nebulaidl.core.RuntimeMetadata.RuntimeType
                 * @enum {string}
                 * @property {number} OTHER=0 OTHER value
                 * @property {number} NEBULA_SDK=1 NEBULA_SDK value
                 */
                RuntimeMetadata.RuntimeType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "OTHER"] = 0;
                    values[valuesById[1] = "NEBULA_SDK"] = 1;
                    return values;
                })();
    
                return RuntimeMetadata;
            })();
    
            core.TaskMetadata = (function() {
    
                /**
                 * Properties of a TaskMetadata.
                 * @memberof nebulaidl.core
                 * @interface ITaskMetadata
                 * @property {boolean|null} [discoverable] TaskMetadata discoverable
                 * @property {nebulaidl.core.IRuntimeMetadata|null} [runtime] TaskMetadata runtime
                 * @property {google.protobuf.IDuration|null} [timeout] TaskMetadata timeout
                 * @property {nebulaidl.core.IRetryStrategy|null} [retries] TaskMetadata retries
                 * @property {string|null} [discoveryVersion] TaskMetadata discoveryVersion
                 * @property {string|null} [deprecatedErrorMessage] TaskMetadata deprecatedErrorMessage
                 * @property {boolean|null} [interruptible] TaskMetadata interruptible
                 * @property {boolean|null} [cacheSerializable] TaskMetadata cacheSerializable
                 * @property {boolean|null} [generatesDeck] TaskMetadata generatesDeck
                 * @property {Object.<string,string>|null} [tags] TaskMetadata tags
                 * @property {string|null} [podTemplateName] TaskMetadata podTemplateName
                 */
    
                /**
                 * Constructs a new TaskMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskMetadata.
                 * @implements ITaskMetadata
                 * @constructor
                 * @param {nebulaidl.core.ITaskMetadata=} [properties] Properties to set
                 */
                function TaskMetadata(properties) {
                    this.tags = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskMetadata discoverable.
                 * @member {boolean} discoverable
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.discoverable = false;
    
                /**
                 * TaskMetadata runtime.
                 * @member {nebulaidl.core.IRuntimeMetadata|null|undefined} runtime
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.runtime = null;
    
                /**
                 * TaskMetadata timeout.
                 * @member {google.protobuf.IDuration|null|undefined} timeout
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.timeout = null;
    
                /**
                 * TaskMetadata retries.
                 * @member {nebulaidl.core.IRetryStrategy|null|undefined} retries
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.retries = null;
    
                /**
                 * TaskMetadata discoveryVersion.
                 * @member {string} discoveryVersion
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.discoveryVersion = "";
    
                /**
                 * TaskMetadata deprecatedErrorMessage.
                 * @member {string} deprecatedErrorMessage
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.deprecatedErrorMessage = "";
    
                /**
                 * TaskMetadata interruptible.
                 * @member {boolean} interruptible
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.interruptible = false;
    
                /**
                 * TaskMetadata cacheSerializable.
                 * @member {boolean} cacheSerializable
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.cacheSerializable = false;
    
                /**
                 * TaskMetadata generatesDeck.
                 * @member {boolean} generatesDeck
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.generatesDeck = false;
    
                /**
                 * TaskMetadata tags.
                 * @member {Object.<string,string>} tags
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.tags = $util.emptyObject;
    
                /**
                 * TaskMetadata podTemplateName.
                 * @member {string} podTemplateName
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                TaskMetadata.prototype.podTemplateName = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * TaskMetadata interruptibleValue.
                 * @member {"interruptible"|undefined} interruptibleValue
                 * @memberof nebulaidl.core.TaskMetadata
                 * @instance
                 */
                Object.defineProperty(TaskMetadata.prototype, "interruptibleValue", {
                    get: $util.oneOfGetter($oneOfFields = ["interruptible"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new TaskMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskMetadata
                 * @static
                 * @param {nebulaidl.core.ITaskMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskMetadata} TaskMetadata instance
                 */
                TaskMetadata.create = function create(properties) {
                    return new TaskMetadata(properties);
                };
    
                /**
                 * Encodes the specified TaskMetadata message. Does not implicitly {@link nebulaidl.core.TaskMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskMetadata
                 * @static
                 * @param {nebulaidl.core.ITaskMetadata} message TaskMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.discoverable != null && message.hasOwnProperty("discoverable"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.discoverable);
                    if (message.runtime != null && message.hasOwnProperty("runtime"))
                        $root.nebulaidl.core.RuntimeMetadata.encode(message.runtime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.timeout != null && message.hasOwnProperty("timeout"))
                        $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.retries != null && message.hasOwnProperty("retries"))
                        $root.nebulaidl.core.RetryStrategy.encode(message.retries, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.discoveryVersion != null && message.hasOwnProperty("discoveryVersion"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.discoveryVersion);
                    if (message.deprecatedErrorMessage != null && message.hasOwnProperty("deprecatedErrorMessage"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.deprecatedErrorMessage);
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.interruptible);
                    if (message.cacheSerializable != null && message.hasOwnProperty("cacheSerializable"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.cacheSerializable);
                    if (message.generatesDeck != null && message.hasOwnProperty("generatesDeck"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.generatesDeck);
                    if (message.tags != null && message.hasOwnProperty("tags"))
                        for (var keys = Object.keys(message.tags), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.tags[keys[i]]).ldelim();
                    if (message.podTemplateName != null && message.hasOwnProperty("podTemplateName"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.podTemplateName);
                    return writer;
                };
    
                /**
                 * Decodes a TaskMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskMetadata} TaskMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskMetadata(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.discoverable = reader.bool();
                            break;
                        case 2:
                            message.runtime = $root.nebulaidl.core.RuntimeMetadata.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.retries = $root.nebulaidl.core.RetryStrategy.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.discoveryVersion = reader.string();
                            break;
                        case 7:
                            message.deprecatedErrorMessage = reader.string();
                            break;
                        case 8:
                            message.interruptible = reader.bool();
                            break;
                        case 9:
                            message.cacheSerializable = reader.bool();
                            break;
                        case 10:
                            message.generatesDeck = reader.bool();
                            break;
                        case 11:
                            reader.skip().pos++;
                            if (message.tags === $util.emptyObject)
                                message.tags = {};
                            key = reader.string();
                            reader.pos++;
                            message.tags[key] = reader.string();
                            break;
                        case 12:
                            message.podTemplateName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.discoverable != null && message.hasOwnProperty("discoverable"))
                        if (typeof message.discoverable !== "boolean")
                            return "discoverable: boolean expected";
                    if (message.runtime != null && message.hasOwnProperty("runtime")) {
                        var error = $root.nebulaidl.core.RuntimeMetadata.verify(message.runtime);
                        if (error)
                            return "runtime." + error;
                    }
                    if (message.timeout != null && message.hasOwnProperty("timeout")) {
                        var error = $root.google.protobuf.Duration.verify(message.timeout);
                        if (error)
                            return "timeout." + error;
                    }
                    if (message.retries != null && message.hasOwnProperty("retries")) {
                        var error = $root.nebulaidl.core.RetryStrategy.verify(message.retries);
                        if (error)
                            return "retries." + error;
                    }
                    if (message.discoveryVersion != null && message.hasOwnProperty("discoveryVersion"))
                        if (!$util.isString(message.discoveryVersion))
                            return "discoveryVersion: string expected";
                    if (message.deprecatedErrorMessage != null && message.hasOwnProperty("deprecatedErrorMessage"))
                        if (!$util.isString(message.deprecatedErrorMessage))
                            return "deprecatedErrorMessage: string expected";
                    if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                        properties.interruptibleValue = 1;
                        if (typeof message.interruptible !== "boolean")
                            return "interruptible: boolean expected";
                    }
                    if (message.cacheSerializable != null && message.hasOwnProperty("cacheSerializable"))
                        if (typeof message.cacheSerializable !== "boolean")
                            return "cacheSerializable: boolean expected";
                    if (message.generatesDeck != null && message.hasOwnProperty("generatesDeck"))
                        if (typeof message.generatesDeck !== "boolean")
                            return "generatesDeck: boolean expected";
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!$util.isObject(message.tags))
                            return "tags: object expected";
                        var key = Object.keys(message.tags);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.tags[key[i]]))
                                return "tags: string{k:string} expected";
                    }
                    if (message.podTemplateName != null && message.hasOwnProperty("podTemplateName"))
                        if (!$util.isString(message.podTemplateName))
                            return "podTemplateName: string expected";
                    return null;
                };
    
                return TaskMetadata;
            })();
    
            core.TaskTemplate = (function() {
    
                /**
                 * Properties of a TaskTemplate.
                 * @memberof nebulaidl.core
                 * @interface ITaskTemplate
                 * @property {nebulaidl.core.IIdentifier|null} [id] TaskTemplate id
                 * @property {string|null} [type] TaskTemplate type
                 * @property {nebulaidl.core.ITaskMetadata|null} [metadata] TaskTemplate metadata
                 * @property {nebulaidl.core.ITypedInterface|null} ["interface"] TaskTemplate interface
                 * @property {google.protobuf.IStruct|null} [custom] TaskTemplate custom
                 * @property {nebulaidl.core.IContainer|null} [container] TaskTemplate container
                 * @property {nebulaidl.core.IK8sPod|null} [k8sPod] TaskTemplate k8sPod
                 * @property {nebulaidl.core.ISql|null} [sql] TaskTemplate sql
                 * @property {number|null} [taskTypeVersion] TaskTemplate taskTypeVersion
                 * @property {nebulaidl.core.ISecurityContext|null} [securityContext] TaskTemplate securityContext
                 * @property {Object.<string,string>|null} [config] TaskTemplate config
                 */
    
                /**
                 * Constructs a new TaskTemplate.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a TaskTemplate.
                 * @implements ITaskTemplate
                 * @constructor
                 * @param {nebulaidl.core.ITaskTemplate=} [properties] Properties to set
                 */
                function TaskTemplate(properties) {
                    this.config = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskTemplate id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.id = null;
    
                /**
                 * TaskTemplate type.
                 * @member {string} type
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.type = "";
    
                /**
                 * TaskTemplate metadata.
                 * @member {nebulaidl.core.ITaskMetadata|null|undefined} metadata
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.metadata = null;
    
                /**
                 * TaskTemplate interface.
                 * @member {nebulaidl.core.ITypedInterface|null|undefined} interface
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype["interface"] = null;
    
                /**
                 * TaskTemplate custom.
                 * @member {google.protobuf.IStruct|null|undefined} custom
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.custom = null;
    
                /**
                 * TaskTemplate container.
                 * @member {nebulaidl.core.IContainer|null|undefined} container
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.container = null;
    
                /**
                 * TaskTemplate k8sPod.
                 * @member {nebulaidl.core.IK8sPod|null|undefined} k8sPod
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.k8sPod = null;
    
                /**
                 * TaskTemplate sql.
                 * @member {nebulaidl.core.ISql|null|undefined} sql
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.sql = null;
    
                /**
                 * TaskTemplate taskTypeVersion.
                 * @member {number} taskTypeVersion
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.taskTypeVersion = 0;
    
                /**
                 * TaskTemplate securityContext.
                 * @member {nebulaidl.core.ISecurityContext|null|undefined} securityContext
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.securityContext = null;
    
                /**
                 * TaskTemplate config.
                 * @member {Object.<string,string>} config
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                TaskTemplate.prototype.config = $util.emptyObject;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * TaskTemplate target.
                 * @member {"container"|"k8sPod"|"sql"|undefined} target
                 * @memberof nebulaidl.core.TaskTemplate
                 * @instance
                 */
                Object.defineProperty(TaskTemplate.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["container", "k8sPod", "sql"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new TaskTemplate instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.TaskTemplate
                 * @static
                 * @param {nebulaidl.core.ITaskTemplate=} [properties] Properties to set
                 * @returns {nebulaidl.core.TaskTemplate} TaskTemplate instance
                 */
                TaskTemplate.create = function create(properties) {
                    return new TaskTemplate(properties);
                };
    
                /**
                 * Encodes the specified TaskTemplate message. Does not implicitly {@link nebulaidl.core.TaskTemplate.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.TaskTemplate
                 * @static
                 * @param {nebulaidl.core.ITaskTemplate} message TaskTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskTemplate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.core.TaskMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message["interface"] != null && message.hasOwnProperty("interface"))
                        $root.nebulaidl.core.TypedInterface.encode(message["interface"], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.custom != null && message.hasOwnProperty("custom"))
                        $root.google.protobuf.Struct.encode(message.custom, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.container != null && message.hasOwnProperty("container"))
                        $root.nebulaidl.core.Container.encode(message.container, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.taskTypeVersion != null && message.hasOwnProperty("taskTypeVersion"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.taskTypeVersion);
                    if (message.securityContext != null && message.hasOwnProperty("securityContext"))
                        $root.nebulaidl.core.SecurityContext.encode(message.securityContext, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.config != null && message.hasOwnProperty("config"))
                        for (var keys = Object.keys(message.config), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 16, wireType 2 =*/130).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.config[keys[i]]).ldelim();
                    if (message.k8sPod != null && message.hasOwnProperty("k8sPod"))
                        $root.nebulaidl.core.K8sPod.encode(message.k8sPod, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.sql != null && message.hasOwnProperty("sql"))
                        $root.nebulaidl.core.Sql.encode(message.sql, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskTemplate message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.TaskTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.TaskTemplate} TaskTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskTemplate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.TaskTemplate(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.type = reader.string();
                            break;
                        case 3:
                            message.metadata = $root.nebulaidl.core.TaskMetadata.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message["interface"] = $root.nebulaidl.core.TypedInterface.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.custom = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.container = $root.nebulaidl.core.Container.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.k8sPod = $root.nebulaidl.core.K8sPod.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.sql = $root.nebulaidl.core.Sql.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.taskTypeVersion = reader.int32();
                            break;
                        case 8:
                            message.securityContext = $root.nebulaidl.core.SecurityContext.decode(reader, reader.uint32());
                            break;
                        case 16:
                            reader.skip().pos++;
                            if (message.config === $util.emptyObject)
                                message.config = {};
                            key = reader.string();
                            reader.pos++;
                            message.config[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskTemplate message.
                 * @function verify
                 * @memberof nebulaidl.core.TaskTemplate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskTemplate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.core.TaskMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message["interface"] != null && message.hasOwnProperty("interface")) {
                        var error = $root.nebulaidl.core.TypedInterface.verify(message["interface"]);
                        if (error)
                            return "interface." + error;
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        var error = $root.google.protobuf.Struct.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                    if (message.container != null && message.hasOwnProperty("container")) {
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.Container.verify(message.container);
                            if (error)
                                return "container." + error;
                        }
                    }
                    if (message.k8sPod != null && message.hasOwnProperty("k8sPod")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.K8sPod.verify(message.k8sPod);
                            if (error)
                                return "k8sPod." + error;
                        }
                    }
                    if (message.sql != null && message.hasOwnProperty("sql")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.Sql.verify(message.sql);
                            if (error)
                                return "sql." + error;
                        }
                    }
                    if (message.taskTypeVersion != null && message.hasOwnProperty("taskTypeVersion"))
                        if (!$util.isInteger(message.taskTypeVersion))
                            return "taskTypeVersion: integer expected";
                    if (message.securityContext != null && message.hasOwnProperty("securityContext")) {
                        var error = $root.nebulaidl.core.SecurityContext.verify(message.securityContext);
                        if (error)
                            return "securityContext." + error;
                    }
                    if (message.config != null && message.hasOwnProperty("config")) {
                        if (!$util.isObject(message.config))
                            return "config: object expected";
                        var key = Object.keys(message.config);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.config[key[i]]))
                                return "config: string{k:string} expected";
                    }
                    return null;
                };
    
                return TaskTemplate;
            })();
    
            core.ContainerPort = (function() {
    
                /**
                 * Properties of a ContainerPort.
                 * @memberof nebulaidl.core
                 * @interface IContainerPort
                 * @property {number|null} [containerPort] ContainerPort containerPort
                 */
    
                /**
                 * Constructs a new ContainerPort.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a ContainerPort.
                 * @implements IContainerPort
                 * @constructor
                 * @param {nebulaidl.core.IContainerPort=} [properties] Properties to set
                 */
                function ContainerPort(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ContainerPort containerPort.
                 * @member {number} containerPort
                 * @memberof nebulaidl.core.ContainerPort
                 * @instance
                 */
                ContainerPort.prototype.containerPort = 0;
    
                /**
                 * Creates a new ContainerPort instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ContainerPort
                 * @static
                 * @param {nebulaidl.core.IContainerPort=} [properties] Properties to set
                 * @returns {nebulaidl.core.ContainerPort} ContainerPort instance
                 */
                ContainerPort.create = function create(properties) {
                    return new ContainerPort(properties);
                };
    
                /**
                 * Encodes the specified ContainerPort message. Does not implicitly {@link nebulaidl.core.ContainerPort.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ContainerPort
                 * @static
                 * @param {nebulaidl.core.IContainerPort} message ContainerPort message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ContainerPort.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.containerPort != null && message.hasOwnProperty("containerPort"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.containerPort);
                    return writer;
                };
    
                /**
                 * Decodes a ContainerPort message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ContainerPort
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ContainerPort} ContainerPort
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ContainerPort.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ContainerPort();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.containerPort = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ContainerPort message.
                 * @function verify
                 * @memberof nebulaidl.core.ContainerPort
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ContainerPort.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.containerPort != null && message.hasOwnProperty("containerPort"))
                        if (!$util.isInteger(message.containerPort))
                            return "containerPort: integer expected";
                    return null;
                };
    
                return ContainerPort;
            })();
    
            core.Container = (function() {
    
                /**
                 * Properties of a Container.
                 * @memberof nebulaidl.core
                 * @interface IContainer
                 * @property {string|null} [image] Container image
                 * @property {Array.<string>|null} [command] Container command
                 * @property {Array.<string>|null} [args] Container args
                 * @property {nebulaidl.core.IResources|null} [resources] Container resources
                 * @property {Array.<nebulaidl.core.IKeyValuePair>|null} [env] Container env
                 * @property {Array.<nebulaidl.core.IKeyValuePair>|null} [config] Container config
                 * @property {Array.<nebulaidl.core.IContainerPort>|null} [ports] Container ports
                 * @property {nebulaidl.core.IDataLoadingConfig|null} [dataConfig] Container dataConfig
                 * @property {nebulaidl.core.Container.Architecture|null} [architecture] Container architecture
                 */
    
                /**
                 * Constructs a new Container.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Container.
                 * @implements IContainer
                 * @constructor
                 * @param {nebulaidl.core.IContainer=} [properties] Properties to set
                 */
                function Container(properties) {
                    this.command = [];
                    this.args = [];
                    this.env = [];
                    this.config = [];
                    this.ports = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Container image.
                 * @member {string} image
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.image = "";
    
                /**
                 * Container command.
                 * @member {Array.<string>} command
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.command = $util.emptyArray;
    
                /**
                 * Container args.
                 * @member {Array.<string>} args
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.args = $util.emptyArray;
    
                /**
                 * Container resources.
                 * @member {nebulaidl.core.IResources|null|undefined} resources
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.resources = null;
    
                /**
                 * Container env.
                 * @member {Array.<nebulaidl.core.IKeyValuePair>} env
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.env = $util.emptyArray;
    
                /**
                 * Container config.
                 * @member {Array.<nebulaidl.core.IKeyValuePair>} config
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.config = $util.emptyArray;
    
                /**
                 * Container ports.
                 * @member {Array.<nebulaidl.core.IContainerPort>} ports
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.ports = $util.emptyArray;
    
                /**
                 * Container dataConfig.
                 * @member {nebulaidl.core.IDataLoadingConfig|null|undefined} dataConfig
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.dataConfig = null;
    
                /**
                 * Container architecture.
                 * @member {nebulaidl.core.Container.Architecture} architecture
                 * @memberof nebulaidl.core.Container
                 * @instance
                 */
                Container.prototype.architecture = 0;
    
                /**
                 * Creates a new Container instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Container
                 * @static
                 * @param {nebulaidl.core.IContainer=} [properties] Properties to set
                 * @returns {nebulaidl.core.Container} Container instance
                 */
                Container.create = function create(properties) {
                    return new Container(properties);
                };
    
                /**
                 * Encodes the specified Container message. Does not implicitly {@link nebulaidl.core.Container.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Container
                 * @static
                 * @param {nebulaidl.core.IContainer} message Container message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Container.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.image != null && message.hasOwnProperty("image"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.image);
                    if (message.command != null && message.command.length)
                        for (var i = 0; i < message.command.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.command[i]);
                    if (message.args != null && message.args.length)
                        for (var i = 0; i < message.args.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.args[i]);
                    if (message.resources != null && message.hasOwnProperty("resources"))
                        $root.nebulaidl.core.Resources.encode(message.resources, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.env != null && message.env.length)
                        for (var i = 0; i < message.env.length; ++i)
                            $root.nebulaidl.core.KeyValuePair.encode(message.env[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.config != null && message.config.length)
                        for (var i = 0; i < message.config.length; ++i)
                            $root.nebulaidl.core.KeyValuePair.encode(message.config[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.ports != null && message.ports.length)
                        for (var i = 0; i < message.ports.length; ++i)
                            $root.nebulaidl.core.ContainerPort.encode(message.ports[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.dataConfig != null && message.hasOwnProperty("dataConfig"))
                        $root.nebulaidl.core.DataLoadingConfig.encode(message.dataConfig, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.architecture != null && message.hasOwnProperty("architecture"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.architecture);
                    return writer;
                };
    
                /**
                 * Decodes a Container message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Container
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Container} Container
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Container.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Container();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.image = reader.string();
                            break;
                        case 2:
                            if (!(message.command && message.command.length))
                                message.command = [];
                            message.command.push(reader.string());
                            break;
                        case 3:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push(reader.string());
                            break;
                        case 4:
                            message.resources = $root.nebulaidl.core.Resources.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.env && message.env.length))
                                message.env = [];
                            message.env.push($root.nebulaidl.core.KeyValuePair.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.config && message.config.length))
                                message.config = [];
                            message.config.push($root.nebulaidl.core.KeyValuePair.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.ports && message.ports.length))
                                message.ports = [];
                            message.ports.push($root.nebulaidl.core.ContainerPort.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            message.dataConfig = $root.nebulaidl.core.DataLoadingConfig.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.architecture = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Container message.
                 * @function verify
                 * @memberof nebulaidl.core.Container
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Container.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.image != null && message.hasOwnProperty("image"))
                        if (!$util.isString(message.image))
                            return "image: string expected";
                    if (message.command != null && message.hasOwnProperty("command")) {
                        if (!Array.isArray(message.command))
                            return "command: array expected";
                        for (var i = 0; i < message.command.length; ++i)
                            if (!$util.isString(message.command[i]))
                                return "command: string[] expected";
                    }
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (var i = 0; i < message.args.length; ++i)
                            if (!$util.isString(message.args[i]))
                                return "args: string[] expected";
                    }
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        var error = $root.nebulaidl.core.Resources.verify(message.resources);
                        if (error)
                            return "resources." + error;
                    }
                    if (message.env != null && message.hasOwnProperty("env")) {
                        if (!Array.isArray(message.env))
                            return "env: array expected";
                        for (var i = 0; i < message.env.length; ++i) {
                            var error = $root.nebulaidl.core.KeyValuePair.verify(message.env[i]);
                            if (error)
                                return "env." + error;
                        }
                    }
                    if (message.config != null && message.hasOwnProperty("config")) {
                        if (!Array.isArray(message.config))
                            return "config: array expected";
                        for (var i = 0; i < message.config.length; ++i) {
                            var error = $root.nebulaidl.core.KeyValuePair.verify(message.config[i]);
                            if (error)
                                return "config." + error;
                        }
                    }
                    if (message.ports != null && message.hasOwnProperty("ports")) {
                        if (!Array.isArray(message.ports))
                            return "ports: array expected";
                        for (var i = 0; i < message.ports.length; ++i) {
                            var error = $root.nebulaidl.core.ContainerPort.verify(message.ports[i]);
                            if (error)
                                return "ports." + error;
                        }
                    }
                    if (message.dataConfig != null && message.hasOwnProperty("dataConfig")) {
                        var error = $root.nebulaidl.core.DataLoadingConfig.verify(message.dataConfig);
                        if (error)
                            return "dataConfig." + error;
                    }
                    if (message.architecture != null && message.hasOwnProperty("architecture"))
                        switch (message.architecture) {
                        default:
                            return "architecture: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Architecture enum.
                 * @name nebulaidl.core.Container.Architecture
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} AMD64=1 AMD64 value
                 * @property {number} ARM64=2 ARM64 value
                 * @property {number} ARM_V6=3 ARM_V6 value
                 * @property {number} ARM_V7=4 ARM_V7 value
                 */
                Container.Architecture = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "AMD64"] = 1;
                    values[valuesById[2] = "ARM64"] = 2;
                    values[valuesById[3] = "ARM_V6"] = 3;
                    values[valuesById[4] = "ARM_V7"] = 4;
                    return values;
                })();
    
                return Container;
            })();
    
            core.IOStrategy = (function() {
    
                /**
                 * Properties of a IOStrategy.
                 * @memberof nebulaidl.core
                 * @interface IIOStrategy
                 * @property {nebulaidl.core.IOStrategy.DownloadMode|null} [downloadMode] IOStrategy downloadMode
                 * @property {nebulaidl.core.IOStrategy.UploadMode|null} [uploadMode] IOStrategy uploadMode
                 */
    
                /**
                 * Constructs a new IOStrategy.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a IOStrategy.
                 * @implements IIOStrategy
                 * @constructor
                 * @param {nebulaidl.core.IIOStrategy=} [properties] Properties to set
                 */
                function IOStrategy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IOStrategy downloadMode.
                 * @member {nebulaidl.core.IOStrategy.DownloadMode} downloadMode
                 * @memberof nebulaidl.core.IOStrategy
                 * @instance
                 */
                IOStrategy.prototype.downloadMode = 0;
    
                /**
                 * IOStrategy uploadMode.
                 * @member {nebulaidl.core.IOStrategy.UploadMode} uploadMode
                 * @memberof nebulaidl.core.IOStrategy
                 * @instance
                 */
                IOStrategy.prototype.uploadMode = 0;
    
                /**
                 * Creates a new IOStrategy instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.IOStrategy
                 * @static
                 * @param {nebulaidl.core.IIOStrategy=} [properties] Properties to set
                 * @returns {nebulaidl.core.IOStrategy} IOStrategy instance
                 */
                IOStrategy.create = function create(properties) {
                    return new IOStrategy(properties);
                };
    
                /**
                 * Encodes the specified IOStrategy message. Does not implicitly {@link nebulaidl.core.IOStrategy.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.IOStrategy
                 * @static
                 * @param {nebulaidl.core.IIOStrategy} message IOStrategy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IOStrategy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.downloadMode != null && message.hasOwnProperty("downloadMode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.downloadMode);
                    if (message.uploadMode != null && message.hasOwnProperty("uploadMode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.uploadMode);
                    return writer;
                };
    
                /**
                 * Decodes a IOStrategy message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.IOStrategy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.IOStrategy} IOStrategy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IOStrategy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.IOStrategy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.downloadMode = reader.int32();
                            break;
                        case 2:
                            message.uploadMode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a IOStrategy message.
                 * @function verify
                 * @memberof nebulaidl.core.IOStrategy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IOStrategy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.downloadMode != null && message.hasOwnProperty("downloadMode"))
                        switch (message.downloadMode) {
                        default:
                            return "downloadMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.uploadMode != null && message.hasOwnProperty("uploadMode"))
                        switch (message.uploadMode) {
                        default:
                            return "uploadMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * DownloadMode enum.
                 * @name nebulaidl.core.IOStrategy.DownloadMode
                 * @enum {string}
                 * @property {number} DOWNLOAD_EAGER=0 DOWNLOAD_EAGER value
                 * @property {number} DOWNLOAD_STREAM=1 DOWNLOAD_STREAM value
                 * @property {number} DO_NOT_DOWNLOAD=2 DO_NOT_DOWNLOAD value
                 */
                IOStrategy.DownloadMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DOWNLOAD_EAGER"] = 0;
                    values[valuesById[1] = "DOWNLOAD_STREAM"] = 1;
                    values[valuesById[2] = "DO_NOT_DOWNLOAD"] = 2;
                    return values;
                })();
    
                /**
                 * UploadMode enum.
                 * @name nebulaidl.core.IOStrategy.UploadMode
                 * @enum {string}
                 * @property {number} UPLOAD_ON_EXIT=0 UPLOAD_ON_EXIT value
                 * @property {number} UPLOAD_EAGER=1 UPLOAD_EAGER value
                 * @property {number} DO_NOT_UPLOAD=2 DO_NOT_UPLOAD value
                 */
                IOStrategy.UploadMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UPLOAD_ON_EXIT"] = 0;
                    values[valuesById[1] = "UPLOAD_EAGER"] = 1;
                    values[valuesById[2] = "DO_NOT_UPLOAD"] = 2;
                    return values;
                })();
    
                return IOStrategy;
            })();
    
            core.DataLoadingConfig = (function() {
    
                /**
                 * Properties of a DataLoadingConfig.
                 * @memberof nebulaidl.core
                 * @interface IDataLoadingConfig
                 * @property {boolean|null} [enabled] DataLoadingConfig enabled
                 * @property {string|null} [inputPath] DataLoadingConfig inputPath
                 * @property {string|null} [outputPath] DataLoadingConfig outputPath
                 * @property {nebulaidl.core.DataLoadingConfig.LiteralMapFormat|null} [format] DataLoadingConfig format
                 * @property {nebulaidl.core.IIOStrategy|null} [ioStrategy] DataLoadingConfig ioStrategy
                 */
    
                /**
                 * Constructs a new DataLoadingConfig.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a DataLoadingConfig.
                 * @implements IDataLoadingConfig
                 * @constructor
                 * @param {nebulaidl.core.IDataLoadingConfig=} [properties] Properties to set
                 */
                function DataLoadingConfig(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DataLoadingConfig enabled.
                 * @member {boolean} enabled
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @instance
                 */
                DataLoadingConfig.prototype.enabled = false;
    
                /**
                 * DataLoadingConfig inputPath.
                 * @member {string} inputPath
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @instance
                 */
                DataLoadingConfig.prototype.inputPath = "";
    
                /**
                 * DataLoadingConfig outputPath.
                 * @member {string} outputPath
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @instance
                 */
                DataLoadingConfig.prototype.outputPath = "";
    
                /**
                 * DataLoadingConfig format.
                 * @member {nebulaidl.core.DataLoadingConfig.LiteralMapFormat} format
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @instance
                 */
                DataLoadingConfig.prototype.format = 0;
    
                /**
                 * DataLoadingConfig ioStrategy.
                 * @member {nebulaidl.core.IIOStrategy|null|undefined} ioStrategy
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @instance
                 */
                DataLoadingConfig.prototype.ioStrategy = null;
    
                /**
                 * Creates a new DataLoadingConfig instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @static
                 * @param {nebulaidl.core.IDataLoadingConfig=} [properties] Properties to set
                 * @returns {nebulaidl.core.DataLoadingConfig} DataLoadingConfig instance
                 */
                DataLoadingConfig.create = function create(properties) {
                    return new DataLoadingConfig(properties);
                };
    
                /**
                 * Encodes the specified DataLoadingConfig message. Does not implicitly {@link nebulaidl.core.DataLoadingConfig.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @static
                 * @param {nebulaidl.core.IDataLoadingConfig} message DataLoadingConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataLoadingConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                    if (message.inputPath != null && message.hasOwnProperty("inputPath"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputPath);
                    if (message.outputPath != null && message.hasOwnProperty("outputPath"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputPath);
                    if (message.format != null && message.hasOwnProperty("format"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.format);
                    if (message.ioStrategy != null && message.hasOwnProperty("ioStrategy"))
                        $root.nebulaidl.core.IOStrategy.encode(message.ioStrategy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a DataLoadingConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.DataLoadingConfig} DataLoadingConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataLoadingConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.DataLoadingConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.enabled = reader.bool();
                            break;
                        case 2:
                            message.inputPath = reader.string();
                            break;
                        case 3:
                            message.outputPath = reader.string();
                            break;
                        case 4:
                            message.format = reader.int32();
                            break;
                        case 5:
                            message.ioStrategy = $root.nebulaidl.core.IOStrategy.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DataLoadingConfig message.
                 * @function verify
                 * @memberof nebulaidl.core.DataLoadingConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DataLoadingConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        if (typeof message.enabled !== "boolean")
                            return "enabled: boolean expected";
                    if (message.inputPath != null && message.hasOwnProperty("inputPath"))
                        if (!$util.isString(message.inputPath))
                            return "inputPath: string expected";
                    if (message.outputPath != null && message.hasOwnProperty("outputPath"))
                        if (!$util.isString(message.outputPath))
                            return "outputPath: string expected";
                    if (message.format != null && message.hasOwnProperty("format"))
                        switch (message.format) {
                        default:
                            return "format: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.ioStrategy != null && message.hasOwnProperty("ioStrategy")) {
                        var error = $root.nebulaidl.core.IOStrategy.verify(message.ioStrategy);
                        if (error)
                            return "ioStrategy." + error;
                    }
                    return null;
                };
    
                /**
                 * LiteralMapFormat enum.
                 * @name nebulaidl.core.DataLoadingConfig.LiteralMapFormat
                 * @enum {string}
                 * @property {number} JSON=0 JSON value
                 * @property {number} YAML=1 YAML value
                 * @property {number} PROTO=2 PROTO value
                 */
                DataLoadingConfig.LiteralMapFormat = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JSON"] = 0;
                    values[valuesById[1] = "YAML"] = 1;
                    values[valuesById[2] = "PROTO"] = 2;
                    return values;
                })();
    
                return DataLoadingConfig;
            })();
    
            core.K8sPod = (function() {
    
                /**
                 * Properties of a K8sPod.
                 * @memberof nebulaidl.core
                 * @interface IK8sPod
                 * @property {nebulaidl.core.IK8sObjectMetadata|null} [metadata] K8sPod metadata
                 * @property {google.protobuf.IStruct|null} [podSpec] K8sPod podSpec
                 * @property {nebulaidl.core.IDataLoadingConfig|null} [dataConfig] K8sPod dataConfig
                 */
    
                /**
                 * Constructs a new K8sPod.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a K8sPod.
                 * @implements IK8sPod
                 * @constructor
                 * @param {nebulaidl.core.IK8sPod=} [properties] Properties to set
                 */
                function K8sPod(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * K8sPod metadata.
                 * @member {nebulaidl.core.IK8sObjectMetadata|null|undefined} metadata
                 * @memberof nebulaidl.core.K8sPod
                 * @instance
                 */
                K8sPod.prototype.metadata = null;
    
                /**
                 * K8sPod podSpec.
                 * @member {google.protobuf.IStruct|null|undefined} podSpec
                 * @memberof nebulaidl.core.K8sPod
                 * @instance
                 */
                K8sPod.prototype.podSpec = null;
    
                /**
                 * K8sPod dataConfig.
                 * @member {nebulaidl.core.IDataLoadingConfig|null|undefined} dataConfig
                 * @memberof nebulaidl.core.K8sPod
                 * @instance
                 */
                K8sPod.prototype.dataConfig = null;
    
                /**
                 * Creates a new K8sPod instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.K8sPod
                 * @static
                 * @param {nebulaidl.core.IK8sPod=} [properties] Properties to set
                 * @returns {nebulaidl.core.K8sPod} K8sPod instance
                 */
                K8sPod.create = function create(properties) {
                    return new K8sPod(properties);
                };
    
                /**
                 * Encodes the specified K8sPod message. Does not implicitly {@link nebulaidl.core.K8sPod.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.K8sPod
                 * @static
                 * @param {nebulaidl.core.IK8sPod} message K8sPod message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                K8sPod.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.core.K8sObjectMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.podSpec != null && message.hasOwnProperty("podSpec"))
                        $root.google.protobuf.Struct.encode(message.podSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.dataConfig != null && message.hasOwnProperty("dataConfig"))
                        $root.nebulaidl.core.DataLoadingConfig.encode(message.dataConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a K8sPod message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.K8sPod
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.K8sPod} K8sPod
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                K8sPod.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.K8sPod();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.metadata = $root.nebulaidl.core.K8sObjectMetadata.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.podSpec = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.dataConfig = $root.nebulaidl.core.DataLoadingConfig.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a K8sPod message.
                 * @function verify
                 * @memberof nebulaidl.core.K8sPod
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                K8sPod.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.core.K8sObjectMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.podSpec != null && message.hasOwnProperty("podSpec")) {
                        var error = $root.google.protobuf.Struct.verify(message.podSpec);
                        if (error)
                            return "podSpec." + error;
                    }
                    if (message.dataConfig != null && message.hasOwnProperty("dataConfig")) {
                        var error = $root.nebulaidl.core.DataLoadingConfig.verify(message.dataConfig);
                        if (error)
                            return "dataConfig." + error;
                    }
                    return null;
                };
    
                return K8sPod;
            })();
    
            core.K8sObjectMetadata = (function() {
    
                /**
                 * Properties of a K8sObjectMetadata.
                 * @memberof nebulaidl.core
                 * @interface IK8sObjectMetadata
                 * @property {Object.<string,string>|null} [labels] K8sObjectMetadata labels
                 * @property {Object.<string,string>|null} [annotations] K8sObjectMetadata annotations
                 */
    
                /**
                 * Constructs a new K8sObjectMetadata.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a K8sObjectMetadata.
                 * @implements IK8sObjectMetadata
                 * @constructor
                 * @param {nebulaidl.core.IK8sObjectMetadata=} [properties] Properties to set
                 */
                function K8sObjectMetadata(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * K8sObjectMetadata labels.
                 * @member {Object.<string,string>} labels
                 * @memberof nebulaidl.core.K8sObjectMetadata
                 * @instance
                 */
                K8sObjectMetadata.prototype.labels = $util.emptyObject;
    
                /**
                 * K8sObjectMetadata annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof nebulaidl.core.K8sObjectMetadata
                 * @instance
                 */
                K8sObjectMetadata.prototype.annotations = $util.emptyObject;
    
                /**
                 * Creates a new K8sObjectMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.K8sObjectMetadata
                 * @static
                 * @param {nebulaidl.core.IK8sObjectMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.core.K8sObjectMetadata} K8sObjectMetadata instance
                 */
                K8sObjectMetadata.create = function create(properties) {
                    return new K8sObjectMetadata(properties);
                };
    
                /**
                 * Encodes the specified K8sObjectMetadata message. Does not implicitly {@link nebulaidl.core.K8sObjectMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.K8sObjectMetadata
                 * @static
                 * @param {nebulaidl.core.IK8sObjectMetadata} message K8sObjectMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                K8sObjectMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                    if (message.annotations != null && message.hasOwnProperty("annotations"))
                        for (var keys = Object.keys(message.annotations), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.annotations[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a K8sObjectMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.K8sObjectMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.K8sObjectMetadata} K8sObjectMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                K8sObjectMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.K8sObjectMetadata(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.labels === $util.emptyObject)
                                message.labels = {};
                            key = reader.string();
                            reader.pos++;
                            message.labels[key] = reader.string();
                            break;
                        case 2:
                            reader.skip().pos++;
                            if (message.annotations === $util.emptyObject)
                                message.annotations = {};
                            key = reader.string();
                            reader.pos++;
                            message.annotations[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a K8sObjectMetadata message.
                 * @function verify
                 * @memberof nebulaidl.core.K8sObjectMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                K8sObjectMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        var key = Object.keys(message.labels);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        var key = Object.keys(message.annotations);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };
    
                return K8sObjectMetadata;
            })();
    
            core.Sql = (function() {
    
                /**
                 * Properties of a Sql.
                 * @memberof nebulaidl.core
                 * @interface ISql
                 * @property {string|null} [statement] Sql statement
                 * @property {nebulaidl.core.Sql.Dialect|null} [dialect] Sql dialect
                 */
    
                /**
                 * Constructs a new Sql.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Sql.
                 * @implements ISql
                 * @constructor
                 * @param {nebulaidl.core.ISql=} [properties] Properties to set
                 */
                function Sql(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Sql statement.
                 * @member {string} statement
                 * @memberof nebulaidl.core.Sql
                 * @instance
                 */
                Sql.prototype.statement = "";
    
                /**
                 * Sql dialect.
                 * @member {nebulaidl.core.Sql.Dialect} dialect
                 * @memberof nebulaidl.core.Sql
                 * @instance
                 */
                Sql.prototype.dialect = 0;
    
                /**
                 * Creates a new Sql instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Sql
                 * @static
                 * @param {nebulaidl.core.ISql=} [properties] Properties to set
                 * @returns {nebulaidl.core.Sql} Sql instance
                 */
                Sql.create = function create(properties) {
                    return new Sql(properties);
                };
    
                /**
                 * Encodes the specified Sql message. Does not implicitly {@link nebulaidl.core.Sql.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Sql
                 * @static
                 * @param {nebulaidl.core.ISql} message Sql message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Sql.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.statement != null && message.hasOwnProperty("statement"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.statement);
                    if (message.dialect != null && message.hasOwnProperty("dialect"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dialect);
                    return writer;
                };
    
                /**
                 * Decodes a Sql message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Sql
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Sql} Sql
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Sql.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Sql();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.statement = reader.string();
                            break;
                        case 2:
                            message.dialect = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Sql message.
                 * @function verify
                 * @memberof nebulaidl.core.Sql
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Sql.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.statement != null && message.hasOwnProperty("statement"))
                        if (!$util.isString(message.statement))
                            return "statement: string expected";
                    if (message.dialect != null && message.hasOwnProperty("dialect"))
                        switch (message.dialect) {
                        default:
                            return "dialect: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Dialect enum.
                 * @name nebulaidl.core.Sql.Dialect
                 * @enum {string}
                 * @property {number} UNDEFINED=0 UNDEFINED value
                 * @property {number} ANSI=1 ANSI value
                 * @property {number} HIVE=2 HIVE value
                 * @property {number} OTHER=3 OTHER value
                 */
                Sql.Dialect = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "ANSI"] = 1;
                    values[valuesById[2] = "HIVE"] = 2;
                    values[valuesById[3] = "OTHER"] = 3;
                    return values;
                })();
    
                return Sql;
            })();
    
            core.Secret = (function() {
    
                /**
                 * Properties of a Secret.
                 * @memberof nebulaidl.core
                 * @interface ISecret
                 * @property {string|null} [group] Secret group
                 * @property {string|null} [groupVersion] Secret groupVersion
                 * @property {string|null} [key] Secret key
                 * @property {nebulaidl.core.Secret.MountType|null} [mountRequirement] Secret mountRequirement
                 */
    
                /**
                 * Constructs a new Secret.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Secret.
                 * @implements ISecret
                 * @constructor
                 * @param {nebulaidl.core.ISecret=} [properties] Properties to set
                 */
                function Secret(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Secret group.
                 * @member {string} group
                 * @memberof nebulaidl.core.Secret
                 * @instance
                 */
                Secret.prototype.group = "";
    
                /**
                 * Secret groupVersion.
                 * @member {string} groupVersion
                 * @memberof nebulaidl.core.Secret
                 * @instance
                 */
                Secret.prototype.groupVersion = "";
    
                /**
                 * Secret key.
                 * @member {string} key
                 * @memberof nebulaidl.core.Secret
                 * @instance
                 */
                Secret.prototype.key = "";
    
                /**
                 * Secret mountRequirement.
                 * @member {nebulaidl.core.Secret.MountType} mountRequirement
                 * @memberof nebulaidl.core.Secret
                 * @instance
                 */
                Secret.prototype.mountRequirement = 0;
    
                /**
                 * Creates a new Secret instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Secret
                 * @static
                 * @param {nebulaidl.core.ISecret=} [properties] Properties to set
                 * @returns {nebulaidl.core.Secret} Secret instance
                 */
                Secret.create = function create(properties) {
                    return new Secret(properties);
                };
    
                /**
                 * Encodes the specified Secret message. Does not implicitly {@link nebulaidl.core.Secret.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Secret
                 * @static
                 * @param {nebulaidl.core.ISecret} message Secret message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Secret.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && message.hasOwnProperty("group"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
                    if (message.groupVersion != null && message.hasOwnProperty("groupVersion"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupVersion);
                    if (message.key != null && message.hasOwnProperty("key"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.key);
                    if (message.mountRequirement != null && message.hasOwnProperty("mountRequirement"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.mountRequirement);
                    return writer;
                };
    
                /**
                 * Decodes a Secret message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Secret
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Secret} Secret
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Secret.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Secret();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.group = reader.string();
                            break;
                        case 2:
                            message.groupVersion = reader.string();
                            break;
                        case 3:
                            message.key = reader.string();
                            break;
                        case 4:
                            message.mountRequirement = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Secret message.
                 * @function verify
                 * @memberof nebulaidl.core.Secret
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Secret.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.groupVersion != null && message.hasOwnProperty("groupVersion"))
                        if (!$util.isString(message.groupVersion))
                            return "groupVersion: string expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.mountRequirement != null && message.hasOwnProperty("mountRequirement"))
                        switch (message.mountRequirement) {
                        default:
                            return "mountRequirement: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * MountType enum.
                 * @name nebulaidl.core.Secret.MountType
                 * @enum {string}
                 * @property {number} ANY=0 ANY value
                 * @property {number} ENV_VAR=1 ENV_VAR value
                 * @property {number} FILE=2 FILE value
                 */
                Secret.MountType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ANY"] = 0;
                    values[valuesById[1] = "ENV_VAR"] = 1;
                    values[valuesById[2] = "FILE"] = 2;
                    return values;
                })();
    
                return Secret;
            })();
    
            core.OAuth2Client = (function() {
    
                /**
                 * Properties of a OAuth2Client.
                 * @memberof nebulaidl.core
                 * @interface IOAuth2Client
                 * @property {string|null} [clientId] OAuth2Client clientId
                 * @property {nebulaidl.core.ISecret|null} [clientSecret] OAuth2Client clientSecret
                 */
    
                /**
                 * Constructs a new OAuth2Client.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a OAuth2Client.
                 * @implements IOAuth2Client
                 * @constructor
                 * @param {nebulaidl.core.IOAuth2Client=} [properties] Properties to set
                 */
                function OAuth2Client(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OAuth2Client clientId.
                 * @member {string} clientId
                 * @memberof nebulaidl.core.OAuth2Client
                 * @instance
                 */
                OAuth2Client.prototype.clientId = "";
    
                /**
                 * OAuth2Client clientSecret.
                 * @member {nebulaidl.core.ISecret|null|undefined} clientSecret
                 * @memberof nebulaidl.core.OAuth2Client
                 * @instance
                 */
                OAuth2Client.prototype.clientSecret = null;
    
                /**
                 * Creates a new OAuth2Client instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.OAuth2Client
                 * @static
                 * @param {nebulaidl.core.IOAuth2Client=} [properties] Properties to set
                 * @returns {nebulaidl.core.OAuth2Client} OAuth2Client instance
                 */
                OAuth2Client.create = function create(properties) {
                    return new OAuth2Client(properties);
                };
    
                /**
                 * Encodes the specified OAuth2Client message. Does not implicitly {@link nebulaidl.core.OAuth2Client.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.OAuth2Client
                 * @static
                 * @param {nebulaidl.core.IOAuth2Client} message OAuth2Client message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OAuth2Client.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.clientId != null && message.hasOwnProperty("clientId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientId);
                    if (message.clientSecret != null && message.hasOwnProperty("clientSecret"))
                        $root.nebulaidl.core.Secret.encode(message.clientSecret, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a OAuth2Client message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.OAuth2Client
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.OAuth2Client} OAuth2Client
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OAuth2Client.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.OAuth2Client();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.clientId = reader.string();
                            break;
                        case 2:
                            message.clientSecret = $root.nebulaidl.core.Secret.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a OAuth2Client message.
                 * @function verify
                 * @memberof nebulaidl.core.OAuth2Client
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OAuth2Client.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientId != null && message.hasOwnProperty("clientId"))
                        if (!$util.isString(message.clientId))
                            return "clientId: string expected";
                    if (message.clientSecret != null && message.hasOwnProperty("clientSecret")) {
                        var error = $root.nebulaidl.core.Secret.verify(message.clientSecret);
                        if (error)
                            return "clientSecret." + error;
                    }
                    return null;
                };
    
                return OAuth2Client;
            })();
    
            core.Identity = (function() {
    
                /**
                 * Properties of an Identity.
                 * @memberof nebulaidl.core
                 * @interface IIdentity
                 * @property {string|null} [iamRole] Identity iamRole
                 * @property {string|null} [k8sServiceAccount] Identity k8sServiceAccount
                 * @property {nebulaidl.core.IOAuth2Client|null} [oauth2Client] Identity oauth2Client
                 * @property {string|null} [executionIdentity] Identity executionIdentity
                 */
    
                /**
                 * Constructs a new Identity.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an Identity.
                 * @implements IIdentity
                 * @constructor
                 * @param {nebulaidl.core.IIdentity=} [properties] Properties to set
                 */
                function Identity(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Identity iamRole.
                 * @member {string} iamRole
                 * @memberof nebulaidl.core.Identity
                 * @instance
                 */
                Identity.prototype.iamRole = "";
    
                /**
                 * Identity k8sServiceAccount.
                 * @member {string} k8sServiceAccount
                 * @memberof nebulaidl.core.Identity
                 * @instance
                 */
                Identity.prototype.k8sServiceAccount = "";
    
                /**
                 * Identity oauth2Client.
                 * @member {nebulaidl.core.IOAuth2Client|null|undefined} oauth2Client
                 * @memberof nebulaidl.core.Identity
                 * @instance
                 */
                Identity.prototype.oauth2Client = null;
    
                /**
                 * Identity executionIdentity.
                 * @member {string} executionIdentity
                 * @memberof nebulaidl.core.Identity
                 * @instance
                 */
                Identity.prototype.executionIdentity = "";
    
                /**
                 * Creates a new Identity instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Identity
                 * @static
                 * @param {nebulaidl.core.IIdentity=} [properties] Properties to set
                 * @returns {nebulaidl.core.Identity} Identity instance
                 */
                Identity.create = function create(properties) {
                    return new Identity(properties);
                };
    
                /**
                 * Encodes the specified Identity message. Does not implicitly {@link nebulaidl.core.Identity.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Identity
                 * @static
                 * @param {nebulaidl.core.IIdentity} message Identity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Identity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.iamRole != null && message.hasOwnProperty("iamRole"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.iamRole);
                    if (message.k8sServiceAccount != null && message.hasOwnProperty("k8sServiceAccount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.k8sServiceAccount);
                    if (message.oauth2Client != null && message.hasOwnProperty("oauth2Client"))
                        $root.nebulaidl.core.OAuth2Client.encode(message.oauth2Client, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.executionIdentity != null && message.hasOwnProperty("executionIdentity"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.executionIdentity);
                    return writer;
                };
    
                /**
                 * Decodes an Identity message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Identity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Identity} Identity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Identity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Identity();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.iamRole = reader.string();
                            break;
                        case 2:
                            message.k8sServiceAccount = reader.string();
                            break;
                        case 3:
                            message.oauth2Client = $root.nebulaidl.core.OAuth2Client.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.executionIdentity = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Identity message.
                 * @function verify
                 * @memberof nebulaidl.core.Identity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Identity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.iamRole != null && message.hasOwnProperty("iamRole"))
                        if (!$util.isString(message.iamRole))
                            return "iamRole: string expected";
                    if (message.k8sServiceAccount != null && message.hasOwnProperty("k8sServiceAccount"))
                        if (!$util.isString(message.k8sServiceAccount))
                            return "k8sServiceAccount: string expected";
                    if (message.oauth2Client != null && message.hasOwnProperty("oauth2Client")) {
                        var error = $root.nebulaidl.core.OAuth2Client.verify(message.oauth2Client);
                        if (error)
                            return "oauth2Client." + error;
                    }
                    if (message.executionIdentity != null && message.hasOwnProperty("executionIdentity"))
                        if (!$util.isString(message.executionIdentity))
                            return "executionIdentity: string expected";
                    return null;
                };
    
                return Identity;
            })();
    
            core.OAuth2TokenRequest = (function() {
    
                /**
                 * Properties of a OAuth2TokenRequest.
                 * @memberof nebulaidl.core
                 * @interface IOAuth2TokenRequest
                 * @property {string|null} [name] OAuth2TokenRequest name
                 * @property {nebulaidl.core.OAuth2TokenRequest.Type|null} [type] OAuth2TokenRequest type
                 * @property {nebulaidl.core.IOAuth2Client|null} [client] OAuth2TokenRequest client
                 * @property {string|null} [idpDiscoveryEndpoint] OAuth2TokenRequest idpDiscoveryEndpoint
                 * @property {string|null} [tokenEndpoint] OAuth2TokenRequest tokenEndpoint
                 */
    
                /**
                 * Constructs a new OAuth2TokenRequest.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a OAuth2TokenRequest.
                 * @implements IOAuth2TokenRequest
                 * @constructor
                 * @param {nebulaidl.core.IOAuth2TokenRequest=} [properties] Properties to set
                 */
                function OAuth2TokenRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OAuth2TokenRequest name.
                 * @member {string} name
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @instance
                 */
                OAuth2TokenRequest.prototype.name = "";
    
                /**
                 * OAuth2TokenRequest type.
                 * @member {nebulaidl.core.OAuth2TokenRequest.Type} type
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @instance
                 */
                OAuth2TokenRequest.prototype.type = 0;
    
                /**
                 * OAuth2TokenRequest client.
                 * @member {nebulaidl.core.IOAuth2Client|null|undefined} client
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @instance
                 */
                OAuth2TokenRequest.prototype.client = null;
    
                /**
                 * OAuth2TokenRequest idpDiscoveryEndpoint.
                 * @member {string} idpDiscoveryEndpoint
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @instance
                 */
                OAuth2TokenRequest.prototype.idpDiscoveryEndpoint = "";
    
                /**
                 * OAuth2TokenRequest tokenEndpoint.
                 * @member {string} tokenEndpoint
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @instance
                 */
                OAuth2TokenRequest.prototype.tokenEndpoint = "";
    
                /**
                 * Creates a new OAuth2TokenRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @static
                 * @param {nebulaidl.core.IOAuth2TokenRequest=} [properties] Properties to set
                 * @returns {nebulaidl.core.OAuth2TokenRequest} OAuth2TokenRequest instance
                 */
                OAuth2TokenRequest.create = function create(properties) {
                    return new OAuth2TokenRequest(properties);
                };
    
                /**
                 * Encodes the specified OAuth2TokenRequest message. Does not implicitly {@link nebulaidl.core.OAuth2TokenRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @static
                 * @param {nebulaidl.core.IOAuth2TokenRequest} message OAuth2TokenRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OAuth2TokenRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.client != null && message.hasOwnProperty("client"))
                        $root.nebulaidl.core.OAuth2Client.encode(message.client, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.idpDiscoveryEndpoint != null && message.hasOwnProperty("idpDiscoveryEndpoint"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.idpDiscoveryEndpoint);
                    if (message.tokenEndpoint != null && message.hasOwnProperty("tokenEndpoint"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.tokenEndpoint);
                    return writer;
                };
    
                /**
                 * Decodes a OAuth2TokenRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.OAuth2TokenRequest} OAuth2TokenRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OAuth2TokenRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.OAuth2TokenRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.client = $root.nebulaidl.core.OAuth2Client.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.idpDiscoveryEndpoint = reader.string();
                            break;
                        case 5:
                            message.tokenEndpoint = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a OAuth2TokenRequest message.
                 * @function verify
                 * @memberof nebulaidl.core.OAuth2TokenRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OAuth2TokenRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                            break;
                        }
                    if (message.client != null && message.hasOwnProperty("client")) {
                        var error = $root.nebulaidl.core.OAuth2Client.verify(message.client);
                        if (error)
                            return "client." + error;
                    }
                    if (message.idpDiscoveryEndpoint != null && message.hasOwnProperty("idpDiscoveryEndpoint"))
                        if (!$util.isString(message.idpDiscoveryEndpoint))
                            return "idpDiscoveryEndpoint: string expected";
                    if (message.tokenEndpoint != null && message.hasOwnProperty("tokenEndpoint"))
                        if (!$util.isString(message.tokenEndpoint))
                            return "tokenEndpoint: string expected";
                    return null;
                };
    
                /**
                 * Type enum.
                 * @name nebulaidl.core.OAuth2TokenRequest.Type
                 * @enum {string}
                 * @property {number} CLIENT_CREDENTIALS=0 CLIENT_CREDENTIALS value
                 */
                OAuth2TokenRequest.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CLIENT_CREDENTIALS"] = 0;
                    return values;
                })();
    
                return OAuth2TokenRequest;
            })();
    
            core.SecurityContext = (function() {
    
                /**
                 * Properties of a SecurityContext.
                 * @memberof nebulaidl.core
                 * @interface ISecurityContext
                 * @property {nebulaidl.core.IIdentity|null} [runAs] SecurityContext runAs
                 * @property {Array.<nebulaidl.core.ISecret>|null} [secrets] SecurityContext secrets
                 * @property {Array.<nebulaidl.core.IOAuth2TokenRequest>|null} [tokens] SecurityContext tokens
                 */
    
                /**
                 * Constructs a new SecurityContext.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a SecurityContext.
                 * @implements ISecurityContext
                 * @constructor
                 * @param {nebulaidl.core.ISecurityContext=} [properties] Properties to set
                 */
                function SecurityContext(properties) {
                    this.secrets = [];
                    this.tokens = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SecurityContext runAs.
                 * @member {nebulaidl.core.IIdentity|null|undefined} runAs
                 * @memberof nebulaidl.core.SecurityContext
                 * @instance
                 */
                SecurityContext.prototype.runAs = null;
    
                /**
                 * SecurityContext secrets.
                 * @member {Array.<nebulaidl.core.ISecret>} secrets
                 * @memberof nebulaidl.core.SecurityContext
                 * @instance
                 */
                SecurityContext.prototype.secrets = $util.emptyArray;
    
                /**
                 * SecurityContext tokens.
                 * @member {Array.<nebulaidl.core.IOAuth2TokenRequest>} tokens
                 * @memberof nebulaidl.core.SecurityContext
                 * @instance
                 */
                SecurityContext.prototype.tokens = $util.emptyArray;
    
                /**
                 * Creates a new SecurityContext instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.SecurityContext
                 * @static
                 * @param {nebulaidl.core.ISecurityContext=} [properties] Properties to set
                 * @returns {nebulaidl.core.SecurityContext} SecurityContext instance
                 */
                SecurityContext.create = function create(properties) {
                    return new SecurityContext(properties);
                };
    
                /**
                 * Encodes the specified SecurityContext message. Does not implicitly {@link nebulaidl.core.SecurityContext.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.SecurityContext
                 * @static
                 * @param {nebulaidl.core.ISecurityContext} message SecurityContext message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SecurityContext.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.runAs != null && message.hasOwnProperty("runAs"))
                        $root.nebulaidl.core.Identity.encode(message.runAs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.secrets != null && message.secrets.length)
                        for (var i = 0; i < message.secrets.length; ++i)
                            $root.nebulaidl.core.Secret.encode(message.secrets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.tokens != null && message.tokens.length)
                        for (var i = 0; i < message.tokens.length; ++i)
                            $root.nebulaidl.core.OAuth2TokenRequest.encode(message.tokens[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SecurityContext message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.SecurityContext
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.SecurityContext} SecurityContext
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SecurityContext.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.SecurityContext();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.runAs = $root.nebulaidl.core.Identity.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.secrets && message.secrets.length))
                                message.secrets = [];
                            message.secrets.push($root.nebulaidl.core.Secret.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.tokens && message.tokens.length))
                                message.tokens = [];
                            message.tokens.push($root.nebulaidl.core.OAuth2TokenRequest.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SecurityContext message.
                 * @function verify
                 * @memberof nebulaidl.core.SecurityContext
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SecurityContext.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.runAs != null && message.hasOwnProperty("runAs")) {
                        var error = $root.nebulaidl.core.Identity.verify(message.runAs);
                        if (error)
                            return "runAs." + error;
                    }
                    if (message.secrets != null && message.hasOwnProperty("secrets")) {
                        if (!Array.isArray(message.secrets))
                            return "secrets: array expected";
                        for (var i = 0; i < message.secrets.length; ++i) {
                            var error = $root.nebulaidl.core.Secret.verify(message.secrets[i]);
                            if (error)
                                return "secrets." + error;
                        }
                    }
                    if (message.tokens != null && message.hasOwnProperty("tokens")) {
                        if (!Array.isArray(message.tokens))
                            return "tokens: array expected";
                        for (var i = 0; i < message.tokens.length; ++i) {
                            var error = $root.nebulaidl.core.OAuth2TokenRequest.verify(message.tokens[i]);
                            if (error)
                                return "tokens." + error;
                        }
                    }
                    return null;
                };
    
                return SecurityContext;
            })();
    
            core.DynamicJobSpec = (function() {
    
                /**
                 * Properties of a DynamicJobSpec.
                 * @memberof nebulaidl.core
                 * @interface IDynamicJobSpec
                 * @property {Array.<nebulaidl.core.INode>|null} [nodes] DynamicJobSpec nodes
                 * @property {Long|null} [minSuccesses] DynamicJobSpec minSuccesses
                 * @property {Array.<nebulaidl.core.IBinding>|null} [outputs] DynamicJobSpec outputs
                 * @property {Array.<nebulaidl.core.ITaskTemplate>|null} [tasks] DynamicJobSpec tasks
                 * @property {Array.<nebulaidl.core.IWorkflowTemplate>|null} [subworkflows] DynamicJobSpec subworkflows
                 */
    
                /**
                 * Constructs a new DynamicJobSpec.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a DynamicJobSpec.
                 * @implements IDynamicJobSpec
                 * @constructor
                 * @param {nebulaidl.core.IDynamicJobSpec=} [properties] Properties to set
                 */
                function DynamicJobSpec(properties) {
                    this.nodes = [];
                    this.outputs = [];
                    this.tasks = [];
                    this.subworkflows = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DynamicJobSpec nodes.
                 * @member {Array.<nebulaidl.core.INode>} nodes
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @instance
                 */
                DynamicJobSpec.prototype.nodes = $util.emptyArray;
    
                /**
                 * DynamicJobSpec minSuccesses.
                 * @member {Long} minSuccesses
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @instance
                 */
                DynamicJobSpec.prototype.minSuccesses = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * DynamicJobSpec outputs.
                 * @member {Array.<nebulaidl.core.IBinding>} outputs
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @instance
                 */
                DynamicJobSpec.prototype.outputs = $util.emptyArray;
    
                /**
                 * DynamicJobSpec tasks.
                 * @member {Array.<nebulaidl.core.ITaskTemplate>} tasks
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @instance
                 */
                DynamicJobSpec.prototype.tasks = $util.emptyArray;
    
                /**
                 * DynamicJobSpec subworkflows.
                 * @member {Array.<nebulaidl.core.IWorkflowTemplate>} subworkflows
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @instance
                 */
                DynamicJobSpec.prototype.subworkflows = $util.emptyArray;
    
                /**
                 * Creates a new DynamicJobSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @static
                 * @param {nebulaidl.core.IDynamicJobSpec=} [properties] Properties to set
                 * @returns {nebulaidl.core.DynamicJobSpec} DynamicJobSpec instance
                 */
                DynamicJobSpec.create = function create(properties) {
                    return new DynamicJobSpec(properties);
                };
    
                /**
                 * Encodes the specified DynamicJobSpec message. Does not implicitly {@link nebulaidl.core.DynamicJobSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @static
                 * @param {nebulaidl.core.IDynamicJobSpec} message DynamicJobSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DynamicJobSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodes != null && message.nodes.length)
                        for (var i = 0; i < message.nodes.length; ++i)
                            $root.nebulaidl.core.Node.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.minSuccesses != null && message.hasOwnProperty("minSuccesses"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minSuccesses);
                    if (message.outputs != null && message.outputs.length)
                        for (var i = 0; i < message.outputs.length; ++i)
                            $root.nebulaidl.core.Binding.encode(message.outputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.tasks != null && message.tasks.length)
                        for (var i = 0; i < message.tasks.length; ++i)
                            $root.nebulaidl.core.TaskTemplate.encode(message.tasks[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.subworkflows != null && message.subworkflows.length)
                        for (var i = 0; i < message.subworkflows.length; ++i)
                            $root.nebulaidl.core.WorkflowTemplate.encode(message.subworkflows[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a DynamicJobSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.DynamicJobSpec} DynamicJobSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DynamicJobSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.DynamicJobSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.nebulaidl.core.Node.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.minSuccesses = reader.int64();
                            break;
                        case 3:
                            if (!(message.outputs && message.outputs.length))
                                message.outputs = [];
                            message.outputs.push($root.nebulaidl.core.Binding.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.nebulaidl.core.TaskTemplate.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.subworkflows && message.subworkflows.length))
                                message.subworkflows = [];
                            message.subworkflows.push($root.nebulaidl.core.WorkflowTemplate.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DynamicJobSpec message.
                 * @function verify
                 * @memberof nebulaidl.core.DynamicJobSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DynamicJobSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (var i = 0; i < message.nodes.length; ++i) {
                            var error = $root.nebulaidl.core.Node.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    if (message.minSuccesses != null && message.hasOwnProperty("minSuccesses"))
                        if (!$util.isInteger(message.minSuccesses) && !(message.minSuccesses && $util.isInteger(message.minSuccesses.low) && $util.isInteger(message.minSuccesses.high)))
                            return "minSuccesses: integer|Long expected";
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        if (!Array.isArray(message.outputs))
                            return "outputs: array expected";
                        for (var i = 0; i < message.outputs.length; ++i) {
                            var error = $root.nebulaidl.core.Binding.verify(message.outputs[i]);
                            if (error)
                                return "outputs." + error;
                        }
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (var i = 0; i < message.tasks.length; ++i) {
                            var error = $root.nebulaidl.core.TaskTemplate.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    if (message.subworkflows != null && message.hasOwnProperty("subworkflows")) {
                        if (!Array.isArray(message.subworkflows))
                            return "subworkflows: array expected";
                        for (var i = 0; i < message.subworkflows.length; ++i) {
                            var error = $root.nebulaidl.core.WorkflowTemplate.verify(message.subworkflows[i]);
                            if (error)
                                return "subworkflows." + error;
                        }
                    }
                    return null;
                };
    
                return DynamicJobSpec;
            })();
    
            core.ContainerError = (function() {
    
                /**
                 * Properties of a ContainerError.
                 * @memberof nebulaidl.core
                 * @interface IContainerError
                 * @property {string|null} [code] ContainerError code
                 * @property {string|null} [message] ContainerError message
                 * @property {nebulaidl.core.ContainerError.Kind|null} [kind] ContainerError kind
                 * @property {nebulaidl.core.ExecutionError.ErrorKind|null} [origin] ContainerError origin
                 */
    
                /**
                 * Constructs a new ContainerError.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a ContainerError.
                 * @implements IContainerError
                 * @constructor
                 * @param {nebulaidl.core.IContainerError=} [properties] Properties to set
                 */
                function ContainerError(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ContainerError code.
                 * @member {string} code
                 * @memberof nebulaidl.core.ContainerError
                 * @instance
                 */
                ContainerError.prototype.code = "";
    
                /**
                 * ContainerError message.
                 * @member {string} message
                 * @memberof nebulaidl.core.ContainerError
                 * @instance
                 */
                ContainerError.prototype.message = "";
    
                /**
                 * ContainerError kind.
                 * @member {nebulaidl.core.ContainerError.Kind} kind
                 * @memberof nebulaidl.core.ContainerError
                 * @instance
                 */
                ContainerError.prototype.kind = 0;
    
                /**
                 * ContainerError origin.
                 * @member {nebulaidl.core.ExecutionError.ErrorKind} origin
                 * @memberof nebulaidl.core.ContainerError
                 * @instance
                 */
                ContainerError.prototype.origin = 0;
    
                /**
                 * Creates a new ContainerError instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ContainerError
                 * @static
                 * @param {nebulaidl.core.IContainerError=} [properties] Properties to set
                 * @returns {nebulaidl.core.ContainerError} ContainerError instance
                 */
                ContainerError.create = function create(properties) {
                    return new ContainerError(properties);
                };
    
                /**
                 * Encodes the specified ContainerError message. Does not implicitly {@link nebulaidl.core.ContainerError.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ContainerError
                 * @static
                 * @param {nebulaidl.core.IContainerError} message ContainerError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ContainerError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && message.hasOwnProperty("code"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.kind);
                    if (message.origin != null && message.hasOwnProperty("origin"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.origin);
                    return writer;
                };
    
                /**
                 * Decodes a ContainerError message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ContainerError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ContainerError} ContainerError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ContainerError.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ContainerError();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.string();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        case 3:
                            message.kind = reader.int32();
                            break;
                        case 4:
                            message.origin = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ContainerError message.
                 * @function verify
                 * @memberof nebulaidl.core.ContainerError
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ContainerError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        switch (message.kind) {
                        default:
                            return "kind: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.origin != null && message.hasOwnProperty("origin"))
                        switch (message.origin) {
                        default:
                            return "origin: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Kind enum.
                 * @name nebulaidl.core.ContainerError.Kind
                 * @enum {string}
                 * @property {number} NON_RECOVERABLE=0 NON_RECOVERABLE value
                 * @property {number} RECOVERABLE=1 RECOVERABLE value
                 */
                ContainerError.Kind = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NON_RECOVERABLE"] = 0;
                    values[valuesById[1] = "RECOVERABLE"] = 1;
                    return values;
                })();
    
                return ContainerError;
            })();
    
            core.ErrorDocument = (function() {
    
                /**
                 * Properties of an ErrorDocument.
                 * @memberof nebulaidl.core
                 * @interface IErrorDocument
                 * @property {nebulaidl.core.IContainerError|null} [error] ErrorDocument error
                 */
    
                /**
                 * Constructs a new ErrorDocument.
                 * @memberof nebulaidl.core
                 * @classdesc Represents an ErrorDocument.
                 * @implements IErrorDocument
                 * @constructor
                 * @param {nebulaidl.core.IErrorDocument=} [properties] Properties to set
                 */
                function ErrorDocument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ErrorDocument error.
                 * @member {nebulaidl.core.IContainerError|null|undefined} error
                 * @memberof nebulaidl.core.ErrorDocument
                 * @instance
                 */
                ErrorDocument.prototype.error = null;
    
                /**
                 * Creates a new ErrorDocument instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.ErrorDocument
                 * @static
                 * @param {nebulaidl.core.IErrorDocument=} [properties] Properties to set
                 * @returns {nebulaidl.core.ErrorDocument} ErrorDocument instance
                 */
                ErrorDocument.create = function create(properties) {
                    return new ErrorDocument(properties);
                };
    
                /**
                 * Encodes the specified ErrorDocument message. Does not implicitly {@link nebulaidl.core.ErrorDocument.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.ErrorDocument
                 * @static
                 * @param {nebulaidl.core.IErrorDocument} message ErrorDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ErrorDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ContainerError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ErrorDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.ErrorDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.ErrorDocument} ErrorDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ErrorDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.ErrorDocument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.nebulaidl.core.ContainerError.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ErrorDocument message.
                 * @function verify
                 * @memberof nebulaidl.core.ErrorDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ErrorDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.nebulaidl.core.ContainerError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                return ErrorDocument;
            })();
    
            core.Span = (function() {
    
                /**
                 * Properties of a Span.
                 * @memberof nebulaidl.core
                 * @interface ISpan
                 * @property {google.protobuf.ITimestamp|null} [startTime] Span startTime
                 * @property {google.protobuf.ITimestamp|null} [endTime] Span endTime
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [workflowId] Span workflowId
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [nodeId] Span nodeId
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [taskId] Span taskId
                 * @property {string|null} [operationId] Span operationId
                 * @property {Array.<nebulaidl.core.ISpan>|null} [spans] Span spans
                 */
    
                /**
                 * Constructs a new Span.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a Span.
                 * @implements ISpan
                 * @constructor
                 * @param {nebulaidl.core.ISpan=} [properties] Properties to set
                 */
                function Span(properties) {
                    this.spans = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Span startTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} startTime
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.startTime = null;
    
                /**
                 * Span endTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} endTime
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.endTime = null;
    
                /**
                 * Span workflowId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} workflowId
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.workflowId = null;
    
                /**
                 * Span nodeId.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} nodeId
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.nodeId = null;
    
                /**
                 * Span taskId.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} taskId
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.taskId = null;
    
                /**
                 * Span operationId.
                 * @member {string} operationId
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.operationId = "";
    
                /**
                 * Span spans.
                 * @member {Array.<nebulaidl.core.ISpan>} spans
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Span.prototype.spans = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Span id.
                 * @member {"workflowId"|"nodeId"|"taskId"|"operationId"|undefined} id
                 * @memberof nebulaidl.core.Span
                 * @instance
                 */
                Object.defineProperty(Span.prototype, "id", {
                    get: $util.oneOfGetter($oneOfFields = ["workflowId", "nodeId", "taskId", "operationId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Span instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.Span
                 * @static
                 * @param {nebulaidl.core.ISpan=} [properties] Properties to set
                 * @returns {nebulaidl.core.Span} Span instance
                 */
                Span.create = function create(properties) {
                    return new Span(properties);
                };
    
                /**
                 * Encodes the specified Span message. Does not implicitly {@link nebulaidl.core.Span.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.Span
                 * @static
                 * @param {nebulaidl.core.ISpan} message Span message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Span.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.startTime != null && message.hasOwnProperty("startTime"))
                        $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.endTime != null && message.hasOwnProperty("endTime"))
                        $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.workflowId != null && message.hasOwnProperty("workflowId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.workflowId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.nodeId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.taskId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.operationId != null && message.hasOwnProperty("operationId"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.operationId);
                    if (message.spans != null && message.spans.length)
                        for (var i = 0; i < message.spans.length; ++i)
                            $root.nebulaidl.core.Span.encode(message.spans[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Span message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.Span
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.Span} Span
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Span.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.Span();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.workflowId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.nodeId = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.taskId = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.operationId = reader.string();
                            break;
                        case 7:
                            if (!(message.spans && message.spans.length))
                                message.spans = [];
                            message.spans.push($root.nebulaidl.core.Span.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Span message.
                 * @function verify
                 * @memberof nebulaidl.core.Span
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Span.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.startTime != null && message.hasOwnProperty("startTime")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.startTime);
                        if (error)
                            return "startTime." + error;
                    }
                    if (message.endTime != null && message.hasOwnProperty("endTime")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.endTime);
                        if (error)
                            return "endTime." + error;
                    }
                    if (message.workflowId != null && message.hasOwnProperty("workflowId")) {
                        properties.id = 1;
                        {
                            var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.workflowId);
                            if (error)
                                return "workflowId." + error;
                        }
                    }
                    if (message.nodeId != null && message.hasOwnProperty("nodeId")) {
                        if (properties.id === 1)
                            return "id: multiple values";
                        properties.id = 1;
                        {
                            var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.nodeId);
                            if (error)
                                return "nodeId." + error;
                        }
                    }
                    if (message.taskId != null && message.hasOwnProperty("taskId")) {
                        if (properties.id === 1)
                            return "id: multiple values";
                        properties.id = 1;
                        {
                            var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.taskId);
                            if (error)
                                return "taskId." + error;
                        }
                    }
                    if (message.operationId != null && message.hasOwnProperty("operationId")) {
                        if (properties.id === 1)
                            return "id: multiple values";
                        properties.id = 1;
                        if (!$util.isString(message.operationId))
                            return "operationId: string expected";
                    }
                    if (message.spans != null && message.hasOwnProperty("spans")) {
                        if (!Array.isArray(message.spans))
                            return "spans: array expected";
                        for (var i = 0; i < message.spans.length; ++i) {
                            var error = $root.nebulaidl.core.Span.verify(message.spans[i]);
                            if (error)
                                return "spans." + error;
                        }
                    }
                    return null;
                };
    
                return Span;
            })();
    
            core.WorkflowClosure = (function() {
    
                /**
                 * Properties of a WorkflowClosure.
                 * @memberof nebulaidl.core
                 * @interface IWorkflowClosure
                 * @property {nebulaidl.core.IWorkflowTemplate|null} [workflow] WorkflowClosure workflow
                 * @property {Array.<nebulaidl.core.ITaskTemplate>|null} [tasks] WorkflowClosure tasks
                 */
    
                /**
                 * Constructs a new WorkflowClosure.
                 * @memberof nebulaidl.core
                 * @classdesc Represents a WorkflowClosure.
                 * @implements IWorkflowClosure
                 * @constructor
                 * @param {nebulaidl.core.IWorkflowClosure=} [properties] Properties to set
                 */
                function WorkflowClosure(properties) {
                    this.tasks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowClosure workflow.
                 * @member {nebulaidl.core.IWorkflowTemplate|null|undefined} workflow
                 * @memberof nebulaidl.core.WorkflowClosure
                 * @instance
                 */
                WorkflowClosure.prototype.workflow = null;
    
                /**
                 * WorkflowClosure tasks.
                 * @member {Array.<nebulaidl.core.ITaskTemplate>} tasks
                 * @memberof nebulaidl.core.WorkflowClosure
                 * @instance
                 */
                WorkflowClosure.prototype.tasks = $util.emptyArray;
    
                /**
                 * Creates a new WorkflowClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.core.WorkflowClosure
                 * @static
                 * @param {nebulaidl.core.IWorkflowClosure=} [properties] Properties to set
                 * @returns {nebulaidl.core.WorkflowClosure} WorkflowClosure instance
                 */
                WorkflowClosure.create = function create(properties) {
                    return new WorkflowClosure(properties);
                };
    
                /**
                 * Encodes the specified WorkflowClosure message. Does not implicitly {@link nebulaidl.core.WorkflowClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.core.WorkflowClosure
                 * @static
                 * @param {nebulaidl.core.IWorkflowClosure} message WorkflowClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        $root.nebulaidl.core.WorkflowTemplate.encode(message.workflow, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.tasks != null && message.tasks.length)
                        for (var i = 0; i < message.tasks.length; ++i)
                            $root.nebulaidl.core.TaskTemplate.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.core.WorkflowClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.core.WorkflowClosure} WorkflowClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.core.WorkflowClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.workflow = $root.nebulaidl.core.WorkflowTemplate.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.nebulaidl.core.TaskTemplate.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowClosure message.
                 * @function verify
                 * @memberof nebulaidl.core.WorkflowClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.workflow != null && message.hasOwnProperty("workflow")) {
                        var error = $root.nebulaidl.core.WorkflowTemplate.verify(message.workflow);
                        if (error)
                            return "workflow." + error;
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (var i = 0; i < message.tasks.length; ++i) {
                            var error = $root.nebulaidl.core.TaskTemplate.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    return null;
                };
    
                return WorkflowClosure;
            })();
    
            return core;
        })();
    
        nebulaidl.event = (function() {
    
            /**
             * Namespace event.
             * @memberof nebulaidl
             * @namespace
             */
            var event = {};
    
            event.WorkflowExecutionEvent = (function() {
    
                /**
                 * Properties of a WorkflowExecutionEvent.
                 * @memberof nebulaidl.event
                 * @interface IWorkflowExecutionEvent
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [executionId] WorkflowExecutionEvent executionId
                 * @property {string|null} [producerId] WorkflowExecutionEvent producerId
                 * @property {nebulaidl.core.WorkflowExecution.Phase|null} [phase] WorkflowExecutionEvent phase
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] WorkflowExecutionEvent occurredAt
                 * @property {string|null} [outputUri] WorkflowExecutionEvent outputUri
                 * @property {nebulaidl.core.IExecutionError|null} [error] WorkflowExecutionEvent error
                 * @property {nebulaidl.core.ILiteralMap|null} [outputData] WorkflowExecutionEvent outputData
                 */
    
                /**
                 * Constructs a new WorkflowExecutionEvent.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a WorkflowExecutionEvent.
                 * @implements IWorkflowExecutionEvent
                 * @constructor
                 * @param {nebulaidl.event.IWorkflowExecutionEvent=} [properties] Properties to set
                 */
                function WorkflowExecutionEvent(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionEvent executionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.executionId = null;
    
                /**
                 * WorkflowExecutionEvent producerId.
                 * @member {string} producerId
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.producerId = "";
    
                /**
                 * WorkflowExecutionEvent phase.
                 * @member {nebulaidl.core.WorkflowExecution.Phase} phase
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.phase = 0;
    
                /**
                 * WorkflowExecutionEvent occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.occurredAt = null;
    
                /**
                 * WorkflowExecutionEvent outputUri.
                 * @member {string} outputUri
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.outputUri = "";
    
                /**
                 * WorkflowExecutionEvent error.
                 * @member {nebulaidl.core.IExecutionError|null|undefined} error
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.error = null;
    
                /**
                 * WorkflowExecutionEvent outputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputData
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                WorkflowExecutionEvent.prototype.outputData = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * WorkflowExecutionEvent outputResult.
                 * @member {"outputUri"|"error"|"outputData"|undefined} outputResult
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @instance
                 */
                Object.defineProperty(WorkflowExecutionEvent.prototype, "outputResult", {
                    get: $util.oneOfGetter($oneOfFields = ["outputUri", "error", "outputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new WorkflowExecutionEvent instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @static
                 * @param {nebulaidl.event.IWorkflowExecutionEvent=} [properties] Properties to set
                 * @returns {nebulaidl.event.WorkflowExecutionEvent} WorkflowExecutionEvent instance
                 */
                WorkflowExecutionEvent.create = function create(properties) {
                    return new WorkflowExecutionEvent(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionEvent message. Does not implicitly {@link nebulaidl.event.WorkflowExecutionEvent.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @static
                 * @param {nebulaidl.event.IWorkflowExecutionEvent} message WorkflowExecutionEvent message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionEvent.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.executionId != null && message.hasOwnProperty("executionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.producerId != null && message.hasOwnProperty("producerId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerId);
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.outputUri);
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.outputData != null && message.hasOwnProperty("outputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionEvent message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.WorkflowExecutionEvent} WorkflowExecutionEvent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionEvent.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.WorkflowExecutionEvent();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.producerId = reader.string();
                            break;
                        case 3:
                            message.phase = reader.int32();
                            break;
                        case 4:
                            message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.outputUri = reader.string();
                            break;
                        case 6:
                            message.error = $root.nebulaidl.core.ExecutionError.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.outputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionEvent message.
                 * @function verify
                 * @memberof nebulaidl.event.WorkflowExecutionEvent
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionEvent.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.executionId != null && message.hasOwnProperty("executionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                        if (error)
                            return "executionId." + error;
                    }
                    if (message.producerId != null && message.hasOwnProperty("producerId"))
                        if (!$util.isString(message.producerId))
                            return "producerId: string expected";
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                        properties.outputResult = 1;
                        if (!$util.isString(message.outputUri))
                            return "outputUri: string expected";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.ExecutionError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.outputData != null && message.hasOwnProperty("outputData")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.outputData);
                            if (error)
                                return "outputData." + error;
                        }
                    }
                    return null;
                };
    
                return WorkflowExecutionEvent;
            })();
    
            event.NodeExecutionEvent = (function() {
    
                /**
                 * Properties of a NodeExecutionEvent.
                 * @memberof nebulaidl.event
                 * @interface INodeExecutionEvent
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [id] NodeExecutionEvent id
                 * @property {string|null} [producerId] NodeExecutionEvent producerId
                 * @property {nebulaidl.core.NodeExecution.Phase|null} [phase] NodeExecutionEvent phase
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] NodeExecutionEvent occurredAt
                 * @property {string|null} [inputUri] NodeExecutionEvent inputUri
                 * @property {nebulaidl.core.ILiteralMap|null} [inputData] NodeExecutionEvent inputData
                 * @property {string|null} [outputUri] NodeExecutionEvent outputUri
                 * @property {nebulaidl.core.IExecutionError|null} [error] NodeExecutionEvent error
                 * @property {nebulaidl.core.ILiteralMap|null} [outputData] NodeExecutionEvent outputData
                 * @property {nebulaidl.event.IWorkflowNodeMetadata|null} [workflowNodeMetadata] NodeExecutionEvent workflowNodeMetadata
                 * @property {nebulaidl.event.ITaskNodeMetadata|null} [taskNodeMetadata] NodeExecutionEvent taskNodeMetadata
                 * @property {nebulaidl.event.IParentTaskExecutionMetadata|null} [parentTaskMetadata] NodeExecutionEvent parentTaskMetadata
                 * @property {nebulaidl.event.IParentNodeExecutionMetadata|null} [parentNodeMetadata] NodeExecutionEvent parentNodeMetadata
                 * @property {string|null} [retryGroup] NodeExecutionEvent retryGroup
                 * @property {string|null} [specNodeId] NodeExecutionEvent specNodeId
                 * @property {string|null} [nodeName] NodeExecutionEvent nodeName
                 * @property {number|null} [eventVersion] NodeExecutionEvent eventVersion
                 * @property {boolean|null} [isParent] NodeExecutionEvent isParent
                 * @property {boolean|null} [isDynamic] NodeExecutionEvent isDynamic
                 * @property {string|null} [deckUri] NodeExecutionEvent deckUri
                 * @property {google.protobuf.ITimestamp|null} [reportedAt] NodeExecutionEvent reportedAt
                 */
    
                /**
                 * Constructs a new NodeExecutionEvent.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a NodeExecutionEvent.
                 * @implements INodeExecutionEvent
                 * @constructor
                 * @param {nebulaidl.event.INodeExecutionEvent=} [properties] Properties to set
                 */
                function NodeExecutionEvent(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionEvent id.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.id = null;
    
                /**
                 * NodeExecutionEvent producerId.
                 * @member {string} producerId
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.producerId = "";
    
                /**
                 * NodeExecutionEvent phase.
                 * @member {nebulaidl.core.NodeExecution.Phase} phase
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.phase = 0;
    
                /**
                 * NodeExecutionEvent occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.occurredAt = null;
    
                /**
                 * NodeExecutionEvent inputUri.
                 * @member {string} inputUri
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.inputUri = "";
    
                /**
                 * NodeExecutionEvent inputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} inputData
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.inputData = null;
    
                /**
                 * NodeExecutionEvent outputUri.
                 * @member {string} outputUri
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.outputUri = "";
    
                /**
                 * NodeExecutionEvent error.
                 * @member {nebulaidl.core.IExecutionError|null|undefined} error
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.error = null;
    
                /**
                 * NodeExecutionEvent outputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputData
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.outputData = null;
    
                /**
                 * NodeExecutionEvent workflowNodeMetadata.
                 * @member {nebulaidl.event.IWorkflowNodeMetadata|null|undefined} workflowNodeMetadata
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.workflowNodeMetadata = null;
    
                /**
                 * NodeExecutionEvent taskNodeMetadata.
                 * @member {nebulaidl.event.ITaskNodeMetadata|null|undefined} taskNodeMetadata
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.taskNodeMetadata = null;
    
                /**
                 * NodeExecutionEvent parentTaskMetadata.
                 * @member {nebulaidl.event.IParentTaskExecutionMetadata|null|undefined} parentTaskMetadata
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.parentTaskMetadata = null;
    
                /**
                 * NodeExecutionEvent parentNodeMetadata.
                 * @member {nebulaidl.event.IParentNodeExecutionMetadata|null|undefined} parentNodeMetadata
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.parentNodeMetadata = null;
    
                /**
                 * NodeExecutionEvent retryGroup.
                 * @member {string} retryGroup
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.retryGroup = "";
    
                /**
                 * NodeExecutionEvent specNodeId.
                 * @member {string} specNodeId
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.specNodeId = "";
    
                /**
                 * NodeExecutionEvent nodeName.
                 * @member {string} nodeName
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.nodeName = "";
    
                /**
                 * NodeExecutionEvent eventVersion.
                 * @member {number} eventVersion
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.eventVersion = 0;
    
                /**
                 * NodeExecutionEvent isParent.
                 * @member {boolean} isParent
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.isParent = false;
    
                /**
                 * NodeExecutionEvent isDynamic.
                 * @member {boolean} isDynamic
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.isDynamic = false;
    
                /**
                 * NodeExecutionEvent deckUri.
                 * @member {string} deckUri
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.deckUri = "";
    
                /**
                 * NodeExecutionEvent reportedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} reportedAt
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                NodeExecutionEvent.prototype.reportedAt = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * NodeExecutionEvent inputValue.
                 * @member {"inputUri"|"inputData"|undefined} inputValue
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                Object.defineProperty(NodeExecutionEvent.prototype, "inputValue", {
                    get: $util.oneOfGetter($oneOfFields = ["inputUri", "inputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * NodeExecutionEvent outputResult.
                 * @member {"outputUri"|"error"|"outputData"|undefined} outputResult
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                Object.defineProperty(NodeExecutionEvent.prototype, "outputResult", {
                    get: $util.oneOfGetter($oneOfFields = ["outputUri", "error", "outputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * NodeExecutionEvent targetMetadata.
                 * @member {"workflowNodeMetadata"|"taskNodeMetadata"|undefined} targetMetadata
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @instance
                 */
                Object.defineProperty(NodeExecutionEvent.prototype, "targetMetadata", {
                    get: $util.oneOfGetter($oneOfFields = ["workflowNodeMetadata", "taskNodeMetadata"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NodeExecutionEvent instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @static
                 * @param {nebulaidl.event.INodeExecutionEvent=} [properties] Properties to set
                 * @returns {nebulaidl.event.NodeExecutionEvent} NodeExecutionEvent instance
                 */
                NodeExecutionEvent.create = function create(properties) {
                    return new NodeExecutionEvent(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionEvent message. Does not implicitly {@link nebulaidl.event.NodeExecutionEvent.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @static
                 * @param {nebulaidl.event.INodeExecutionEvent} message NodeExecutionEvent message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionEvent.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.producerId != null && message.hasOwnProperty("producerId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerId);
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.inputUri);
                    if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.outputUri);
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata"))
                        $root.nebulaidl.event.WorkflowNodeMetadata.encode(message.workflowNodeMetadata, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.parentTaskMetadata != null && message.hasOwnProperty("parentTaskMetadata"))
                        $root.nebulaidl.event.ParentTaskExecutionMetadata.encode(message.parentTaskMetadata, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.parentNodeMetadata != null && message.hasOwnProperty("parentNodeMetadata"))
                        $root.nebulaidl.event.ParentNodeExecutionMetadata.encode(message.parentNodeMetadata, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.retryGroup != null && message.hasOwnProperty("retryGroup"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.retryGroup);
                    if (message.specNodeId != null && message.hasOwnProperty("specNodeId"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.specNodeId);
                    if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.nodeName);
                    if (message.taskNodeMetadata != null && message.hasOwnProperty("taskNodeMetadata"))
                        $root.nebulaidl.event.TaskNodeMetadata.encode(message.taskNodeMetadata, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.outputData != null && message.hasOwnProperty("outputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputData, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.eventVersion);
                    if (message.isParent != null && message.hasOwnProperty("isParent"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.isParent);
                    if (message.isDynamic != null && message.hasOwnProperty("isDynamic"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.isDynamic);
                    if (message.deckUri != null && message.hasOwnProperty("deckUri"))
                        writer.uint32(/* id 19, wireType 2 =*/154).string(message.deckUri);
                    if (message.inputData != null && message.hasOwnProperty("inputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.inputData, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.reportedAt != null && message.hasOwnProperty("reportedAt"))
                        $root.google.protobuf.Timestamp.encode(message.reportedAt, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionEvent message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.NodeExecutionEvent} NodeExecutionEvent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionEvent.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.NodeExecutionEvent();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.producerId = reader.string();
                            break;
                        case 3:
                            message.phase = reader.int32();
                            break;
                        case 4:
                            message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.inputUri = reader.string();
                            break;
                        case 20:
                            message.inputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.outputUri = reader.string();
                            break;
                        case 7:
                            message.error = $root.nebulaidl.core.ExecutionError.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.outputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.workflowNodeMetadata = $root.nebulaidl.event.WorkflowNodeMetadata.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.taskNodeMetadata = $root.nebulaidl.event.TaskNodeMetadata.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.parentTaskMetadata = $root.nebulaidl.event.ParentTaskExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.parentNodeMetadata = $root.nebulaidl.event.ParentNodeExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.retryGroup = reader.string();
                            break;
                        case 12:
                            message.specNodeId = reader.string();
                            break;
                        case 13:
                            message.nodeName = reader.string();
                            break;
                        case 16:
                            message.eventVersion = reader.int32();
                            break;
                        case 17:
                            message.isParent = reader.bool();
                            break;
                        case 18:
                            message.isDynamic = reader.bool();
                            break;
                        case 19:
                            message.deckUri = reader.string();
                            break;
                        case 21:
                            message.reportedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionEvent message.
                 * @function verify
                 * @memberof nebulaidl.event.NodeExecutionEvent
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionEvent.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.producerId != null && message.hasOwnProperty("producerId"))
                        if (!$util.isString(message.producerId))
                            return "producerId: string expected";
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.inputUri != null && message.hasOwnProperty("inputUri")) {
                        properties.inputValue = 1;
                        if (!$util.isString(message.inputUri))
                            return "inputUri: string expected";
                    }
                    if (message.inputData != null && message.hasOwnProperty("inputData")) {
                        if (properties.inputValue === 1)
                            return "inputValue: multiple values";
                        properties.inputValue = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.inputData);
                            if (error)
                                return "inputData." + error;
                        }
                    }
                    if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                        properties.outputResult = 1;
                        if (!$util.isString(message.outputUri))
                            return "outputUri: string expected";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.ExecutionError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.outputData != null && message.hasOwnProperty("outputData")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.outputData);
                            if (error)
                                return "outputData." + error;
                        }
                    }
                    if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata")) {
                        properties.targetMetadata = 1;
                        {
                            var error = $root.nebulaidl.event.WorkflowNodeMetadata.verify(message.workflowNodeMetadata);
                            if (error)
                                return "workflowNodeMetadata." + error;
                        }
                    }
                    if (message.taskNodeMetadata != null && message.hasOwnProperty("taskNodeMetadata")) {
                        if (properties.targetMetadata === 1)
                            return "targetMetadata: multiple values";
                        properties.targetMetadata = 1;
                        {
                            var error = $root.nebulaidl.event.TaskNodeMetadata.verify(message.taskNodeMetadata);
                            if (error)
                                return "taskNodeMetadata." + error;
                        }
                    }
                    if (message.parentTaskMetadata != null && message.hasOwnProperty("parentTaskMetadata")) {
                        var error = $root.nebulaidl.event.ParentTaskExecutionMetadata.verify(message.parentTaskMetadata);
                        if (error)
                            return "parentTaskMetadata." + error;
                    }
                    if (message.parentNodeMetadata != null && message.hasOwnProperty("parentNodeMetadata")) {
                        var error = $root.nebulaidl.event.ParentNodeExecutionMetadata.verify(message.parentNodeMetadata);
                        if (error)
                            return "parentNodeMetadata." + error;
                    }
                    if (message.retryGroup != null && message.hasOwnProperty("retryGroup"))
                        if (!$util.isString(message.retryGroup))
                            return "retryGroup: string expected";
                    if (message.specNodeId != null && message.hasOwnProperty("specNodeId"))
                        if (!$util.isString(message.specNodeId))
                            return "specNodeId: string expected";
                    if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                        if (!$util.isString(message.nodeName))
                            return "nodeName: string expected";
                    if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
                        if (!$util.isInteger(message.eventVersion))
                            return "eventVersion: integer expected";
                    if (message.isParent != null && message.hasOwnProperty("isParent"))
                        if (typeof message.isParent !== "boolean")
                            return "isParent: boolean expected";
                    if (message.isDynamic != null && message.hasOwnProperty("isDynamic"))
                        if (typeof message.isDynamic !== "boolean")
                            return "isDynamic: boolean expected";
                    if (message.deckUri != null && message.hasOwnProperty("deckUri"))
                        if (!$util.isString(message.deckUri))
                            return "deckUri: string expected";
                    if (message.reportedAt != null && message.hasOwnProperty("reportedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.reportedAt);
                        if (error)
                            return "reportedAt." + error;
                    }
                    return null;
                };
    
                return NodeExecutionEvent;
            })();
    
            event.WorkflowNodeMetadata = (function() {
    
                /**
                 * Properties of a WorkflowNodeMetadata.
                 * @memberof nebulaidl.event
                 * @interface IWorkflowNodeMetadata
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [executionId] WorkflowNodeMetadata executionId
                 */
    
                /**
                 * Constructs a new WorkflowNodeMetadata.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a WorkflowNodeMetadata.
                 * @implements IWorkflowNodeMetadata
                 * @constructor
                 * @param {nebulaidl.event.IWorkflowNodeMetadata=} [properties] Properties to set
                 */
                function WorkflowNodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowNodeMetadata executionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
                 * @memberof nebulaidl.event.WorkflowNodeMetadata
                 * @instance
                 */
                WorkflowNodeMetadata.prototype.executionId = null;
    
                /**
                 * Creates a new WorkflowNodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.WorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.event.IWorkflowNodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.event.WorkflowNodeMetadata} WorkflowNodeMetadata instance
                 */
                WorkflowNodeMetadata.create = function create(properties) {
                    return new WorkflowNodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified WorkflowNodeMetadata message. Does not implicitly {@link nebulaidl.event.WorkflowNodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.WorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.event.IWorkflowNodeMetadata} message WorkflowNodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowNodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.executionId != null && message.hasOwnProperty("executionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowNodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.WorkflowNodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.WorkflowNodeMetadata} WorkflowNodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowNodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.WorkflowNodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowNodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.event.WorkflowNodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowNodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.executionId != null && message.hasOwnProperty("executionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                        if (error)
                            return "executionId." + error;
                    }
                    return null;
                };
    
                return WorkflowNodeMetadata;
            })();
    
            event.TaskNodeMetadata = (function() {
    
                /**
                 * Properties of a TaskNodeMetadata.
                 * @memberof nebulaidl.event
                 * @interface ITaskNodeMetadata
                 * @property {nebulaidl.core.CatalogCacheStatus|null} [cacheStatus] TaskNodeMetadata cacheStatus
                 * @property {nebulaidl.core.ICatalogMetadata|null} [catalogKey] TaskNodeMetadata catalogKey
                 * @property {nebulaidl.core.CatalogReservation.Status|null} [reservationStatus] TaskNodeMetadata reservationStatus
                 * @property {string|null} [checkpointUri] TaskNodeMetadata checkpointUri
                 * @property {nebulaidl.event.IDynamicWorkflowNodeMetadata|null} [dynamicWorkflow] TaskNodeMetadata dynamicWorkflow
                 */
    
                /**
                 * Constructs a new TaskNodeMetadata.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a TaskNodeMetadata.
                 * @implements ITaskNodeMetadata
                 * @constructor
                 * @param {nebulaidl.event.ITaskNodeMetadata=} [properties] Properties to set
                 */
                function TaskNodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskNodeMetadata cacheStatus.
                 * @member {nebulaidl.core.CatalogCacheStatus} cacheStatus
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.cacheStatus = 0;
    
                /**
                 * TaskNodeMetadata catalogKey.
                 * @member {nebulaidl.core.ICatalogMetadata|null|undefined} catalogKey
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.catalogKey = null;
    
                /**
                 * TaskNodeMetadata reservationStatus.
                 * @member {nebulaidl.core.CatalogReservation.Status} reservationStatus
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.reservationStatus = 0;
    
                /**
                 * TaskNodeMetadata checkpointUri.
                 * @member {string} checkpointUri
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.checkpointUri = "";
    
                /**
                 * TaskNodeMetadata dynamicWorkflow.
                 * @member {nebulaidl.event.IDynamicWorkflowNodeMetadata|null|undefined} dynamicWorkflow
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.dynamicWorkflow = null;
    
                /**
                 * Creates a new TaskNodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @static
                 * @param {nebulaidl.event.ITaskNodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.event.TaskNodeMetadata} TaskNodeMetadata instance
                 */
                TaskNodeMetadata.create = function create(properties) {
                    return new TaskNodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified TaskNodeMetadata message. Does not implicitly {@link nebulaidl.event.TaskNodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @static
                 * @param {nebulaidl.event.ITaskNodeMetadata} message TaskNodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskNodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cacheStatus);
                    if (message.catalogKey != null && message.hasOwnProperty("catalogKey"))
                        $root.nebulaidl.core.CatalogMetadata.encode(message.catalogKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.reservationStatus != null && message.hasOwnProperty("reservationStatus"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reservationStatus);
                    if (message.checkpointUri != null && message.hasOwnProperty("checkpointUri"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.checkpointUri);
                    if (message.dynamicWorkflow != null && message.hasOwnProperty("dynamicWorkflow"))
                        $root.nebulaidl.event.DynamicWorkflowNodeMetadata.encode(message.dynamicWorkflow, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskNodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.TaskNodeMetadata} TaskNodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskNodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.TaskNodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cacheStatus = reader.int32();
                            break;
                        case 2:
                            message.catalogKey = $root.nebulaidl.core.CatalogMetadata.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.reservationStatus = reader.int32();
                            break;
                        case 4:
                            message.checkpointUri = reader.string();
                            break;
                        case 16:
                            message.dynamicWorkflow = $root.nebulaidl.event.DynamicWorkflowNodeMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskNodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.event.TaskNodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskNodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
                        switch (message.cacheStatus) {
                        default:
                            return "cacheStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.catalogKey != null && message.hasOwnProperty("catalogKey")) {
                        var error = $root.nebulaidl.core.CatalogMetadata.verify(message.catalogKey);
                        if (error)
                            return "catalogKey." + error;
                    }
                    if (message.reservationStatus != null && message.hasOwnProperty("reservationStatus"))
                        switch (message.reservationStatus) {
                        default:
                            return "reservationStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.checkpointUri != null && message.hasOwnProperty("checkpointUri"))
                        if (!$util.isString(message.checkpointUri))
                            return "checkpointUri: string expected";
                    if (message.dynamicWorkflow != null && message.hasOwnProperty("dynamicWorkflow")) {
                        var error = $root.nebulaidl.event.DynamicWorkflowNodeMetadata.verify(message.dynamicWorkflow);
                        if (error)
                            return "dynamicWorkflow." + error;
                    }
                    return null;
                };
    
                return TaskNodeMetadata;
            })();
    
            event.DynamicWorkflowNodeMetadata = (function() {
    
                /**
                 * Properties of a DynamicWorkflowNodeMetadata.
                 * @memberof nebulaidl.event
                 * @interface IDynamicWorkflowNodeMetadata
                 * @property {nebulaidl.core.IIdentifier|null} [id] DynamicWorkflowNodeMetadata id
                 * @property {nebulaidl.core.ICompiledWorkflowClosure|null} [compiledWorkflow] DynamicWorkflowNodeMetadata compiledWorkflow
                 * @property {string|null} [dynamicJobSpecUri] DynamicWorkflowNodeMetadata dynamicJobSpecUri
                 */
    
                /**
                 * Constructs a new DynamicWorkflowNodeMetadata.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a DynamicWorkflowNodeMetadata.
                 * @implements IDynamicWorkflowNodeMetadata
                 * @constructor
                 * @param {nebulaidl.event.IDynamicWorkflowNodeMetadata=} [properties] Properties to set
                 */
                function DynamicWorkflowNodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DynamicWorkflowNodeMetadata id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @instance
                 */
                DynamicWorkflowNodeMetadata.prototype.id = null;
    
                /**
                 * DynamicWorkflowNodeMetadata compiledWorkflow.
                 * @member {nebulaidl.core.ICompiledWorkflowClosure|null|undefined} compiledWorkflow
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @instance
                 */
                DynamicWorkflowNodeMetadata.prototype.compiledWorkflow = null;
    
                /**
                 * DynamicWorkflowNodeMetadata dynamicJobSpecUri.
                 * @member {string} dynamicJobSpecUri
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @instance
                 */
                DynamicWorkflowNodeMetadata.prototype.dynamicJobSpecUri = "";
    
                /**
                 * Creates a new DynamicWorkflowNodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.event.IDynamicWorkflowNodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.event.DynamicWorkflowNodeMetadata} DynamicWorkflowNodeMetadata instance
                 */
                DynamicWorkflowNodeMetadata.create = function create(properties) {
                    return new DynamicWorkflowNodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified DynamicWorkflowNodeMetadata message. Does not implicitly {@link nebulaidl.event.DynamicWorkflowNodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.event.IDynamicWorkflowNodeMetadata} message DynamicWorkflowNodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DynamicWorkflowNodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow"))
                        $root.nebulaidl.core.CompiledWorkflowClosure.encode(message.compiledWorkflow, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.dynamicJobSpecUri != null && message.hasOwnProperty("dynamicJobSpecUri"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dynamicJobSpecUri);
                    return writer;
                };
    
                /**
                 * Decodes a DynamicWorkflowNodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.DynamicWorkflowNodeMetadata} DynamicWorkflowNodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DynamicWorkflowNodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.DynamicWorkflowNodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.compiledWorkflow = $root.nebulaidl.core.CompiledWorkflowClosure.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.dynamicJobSpecUri = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DynamicWorkflowNodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.event.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DynamicWorkflowNodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow")) {
                        var error = $root.nebulaidl.core.CompiledWorkflowClosure.verify(message.compiledWorkflow);
                        if (error)
                            return "compiledWorkflow." + error;
                    }
                    if (message.dynamicJobSpecUri != null && message.hasOwnProperty("dynamicJobSpecUri"))
                        if (!$util.isString(message.dynamicJobSpecUri))
                            return "dynamicJobSpecUri: string expected";
                    return null;
                };
    
                return DynamicWorkflowNodeMetadata;
            })();
    
            event.ParentTaskExecutionMetadata = (function() {
    
                /**
                 * Properties of a ParentTaskExecutionMetadata.
                 * @memberof nebulaidl.event
                 * @interface IParentTaskExecutionMetadata
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [id] ParentTaskExecutionMetadata id
                 */
    
                /**
                 * Constructs a new ParentTaskExecutionMetadata.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a ParentTaskExecutionMetadata.
                 * @implements IParentTaskExecutionMetadata
                 * @constructor
                 * @param {nebulaidl.event.IParentTaskExecutionMetadata=} [properties] Properties to set
                 */
                function ParentTaskExecutionMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ParentTaskExecutionMetadata id.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.event.ParentTaskExecutionMetadata
                 * @instance
                 */
                ParentTaskExecutionMetadata.prototype.id = null;
    
                /**
                 * Creates a new ParentTaskExecutionMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.ParentTaskExecutionMetadata
                 * @static
                 * @param {nebulaidl.event.IParentTaskExecutionMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.event.ParentTaskExecutionMetadata} ParentTaskExecutionMetadata instance
                 */
                ParentTaskExecutionMetadata.create = function create(properties) {
                    return new ParentTaskExecutionMetadata(properties);
                };
    
                /**
                 * Encodes the specified ParentTaskExecutionMetadata message. Does not implicitly {@link nebulaidl.event.ParentTaskExecutionMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.ParentTaskExecutionMetadata
                 * @static
                 * @param {nebulaidl.event.IParentTaskExecutionMetadata} message ParentTaskExecutionMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParentTaskExecutionMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ParentTaskExecutionMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.ParentTaskExecutionMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.ParentTaskExecutionMetadata} ParentTaskExecutionMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParentTaskExecutionMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.ParentTaskExecutionMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ParentTaskExecutionMetadata message.
                 * @function verify
                 * @memberof nebulaidl.event.ParentTaskExecutionMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ParentTaskExecutionMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return ParentTaskExecutionMetadata;
            })();
    
            event.ParentNodeExecutionMetadata = (function() {
    
                /**
                 * Properties of a ParentNodeExecutionMetadata.
                 * @memberof nebulaidl.event
                 * @interface IParentNodeExecutionMetadata
                 * @property {string|null} [nodeId] ParentNodeExecutionMetadata nodeId
                 */
    
                /**
                 * Constructs a new ParentNodeExecutionMetadata.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a ParentNodeExecutionMetadata.
                 * @implements IParentNodeExecutionMetadata
                 * @constructor
                 * @param {nebulaidl.event.IParentNodeExecutionMetadata=} [properties] Properties to set
                 */
                function ParentNodeExecutionMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ParentNodeExecutionMetadata nodeId.
                 * @member {string} nodeId
                 * @memberof nebulaidl.event.ParentNodeExecutionMetadata
                 * @instance
                 */
                ParentNodeExecutionMetadata.prototype.nodeId = "";
    
                /**
                 * Creates a new ParentNodeExecutionMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.ParentNodeExecutionMetadata
                 * @static
                 * @param {nebulaidl.event.IParentNodeExecutionMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.event.ParentNodeExecutionMetadata} ParentNodeExecutionMetadata instance
                 */
                ParentNodeExecutionMetadata.create = function create(properties) {
                    return new ParentNodeExecutionMetadata(properties);
                };
    
                /**
                 * Encodes the specified ParentNodeExecutionMetadata message. Does not implicitly {@link nebulaidl.event.ParentNodeExecutionMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.ParentNodeExecutionMetadata
                 * @static
                 * @param {nebulaidl.event.IParentNodeExecutionMetadata} message ParentNodeExecutionMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParentNodeExecutionMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                    return writer;
                };
    
                /**
                 * Decodes a ParentNodeExecutionMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.ParentNodeExecutionMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.ParentNodeExecutionMetadata} ParentNodeExecutionMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParentNodeExecutionMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.ParentNodeExecutionMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nodeId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ParentNodeExecutionMetadata message.
                 * @function verify
                 * @memberof nebulaidl.event.ParentNodeExecutionMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ParentNodeExecutionMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                        if (!$util.isString(message.nodeId))
                            return "nodeId: string expected";
                    return null;
                };
    
                return ParentNodeExecutionMetadata;
            })();
    
            event.EventReason = (function() {
    
                /**
                 * Properties of an EventReason.
                 * @memberof nebulaidl.event
                 * @interface IEventReason
                 * @property {string|null} [reason] EventReason reason
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] EventReason occurredAt
                 */
    
                /**
                 * Constructs a new EventReason.
                 * @memberof nebulaidl.event
                 * @classdesc Represents an EventReason.
                 * @implements IEventReason
                 * @constructor
                 * @param {nebulaidl.event.IEventReason=} [properties] Properties to set
                 */
                function EventReason(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventReason reason.
                 * @member {string} reason
                 * @memberof nebulaidl.event.EventReason
                 * @instance
                 */
                EventReason.prototype.reason = "";
    
                /**
                 * EventReason occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof nebulaidl.event.EventReason
                 * @instance
                 */
                EventReason.prototype.occurredAt = null;
    
                /**
                 * Creates a new EventReason instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.EventReason
                 * @static
                 * @param {nebulaidl.event.IEventReason=} [properties] Properties to set
                 * @returns {nebulaidl.event.EventReason} EventReason instance
                 */
                EventReason.create = function create(properties) {
                    return new EventReason(properties);
                };
    
                /**
                 * Encodes the specified EventReason message. Does not implicitly {@link nebulaidl.event.EventReason.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.EventReason
                 * @static
                 * @param {nebulaidl.event.IEventReason} message EventReason message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventReason.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EventReason message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.EventReason
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.EventReason} EventReason
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventReason.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.EventReason();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reason = reader.string();
                            break;
                        case 2:
                            message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EventReason message.
                 * @function verify
                 * @memberof nebulaidl.event.EventReason
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventReason.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    return null;
                };
    
                return EventReason;
            })();
    
            event.TaskExecutionEvent = (function() {
    
                /**
                 * Properties of a TaskExecutionEvent.
                 * @memberof nebulaidl.event
                 * @interface ITaskExecutionEvent
                 * @property {nebulaidl.core.IIdentifier|null} [taskId] TaskExecutionEvent taskId
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [parentNodeExecutionId] TaskExecutionEvent parentNodeExecutionId
                 * @property {number|null} [retryAttempt] TaskExecutionEvent retryAttempt
                 * @property {nebulaidl.core.TaskExecution.Phase|null} [phase] TaskExecutionEvent phase
                 * @property {string|null} [producerId] TaskExecutionEvent producerId
                 * @property {Array.<nebulaidl.core.ITaskLog>|null} [logs] TaskExecutionEvent logs
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] TaskExecutionEvent occurredAt
                 * @property {string|null} [inputUri] TaskExecutionEvent inputUri
                 * @property {nebulaidl.core.ILiteralMap|null} [inputData] TaskExecutionEvent inputData
                 * @property {string|null} [outputUri] TaskExecutionEvent outputUri
                 * @property {nebulaidl.core.IExecutionError|null} [error] TaskExecutionEvent error
                 * @property {nebulaidl.core.ILiteralMap|null} [outputData] TaskExecutionEvent outputData
                 * @property {google.protobuf.IStruct|null} [customInfo] TaskExecutionEvent customInfo
                 * @property {number|null} [phaseVersion] TaskExecutionEvent phaseVersion
                 * @property {string|null} [reason] TaskExecutionEvent reason
                 * @property {Array.<nebulaidl.event.IEventReason>|null} [reasons] TaskExecutionEvent reasons
                 * @property {string|null} [taskType] TaskExecutionEvent taskType
                 * @property {nebulaidl.event.ITaskExecutionMetadata|null} [metadata] TaskExecutionEvent metadata
                 * @property {number|null} [eventVersion] TaskExecutionEvent eventVersion
                 * @property {google.protobuf.ITimestamp|null} [reportedAt] TaskExecutionEvent reportedAt
                 */
    
                /**
                 * Constructs a new TaskExecutionEvent.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a TaskExecutionEvent.
                 * @implements ITaskExecutionEvent
                 * @constructor
                 * @param {nebulaidl.event.ITaskExecutionEvent=} [properties] Properties to set
                 */
                function TaskExecutionEvent(properties) {
                    this.logs = [];
                    this.reasons = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionEvent taskId.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} taskId
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.taskId = null;
    
                /**
                 * TaskExecutionEvent parentNodeExecutionId.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} parentNodeExecutionId
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.parentNodeExecutionId = null;
    
                /**
                 * TaskExecutionEvent retryAttempt.
                 * @member {number} retryAttempt
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.retryAttempt = 0;
    
                /**
                 * TaskExecutionEvent phase.
                 * @member {nebulaidl.core.TaskExecution.Phase} phase
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.phase = 0;
    
                /**
                 * TaskExecutionEvent producerId.
                 * @member {string} producerId
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.producerId = "";
    
                /**
                 * TaskExecutionEvent logs.
                 * @member {Array.<nebulaidl.core.ITaskLog>} logs
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.logs = $util.emptyArray;
    
                /**
                 * TaskExecutionEvent occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.occurredAt = null;
    
                /**
                 * TaskExecutionEvent inputUri.
                 * @member {string} inputUri
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.inputUri = "";
    
                /**
                 * TaskExecutionEvent inputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} inputData
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.inputData = null;
    
                /**
                 * TaskExecutionEvent outputUri.
                 * @member {string} outputUri
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.outputUri = "";
    
                /**
                 * TaskExecutionEvent error.
                 * @member {nebulaidl.core.IExecutionError|null|undefined} error
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.error = null;
    
                /**
                 * TaskExecutionEvent outputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputData
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.outputData = null;
    
                /**
                 * TaskExecutionEvent customInfo.
                 * @member {google.protobuf.IStruct|null|undefined} customInfo
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.customInfo = null;
    
                /**
                 * TaskExecutionEvent phaseVersion.
                 * @member {number} phaseVersion
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.phaseVersion = 0;
    
                /**
                 * TaskExecutionEvent reason.
                 * @member {string} reason
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.reason = "";
    
                /**
                 * TaskExecutionEvent reasons.
                 * @member {Array.<nebulaidl.event.IEventReason>} reasons
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.reasons = $util.emptyArray;
    
                /**
                 * TaskExecutionEvent taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.taskType = "";
    
                /**
                 * TaskExecutionEvent metadata.
                 * @member {nebulaidl.event.ITaskExecutionMetadata|null|undefined} metadata
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.metadata = null;
    
                /**
                 * TaskExecutionEvent eventVersion.
                 * @member {number} eventVersion
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.eventVersion = 0;
    
                /**
                 * TaskExecutionEvent reportedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} reportedAt
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                TaskExecutionEvent.prototype.reportedAt = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * TaskExecutionEvent inputValue.
                 * @member {"inputUri"|"inputData"|undefined} inputValue
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                Object.defineProperty(TaskExecutionEvent.prototype, "inputValue", {
                    get: $util.oneOfGetter($oneOfFields = ["inputUri", "inputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * TaskExecutionEvent outputResult.
                 * @member {"outputUri"|"error"|"outputData"|undefined} outputResult
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @instance
                 */
                Object.defineProperty(TaskExecutionEvent.prototype, "outputResult", {
                    get: $util.oneOfGetter($oneOfFields = ["outputUri", "error", "outputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new TaskExecutionEvent instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @static
                 * @param {nebulaidl.event.ITaskExecutionEvent=} [properties] Properties to set
                 * @returns {nebulaidl.event.TaskExecutionEvent} TaskExecutionEvent instance
                 */
                TaskExecutionEvent.create = function create(properties) {
                    return new TaskExecutionEvent(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionEvent message. Does not implicitly {@link nebulaidl.event.TaskExecutionEvent.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @static
                 * @param {nebulaidl.event.ITaskExecutionEvent} message TaskExecutionEvent message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionEvent.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        $root.nebulaidl.core.Identifier.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.parentNodeExecutionId != null && message.hasOwnProperty("parentNodeExecutionId"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.parentNodeExecutionId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryAttempt);
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.phase);
                    if (message.producerId != null && message.hasOwnProperty("producerId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.producerId);
                    if (message.logs != null && message.logs.length)
                        for (var i = 0; i < message.logs.length; ++i)
                            $root.nebulaidl.core.TaskLog.encode(message.logs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.inputUri);
                    if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.outputUri);
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.customInfo != null && message.hasOwnProperty("customInfo"))
                        $root.google.protobuf.Struct.encode(message.customInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.phaseVersion != null && message.hasOwnProperty("phaseVersion"))
                        writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.phaseVersion);
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.reason);
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.taskType);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.event.TaskExecutionMetadata.encode(message.metadata, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.outputData != null && message.hasOwnProperty("outputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputData, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.eventVersion);
                    if (message.inputData != null && message.hasOwnProperty("inputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.inputData, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.reportedAt != null && message.hasOwnProperty("reportedAt"))
                        $root.google.protobuf.Timestamp.encode(message.reportedAt, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.reasons != null && message.reasons.length)
                        for (var i = 0; i < message.reasons.length; ++i)
                            $root.nebulaidl.event.EventReason.encode(message.reasons[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionEvent message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.TaskExecutionEvent} TaskExecutionEvent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionEvent.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.TaskExecutionEvent();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskId = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.parentNodeExecutionId = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.retryAttempt = reader.uint32();
                            break;
                        case 4:
                            message.phase = reader.int32();
                            break;
                        case 5:
                            message.producerId = reader.string();
                            break;
                        case 6:
                            if (!(message.logs && message.logs.length))
                                message.logs = [];
                            message.logs.push($root.nebulaidl.core.TaskLog.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.inputUri = reader.string();
                            break;
                        case 19:
                            message.inputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.outputUri = reader.string();
                            break;
                        case 10:
                            message.error = $root.nebulaidl.core.ExecutionError.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.outputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.customInfo = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.phaseVersion = reader.uint32();
                            break;
                        case 13:
                            message.reason = reader.string();
                            break;
                        case 21:
                            if (!(message.reasons && message.reasons.length))
                                message.reasons = [];
                            message.reasons.push($root.nebulaidl.event.EventReason.decode(reader, reader.uint32()));
                            break;
                        case 14:
                            message.taskType = reader.string();
                            break;
                        case 16:
                            message.metadata = $root.nebulaidl.event.TaskExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.eventVersion = reader.int32();
                            break;
                        case 20:
                            message.reportedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionEvent message.
                 * @function verify
                 * @memberof nebulaidl.event.TaskExecutionEvent
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionEvent.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.taskId != null && message.hasOwnProperty("taskId")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.taskId);
                        if (error)
                            return "taskId." + error;
                    }
                    if (message.parentNodeExecutionId != null && message.hasOwnProperty("parentNodeExecutionId")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.parentNodeExecutionId);
                        if (error)
                            return "parentNodeExecutionId." + error;
                    }
                    if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                        if (!$util.isInteger(message.retryAttempt))
                            return "retryAttempt: integer expected";
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.producerId != null && message.hasOwnProperty("producerId"))
                        if (!$util.isString(message.producerId))
                            return "producerId: string expected";
                    if (message.logs != null && message.hasOwnProperty("logs")) {
                        if (!Array.isArray(message.logs))
                            return "logs: array expected";
                        for (var i = 0; i < message.logs.length; ++i) {
                            var error = $root.nebulaidl.core.TaskLog.verify(message.logs[i]);
                            if (error)
                                return "logs." + error;
                        }
                    }
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.inputUri != null && message.hasOwnProperty("inputUri")) {
                        properties.inputValue = 1;
                        if (!$util.isString(message.inputUri))
                            return "inputUri: string expected";
                    }
                    if (message.inputData != null && message.hasOwnProperty("inputData")) {
                        if (properties.inputValue === 1)
                            return "inputValue: multiple values";
                        properties.inputValue = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.inputData);
                            if (error)
                                return "inputData." + error;
                        }
                    }
                    if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                        properties.outputResult = 1;
                        if (!$util.isString(message.outputUri))
                            return "outputUri: string expected";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.ExecutionError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.outputData != null && message.hasOwnProperty("outputData")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.outputData);
                            if (error)
                                return "outputData." + error;
                        }
                    }
                    if (message.customInfo != null && message.hasOwnProperty("customInfo")) {
                        var error = $root.google.protobuf.Struct.verify(message.customInfo);
                        if (error)
                            return "customInfo." + error;
                    }
                    if (message.phaseVersion != null && message.hasOwnProperty("phaseVersion"))
                        if (!$util.isInteger(message.phaseVersion))
                            return "phaseVersion: integer expected";
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.reasons != null && message.hasOwnProperty("reasons")) {
                        if (!Array.isArray(message.reasons))
                            return "reasons: array expected";
                        for (var i = 0; i < message.reasons.length; ++i) {
                            var error = $root.nebulaidl.event.EventReason.verify(message.reasons[i]);
                            if (error)
                                return "reasons." + error;
                        }
                    }
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.event.TaskExecutionMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
                        if (!$util.isInteger(message.eventVersion))
                            return "eventVersion: integer expected";
                    if (message.reportedAt != null && message.hasOwnProperty("reportedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.reportedAt);
                        if (error)
                            return "reportedAt." + error;
                    }
                    return null;
                };
    
                return TaskExecutionEvent;
            })();
    
            event.ExternalResourceInfo = (function() {
    
                /**
                 * Properties of an ExternalResourceInfo.
                 * @memberof nebulaidl.event
                 * @interface IExternalResourceInfo
                 * @property {string|null} [externalId] ExternalResourceInfo externalId
                 * @property {number|null} [index] ExternalResourceInfo index
                 * @property {number|null} [retryAttempt] ExternalResourceInfo retryAttempt
                 * @property {nebulaidl.core.TaskExecution.Phase|null} [phase] ExternalResourceInfo phase
                 * @property {nebulaidl.core.CatalogCacheStatus|null} [cacheStatus] ExternalResourceInfo cacheStatus
                 * @property {Array.<nebulaidl.core.ITaskLog>|null} [logs] ExternalResourceInfo logs
                 */
    
                /**
                 * Constructs a new ExternalResourceInfo.
                 * @memberof nebulaidl.event
                 * @classdesc Represents an ExternalResourceInfo.
                 * @implements IExternalResourceInfo
                 * @constructor
                 * @param {nebulaidl.event.IExternalResourceInfo=} [properties] Properties to set
                 */
                function ExternalResourceInfo(properties) {
                    this.logs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExternalResourceInfo externalId.
                 * @member {string} externalId
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @instance
                 */
                ExternalResourceInfo.prototype.externalId = "";
    
                /**
                 * ExternalResourceInfo index.
                 * @member {number} index
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @instance
                 */
                ExternalResourceInfo.prototype.index = 0;
    
                /**
                 * ExternalResourceInfo retryAttempt.
                 * @member {number} retryAttempt
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @instance
                 */
                ExternalResourceInfo.prototype.retryAttempt = 0;
    
                /**
                 * ExternalResourceInfo phase.
                 * @member {nebulaidl.core.TaskExecution.Phase} phase
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @instance
                 */
                ExternalResourceInfo.prototype.phase = 0;
    
                /**
                 * ExternalResourceInfo cacheStatus.
                 * @member {nebulaidl.core.CatalogCacheStatus} cacheStatus
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @instance
                 */
                ExternalResourceInfo.prototype.cacheStatus = 0;
    
                /**
                 * ExternalResourceInfo logs.
                 * @member {Array.<nebulaidl.core.ITaskLog>} logs
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @instance
                 */
                ExternalResourceInfo.prototype.logs = $util.emptyArray;
    
                /**
                 * Creates a new ExternalResourceInfo instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @static
                 * @param {nebulaidl.event.IExternalResourceInfo=} [properties] Properties to set
                 * @returns {nebulaidl.event.ExternalResourceInfo} ExternalResourceInfo instance
                 */
                ExternalResourceInfo.create = function create(properties) {
                    return new ExternalResourceInfo(properties);
                };
    
                /**
                 * Encodes the specified ExternalResourceInfo message. Does not implicitly {@link nebulaidl.event.ExternalResourceInfo.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @static
                 * @param {nebulaidl.event.IExternalResourceInfo} message ExternalResourceInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExternalResourceInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.externalId != null && message.hasOwnProperty("externalId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.externalId);
                    if (message.index != null && message.hasOwnProperty("index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                    if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryAttempt);
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.phase);
                    if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cacheStatus);
                    if (message.logs != null && message.logs.length)
                        for (var i = 0; i < message.logs.length; ++i)
                            $root.nebulaidl.core.TaskLog.encode(message.logs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ExternalResourceInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.ExternalResourceInfo} ExternalResourceInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExternalResourceInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.ExternalResourceInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.externalId = reader.string();
                            break;
                        case 2:
                            message.index = reader.uint32();
                            break;
                        case 3:
                            message.retryAttempt = reader.uint32();
                            break;
                        case 4:
                            message.phase = reader.int32();
                            break;
                        case 5:
                            message.cacheStatus = reader.int32();
                            break;
                        case 6:
                            if (!(message.logs && message.logs.length))
                                message.logs = [];
                            message.logs.push($root.nebulaidl.core.TaskLog.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExternalResourceInfo message.
                 * @function verify
                 * @memberof nebulaidl.event.ExternalResourceInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExternalResourceInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.externalId != null && message.hasOwnProperty("externalId"))
                        if (!$util.isString(message.externalId))
                            return "externalId: string expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.retryAttempt != null && message.hasOwnProperty("retryAttempt"))
                        if (!$util.isInteger(message.retryAttempt))
                            return "retryAttempt: integer expected";
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
                        switch (message.cacheStatus) {
                        default:
                            return "cacheStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.logs != null && message.hasOwnProperty("logs")) {
                        if (!Array.isArray(message.logs))
                            return "logs: array expected";
                        for (var i = 0; i < message.logs.length; ++i) {
                            var error = $root.nebulaidl.core.TaskLog.verify(message.logs[i]);
                            if (error)
                                return "logs." + error;
                        }
                    }
                    return null;
                };
    
                return ExternalResourceInfo;
            })();
    
            event.ResourcePoolInfo = (function() {
    
                /**
                 * Properties of a ResourcePoolInfo.
                 * @memberof nebulaidl.event
                 * @interface IResourcePoolInfo
                 * @property {string|null} [allocationToken] ResourcePoolInfo allocationToken
                 * @property {string|null} [namespace] ResourcePoolInfo namespace
                 */
    
                /**
                 * Constructs a new ResourcePoolInfo.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a ResourcePoolInfo.
                 * @implements IResourcePoolInfo
                 * @constructor
                 * @param {nebulaidl.event.IResourcePoolInfo=} [properties] Properties to set
                 */
                function ResourcePoolInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ResourcePoolInfo allocationToken.
                 * @member {string} allocationToken
                 * @memberof nebulaidl.event.ResourcePoolInfo
                 * @instance
                 */
                ResourcePoolInfo.prototype.allocationToken = "";
    
                /**
                 * ResourcePoolInfo namespace.
                 * @member {string} namespace
                 * @memberof nebulaidl.event.ResourcePoolInfo
                 * @instance
                 */
                ResourcePoolInfo.prototype.namespace = "";
    
                /**
                 * Creates a new ResourcePoolInfo instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.ResourcePoolInfo
                 * @static
                 * @param {nebulaidl.event.IResourcePoolInfo=} [properties] Properties to set
                 * @returns {nebulaidl.event.ResourcePoolInfo} ResourcePoolInfo instance
                 */
                ResourcePoolInfo.create = function create(properties) {
                    return new ResourcePoolInfo(properties);
                };
    
                /**
                 * Encodes the specified ResourcePoolInfo message. Does not implicitly {@link nebulaidl.event.ResourcePoolInfo.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.ResourcePoolInfo
                 * @static
                 * @param {nebulaidl.event.IResourcePoolInfo} message ResourcePoolInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ResourcePoolInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allocationToken != null && message.hasOwnProperty("allocationToken"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.allocationToken);
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                    return writer;
                };
    
                /**
                 * Decodes a ResourcePoolInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.ResourcePoolInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.ResourcePoolInfo} ResourcePoolInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ResourcePoolInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.ResourcePoolInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.allocationToken = reader.string();
                            break;
                        case 2:
                            message.namespace = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ResourcePoolInfo message.
                 * @function verify
                 * @memberof nebulaidl.event.ResourcePoolInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResourcePoolInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allocationToken != null && message.hasOwnProperty("allocationToken"))
                        if (!$util.isString(message.allocationToken))
                            return "allocationToken: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    return null;
                };
    
                return ResourcePoolInfo;
            })();
    
            event.TaskExecutionMetadata = (function() {
    
                /**
                 * Properties of a TaskExecutionMetadata.
                 * @memberof nebulaidl.event
                 * @interface ITaskExecutionMetadata
                 * @property {string|null} [generatedName] TaskExecutionMetadata generatedName
                 * @property {Array.<nebulaidl.event.IExternalResourceInfo>|null} [externalResources] TaskExecutionMetadata externalResources
                 * @property {Array.<nebulaidl.event.IResourcePoolInfo>|null} [resourcePoolInfo] TaskExecutionMetadata resourcePoolInfo
                 * @property {string|null} [pluginIdentifier] TaskExecutionMetadata pluginIdentifier
                 * @property {nebulaidl.event.TaskExecutionMetadata.InstanceClass|null} [instanceClass] TaskExecutionMetadata instanceClass
                 */
    
                /**
                 * Constructs a new TaskExecutionMetadata.
                 * @memberof nebulaidl.event
                 * @classdesc Represents a TaskExecutionMetadata.
                 * @implements ITaskExecutionMetadata
                 * @constructor
                 * @param {nebulaidl.event.ITaskExecutionMetadata=} [properties] Properties to set
                 */
                function TaskExecutionMetadata(properties) {
                    this.externalResources = [];
                    this.resourcePoolInfo = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionMetadata generatedName.
                 * @member {string} generatedName
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.generatedName = "";
    
                /**
                 * TaskExecutionMetadata externalResources.
                 * @member {Array.<nebulaidl.event.IExternalResourceInfo>} externalResources
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.externalResources = $util.emptyArray;
    
                /**
                 * TaskExecutionMetadata resourcePoolInfo.
                 * @member {Array.<nebulaidl.event.IResourcePoolInfo>} resourcePoolInfo
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.resourcePoolInfo = $util.emptyArray;
    
                /**
                 * TaskExecutionMetadata pluginIdentifier.
                 * @member {string} pluginIdentifier
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.pluginIdentifier = "";
    
                /**
                 * TaskExecutionMetadata instanceClass.
                 * @member {nebulaidl.event.TaskExecutionMetadata.InstanceClass} instanceClass
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.instanceClass = 0;
    
                /**
                 * Creates a new TaskExecutionMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @static
                 * @param {nebulaidl.event.ITaskExecutionMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.event.TaskExecutionMetadata} TaskExecutionMetadata instance
                 */
                TaskExecutionMetadata.create = function create(properties) {
                    return new TaskExecutionMetadata(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionMetadata message. Does not implicitly {@link nebulaidl.event.TaskExecutionMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @static
                 * @param {nebulaidl.event.ITaskExecutionMetadata} message TaskExecutionMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.generatedName != null && message.hasOwnProperty("generatedName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.generatedName);
                    if (message.externalResources != null && message.externalResources.length)
                        for (var i = 0; i < message.externalResources.length; ++i)
                            $root.nebulaidl.event.ExternalResourceInfo.encode(message.externalResources[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.resourcePoolInfo != null && message.resourcePoolInfo.length)
                        for (var i = 0; i < message.resourcePoolInfo.length; ++i)
                            $root.nebulaidl.event.ResourcePoolInfo.encode(message.resourcePoolInfo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.pluginIdentifier != null && message.hasOwnProperty("pluginIdentifier"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.pluginIdentifier);
                    if (message.instanceClass != null && message.hasOwnProperty("instanceClass"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.instanceClass);
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.event.TaskExecutionMetadata} TaskExecutionMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.event.TaskExecutionMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.generatedName = reader.string();
                            break;
                        case 2:
                            if (!(message.externalResources && message.externalResources.length))
                                message.externalResources = [];
                            message.externalResources.push($root.nebulaidl.event.ExternalResourceInfo.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.resourcePoolInfo && message.resourcePoolInfo.length))
                                message.resourcePoolInfo = [];
                            message.resourcePoolInfo.push($root.nebulaidl.event.ResourcePoolInfo.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.pluginIdentifier = reader.string();
                            break;
                        case 16:
                            message.instanceClass = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionMetadata message.
                 * @function verify
                 * @memberof nebulaidl.event.TaskExecutionMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.generatedName != null && message.hasOwnProperty("generatedName"))
                        if (!$util.isString(message.generatedName))
                            return "generatedName: string expected";
                    if (message.externalResources != null && message.hasOwnProperty("externalResources")) {
                        if (!Array.isArray(message.externalResources))
                            return "externalResources: array expected";
                        for (var i = 0; i < message.externalResources.length; ++i) {
                            var error = $root.nebulaidl.event.ExternalResourceInfo.verify(message.externalResources[i]);
                            if (error)
                                return "externalResources." + error;
                        }
                    }
                    if (message.resourcePoolInfo != null && message.hasOwnProperty("resourcePoolInfo")) {
                        if (!Array.isArray(message.resourcePoolInfo))
                            return "resourcePoolInfo: array expected";
                        for (var i = 0; i < message.resourcePoolInfo.length; ++i) {
                            var error = $root.nebulaidl.event.ResourcePoolInfo.verify(message.resourcePoolInfo[i]);
                            if (error)
                                return "resourcePoolInfo." + error;
                        }
                    }
                    if (message.pluginIdentifier != null && message.hasOwnProperty("pluginIdentifier"))
                        if (!$util.isString(message.pluginIdentifier))
                            return "pluginIdentifier: string expected";
                    if (message.instanceClass != null && message.hasOwnProperty("instanceClass"))
                        switch (message.instanceClass) {
                        default:
                            return "instanceClass: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * InstanceClass enum.
                 * @name nebulaidl.event.TaskExecutionMetadata.InstanceClass
                 * @enum {string}
                 * @property {number} DEFAULT=0 DEFAULT value
                 * @property {number} INTERRUPTIBLE=1 INTERRUPTIBLE value
                 */
                TaskExecutionMetadata.InstanceClass = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DEFAULT"] = 0;
                    values[valuesById[1] = "INTERRUPTIBLE"] = 1;
                    return values;
                })();
    
                return TaskExecutionMetadata;
            })();
    
            return event;
        })();
    
        nebulaidl.admin = (function() {
    
            /**
             * Namespace admin.
             * @memberof nebulaidl
             * @namespace
             */
            var admin = {};
    
            /**
             * State enum.
             * @name nebulaidl.admin.State
             * @enum {string}
             * @property {number} RETRYABLE_FAILURE=0 RETRYABLE_FAILURE value
             * @property {number} PERMANENT_FAILURE=1 PERMANENT_FAILURE value
             * @property {number} PENDING=2 PENDING value
             * @property {number} RUNNING=3 RUNNING value
             * @property {number} SUCCEEDED=4 SUCCEEDED value
             */
            admin.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RETRYABLE_FAILURE"] = 0;
                values[valuesById[1] = "PERMANENT_FAILURE"] = 1;
                values[valuesById[2] = "PENDING"] = 2;
                values[valuesById[3] = "RUNNING"] = 3;
                values[valuesById[4] = "SUCCEEDED"] = 4;
                return values;
            })();
    
            admin.TaskExecutionMetadata = (function() {
    
                /**
                 * Properties of a TaskExecutionMetadata.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionMetadata
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [taskExecutionId] TaskExecutionMetadata taskExecutionId
                 * @property {string|null} [namespace] TaskExecutionMetadata namespace
                 * @property {Object.<string,string>|null} [labels] TaskExecutionMetadata labels
                 * @property {Object.<string,string>|null} [annotations] TaskExecutionMetadata annotations
                 * @property {string|null} [k8sServiceAccount] TaskExecutionMetadata k8sServiceAccount
                 * @property {Object.<string,string>|null} [environmentVariables] TaskExecutionMetadata environmentVariables
                 */
    
                /**
                 * Constructs a new TaskExecutionMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionMetadata.
                 * @implements ITaskExecutionMetadata
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionMetadata=} [properties] Properties to set
                 */
                function TaskExecutionMetadata(properties) {
                    this.labels = {};
                    this.annotations = {};
                    this.environmentVariables = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionMetadata taskExecutionId.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} taskExecutionId
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.taskExecutionId = null;
    
                /**
                 * TaskExecutionMetadata namespace.
                 * @member {string} namespace
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.namespace = "";
    
                /**
                 * TaskExecutionMetadata labels.
                 * @member {Object.<string,string>} labels
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.labels = $util.emptyObject;
    
                /**
                 * TaskExecutionMetadata annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.annotations = $util.emptyObject;
    
                /**
                 * TaskExecutionMetadata k8sServiceAccount.
                 * @member {string} k8sServiceAccount
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.k8sServiceAccount = "";
    
                /**
                 * TaskExecutionMetadata environmentVariables.
                 * @member {Object.<string,string>} environmentVariables
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @instance
                 */
                TaskExecutionMetadata.prototype.environmentVariables = $util.emptyObject;
    
                /**
                 * Creates a new TaskExecutionMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionMetadata} TaskExecutionMetadata instance
                 */
                TaskExecutionMetadata.create = function create(properties) {
                    return new TaskExecutionMetadata(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionMetadata message. Does not implicitly {@link nebulaidl.admin.TaskExecutionMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionMetadata} message TaskExecutionMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.taskExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                    if (message.annotations != null && message.hasOwnProperty("annotations"))
                        for (var keys = Object.keys(message.annotations), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.annotations[keys[i]]).ldelim();
                    if (message.k8sServiceAccount != null && message.hasOwnProperty("k8sServiceAccount"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.k8sServiceAccount);
                    if (message.environmentVariables != null && message.hasOwnProperty("environmentVariables"))
                        for (var keys = Object.keys(message.environmentVariables), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.environmentVariables[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionMetadata} TaskExecutionMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionMetadata(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskExecutionId = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.namespace = reader.string();
                            break;
                        case 3:
                            reader.skip().pos++;
                            if (message.labels === $util.emptyObject)
                                message.labels = {};
                            key = reader.string();
                            reader.pos++;
                            message.labels[key] = reader.string();
                            break;
                        case 4:
                            reader.skip().pos++;
                            if (message.annotations === $util.emptyObject)
                                message.annotations = {};
                            key = reader.string();
                            reader.pos++;
                            message.annotations[key] = reader.string();
                            break;
                        case 5:
                            message.k8sServiceAccount = reader.string();
                            break;
                        case 6:
                            reader.skip().pos++;
                            if (message.environmentVariables === $util.emptyObject)
                                message.environmentVariables = {};
                            key = reader.string();
                            reader.pos++;
                            message.environmentVariables[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId")) {
                        var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.taskExecutionId);
                        if (error)
                            return "taskExecutionId." + error;
                    }
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        var key = Object.keys(message.labels);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        var key = Object.keys(message.annotations);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.k8sServiceAccount != null && message.hasOwnProperty("k8sServiceAccount"))
                        if (!$util.isString(message.k8sServiceAccount))
                            return "k8sServiceAccount: string expected";
                    if (message.environmentVariables != null && message.hasOwnProperty("environmentVariables")) {
                        if (!$util.isObject(message.environmentVariables))
                            return "environmentVariables: object expected";
                        var key = Object.keys(message.environmentVariables);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.environmentVariables[key[i]]))
                                return "environmentVariables: string{k:string} expected";
                    }
                    return null;
                };
    
                return TaskExecutionMetadata;
            })();
    
            admin.CreateTaskRequest = (function() {
    
                /**
                 * Properties of a CreateTaskRequest.
                 * @memberof nebulaidl.admin
                 * @interface ICreateTaskRequest
                 * @property {nebulaidl.core.ILiteralMap|null} [inputs] CreateTaskRequest inputs
                 * @property {nebulaidl.core.ITaskTemplate|null} [template] CreateTaskRequest template
                 * @property {string|null} [outputPrefix] CreateTaskRequest outputPrefix
                 * @property {nebulaidl.admin.ITaskExecutionMetadata|null} [taskExecutionMetadata] CreateTaskRequest taskExecutionMetadata
                 */
    
                /**
                 * Constructs a new CreateTaskRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a CreateTaskRequest.
                 * @implements ICreateTaskRequest
                 * @constructor
                 * @param {nebulaidl.admin.ICreateTaskRequest=} [properties] Properties to set
                 */
                function CreateTaskRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateTaskRequest inputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} inputs
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @instance
                 */
                CreateTaskRequest.prototype.inputs = null;
    
                /**
                 * CreateTaskRequest template.
                 * @member {nebulaidl.core.ITaskTemplate|null|undefined} template
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @instance
                 */
                CreateTaskRequest.prototype.template = null;
    
                /**
                 * CreateTaskRequest outputPrefix.
                 * @member {string} outputPrefix
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @instance
                 */
                CreateTaskRequest.prototype.outputPrefix = "";
    
                /**
                 * CreateTaskRequest taskExecutionMetadata.
                 * @member {nebulaidl.admin.ITaskExecutionMetadata|null|undefined} taskExecutionMetadata
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @instance
                 */
                CreateTaskRequest.prototype.taskExecutionMetadata = null;
    
                /**
                 * Creates a new CreateTaskRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @static
                 * @param {nebulaidl.admin.ICreateTaskRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.CreateTaskRequest} CreateTaskRequest instance
                 */
                CreateTaskRequest.create = function create(properties) {
                    return new CreateTaskRequest(properties);
                };
    
                /**
                 * Encodes the specified CreateTaskRequest message. Does not implicitly {@link nebulaidl.admin.CreateTaskRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @static
                 * @param {nebulaidl.admin.ICreateTaskRequest} message CreateTaskRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateTaskRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.template != null && message.hasOwnProperty("template"))
                        $root.nebulaidl.core.TaskTemplate.encode(message.template, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.outputPrefix != null && message.hasOwnProperty("outputPrefix"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputPrefix);
                    if (message.taskExecutionMetadata != null && message.hasOwnProperty("taskExecutionMetadata"))
                        $root.nebulaidl.admin.TaskExecutionMetadata.encode(message.taskExecutionMetadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateTaskRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.CreateTaskRequest} CreateTaskRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateTaskRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.CreateTaskRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.template = $root.nebulaidl.core.TaskTemplate.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.outputPrefix = reader.string();
                            break;
                        case 4:
                            message.taskExecutionMetadata = $root.nebulaidl.admin.TaskExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateTaskRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.CreateTaskRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateTaskRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.template != null && message.hasOwnProperty("template")) {
                        var error = $root.nebulaidl.core.TaskTemplate.verify(message.template);
                        if (error)
                            return "template." + error;
                    }
                    if (message.outputPrefix != null && message.hasOwnProperty("outputPrefix"))
                        if (!$util.isString(message.outputPrefix))
                            return "outputPrefix: string expected";
                    if (message.taskExecutionMetadata != null && message.hasOwnProperty("taskExecutionMetadata")) {
                        var error = $root.nebulaidl.admin.TaskExecutionMetadata.verify(message.taskExecutionMetadata);
                        if (error)
                            return "taskExecutionMetadata." + error;
                    }
                    return null;
                };
    
                return CreateTaskRequest;
            })();
    
            admin.CreateTaskResponse = (function() {
    
                /**
                 * Properties of a CreateTaskResponse.
                 * @memberof nebulaidl.admin
                 * @interface ICreateTaskResponse
                 * @property {Uint8Array|null} [resourceMeta] CreateTaskResponse resourceMeta
                 */
    
                /**
                 * Constructs a new CreateTaskResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a CreateTaskResponse.
                 * @implements ICreateTaskResponse
                 * @constructor
                 * @param {nebulaidl.admin.ICreateTaskResponse=} [properties] Properties to set
                 */
                function CreateTaskResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateTaskResponse resourceMeta.
                 * @member {Uint8Array} resourceMeta
                 * @memberof nebulaidl.admin.CreateTaskResponse
                 * @instance
                 */
                CreateTaskResponse.prototype.resourceMeta = $util.newBuffer([]);
    
                /**
                 * Creates a new CreateTaskResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.CreateTaskResponse
                 * @static
                 * @param {nebulaidl.admin.ICreateTaskResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.CreateTaskResponse} CreateTaskResponse instance
                 */
                CreateTaskResponse.create = function create(properties) {
                    return new CreateTaskResponse(properties);
                };
    
                /**
                 * Encodes the specified CreateTaskResponse message. Does not implicitly {@link nebulaidl.admin.CreateTaskResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.CreateTaskResponse
                 * @static
                 * @param {nebulaidl.admin.ICreateTaskResponse} message CreateTaskResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateTaskResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceMeta != null && message.hasOwnProperty("resourceMeta"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.resourceMeta);
                    return writer;
                };
    
                /**
                 * Decodes a CreateTaskResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.CreateTaskResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.CreateTaskResponse} CreateTaskResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateTaskResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.CreateTaskResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceMeta = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateTaskResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.CreateTaskResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateTaskResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceMeta != null && message.hasOwnProperty("resourceMeta"))
                        if (!(message.resourceMeta && typeof message.resourceMeta.length === "number" || $util.isString(message.resourceMeta)))
                            return "resourceMeta: buffer expected";
                    return null;
                };
    
                return CreateTaskResponse;
            })();
    
            admin.GetTaskRequest = (function() {
    
                /**
                 * Properties of a GetTaskRequest.
                 * @memberof nebulaidl.admin
                 * @interface IGetTaskRequest
                 * @property {string|null} [taskType] GetTaskRequest taskType
                 * @property {Uint8Array|null} [resourceMeta] GetTaskRequest resourceMeta
                 */
    
                /**
                 * Constructs a new GetTaskRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a GetTaskRequest.
                 * @implements IGetTaskRequest
                 * @constructor
                 * @param {nebulaidl.admin.IGetTaskRequest=} [properties] Properties to set
                 */
                function GetTaskRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetTaskRequest taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.admin.GetTaskRequest
                 * @instance
                 */
                GetTaskRequest.prototype.taskType = "";
    
                /**
                 * GetTaskRequest resourceMeta.
                 * @member {Uint8Array} resourceMeta
                 * @memberof nebulaidl.admin.GetTaskRequest
                 * @instance
                 */
                GetTaskRequest.prototype.resourceMeta = $util.newBuffer([]);
    
                /**
                 * Creates a new GetTaskRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.GetTaskRequest
                 * @static
                 * @param {nebulaidl.admin.IGetTaskRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.GetTaskRequest} GetTaskRequest instance
                 */
                GetTaskRequest.create = function create(properties) {
                    return new GetTaskRequest(properties);
                };
    
                /**
                 * Encodes the specified GetTaskRequest message. Does not implicitly {@link nebulaidl.admin.GetTaskRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.GetTaskRequest
                 * @static
                 * @param {nebulaidl.admin.IGetTaskRequest} message GetTaskRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetTaskRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskType);
                    if (message.resourceMeta != null && message.hasOwnProperty("resourceMeta"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.resourceMeta);
                    return writer;
                };
    
                /**
                 * Decodes a GetTaskRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.GetTaskRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.GetTaskRequest} GetTaskRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetTaskRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.GetTaskRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskType = reader.string();
                            break;
                        case 2:
                            message.resourceMeta = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GetTaskRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.GetTaskRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTaskRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.resourceMeta != null && message.hasOwnProperty("resourceMeta"))
                        if (!(message.resourceMeta && typeof message.resourceMeta.length === "number" || $util.isString(message.resourceMeta)))
                            return "resourceMeta: buffer expected";
                    return null;
                };
    
                return GetTaskRequest;
            })();
    
            admin.GetTaskResponse = (function() {
    
                /**
                 * Properties of a GetTaskResponse.
                 * @memberof nebulaidl.admin
                 * @interface IGetTaskResponse
                 * @property {nebulaidl.admin.IResource|null} [resource] GetTaskResponse resource
                 */
    
                /**
                 * Constructs a new GetTaskResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a GetTaskResponse.
                 * @implements IGetTaskResponse
                 * @constructor
                 * @param {nebulaidl.admin.IGetTaskResponse=} [properties] Properties to set
                 */
                function GetTaskResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetTaskResponse resource.
                 * @member {nebulaidl.admin.IResource|null|undefined} resource
                 * @memberof nebulaidl.admin.GetTaskResponse
                 * @instance
                 */
                GetTaskResponse.prototype.resource = null;
    
                /**
                 * Creates a new GetTaskResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.GetTaskResponse
                 * @static
                 * @param {nebulaidl.admin.IGetTaskResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.GetTaskResponse} GetTaskResponse instance
                 */
                GetTaskResponse.create = function create(properties) {
                    return new GetTaskResponse(properties);
                };
    
                /**
                 * Encodes the specified GetTaskResponse message. Does not implicitly {@link nebulaidl.admin.GetTaskResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.GetTaskResponse
                 * @static
                 * @param {nebulaidl.admin.IGetTaskResponse} message GetTaskResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetTaskResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resource != null && message.hasOwnProperty("resource"))
                        $root.nebulaidl.admin.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetTaskResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.GetTaskResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.GetTaskResponse} GetTaskResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetTaskResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.GetTaskResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resource = $root.nebulaidl.admin.Resource.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GetTaskResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.GetTaskResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTaskResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resource != null && message.hasOwnProperty("resource")) {
                        var error = $root.nebulaidl.admin.Resource.verify(message.resource);
                        if (error)
                            return "resource." + error;
                    }
                    return null;
                };
    
                return GetTaskResponse;
            })();
    
            admin.Resource = (function() {
    
                /**
                 * Properties of a Resource.
                 * @memberof nebulaidl.admin
                 * @interface IResource
                 * @property {nebulaidl.admin.State|null} [state] Resource state
                 * @property {nebulaidl.core.ILiteralMap|null} [outputs] Resource outputs
                 */
    
                /**
                 * Constructs a new Resource.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Resource.
                 * @implements IResource
                 * @constructor
                 * @param {nebulaidl.admin.IResource=} [properties] Properties to set
                 */
                function Resource(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Resource state.
                 * @member {nebulaidl.admin.State} state
                 * @memberof nebulaidl.admin.Resource
                 * @instance
                 */
                Resource.prototype.state = 0;
    
                /**
                 * Resource outputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputs
                 * @memberof nebulaidl.admin.Resource
                 * @instance
                 */
                Resource.prototype.outputs = null;
    
                /**
                 * Creates a new Resource instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Resource
                 * @static
                 * @param {nebulaidl.admin.IResource=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Resource} Resource instance
                 */
                Resource.create = function create(properties) {
                    return new Resource(properties);
                };
    
                /**
                 * Encodes the specified Resource message. Does not implicitly {@link nebulaidl.admin.Resource.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Resource
                 * @static
                 * @param {nebulaidl.admin.IResource} message Resource message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Resource.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Resource message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Resource
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Resource} Resource
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Resource.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Resource();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = reader.int32();
                            break;
                        case 2:
                            message.outputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Resource message.
                 * @function verify
                 * @memberof nebulaidl.admin.Resource
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Resource.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                    return null;
                };
    
                return Resource;
            })();
    
            admin.DeleteTaskRequest = (function() {
    
                /**
                 * Properties of a DeleteTaskRequest.
                 * @memberof nebulaidl.admin
                 * @interface IDeleteTaskRequest
                 * @property {string|null} [taskType] DeleteTaskRequest taskType
                 * @property {Uint8Array|null} [resourceMeta] DeleteTaskRequest resourceMeta
                 */
    
                /**
                 * Constructs a new DeleteTaskRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a DeleteTaskRequest.
                 * @implements IDeleteTaskRequest
                 * @constructor
                 * @param {nebulaidl.admin.IDeleteTaskRequest=} [properties] Properties to set
                 */
                function DeleteTaskRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DeleteTaskRequest taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.admin.DeleteTaskRequest
                 * @instance
                 */
                DeleteTaskRequest.prototype.taskType = "";
    
                /**
                 * DeleteTaskRequest resourceMeta.
                 * @member {Uint8Array} resourceMeta
                 * @memberof nebulaidl.admin.DeleteTaskRequest
                 * @instance
                 */
                DeleteTaskRequest.prototype.resourceMeta = $util.newBuffer([]);
    
                /**
                 * Creates a new DeleteTaskRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.DeleteTaskRequest
                 * @static
                 * @param {nebulaidl.admin.IDeleteTaskRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.DeleteTaskRequest} DeleteTaskRequest instance
                 */
                DeleteTaskRequest.create = function create(properties) {
                    return new DeleteTaskRequest(properties);
                };
    
                /**
                 * Encodes the specified DeleteTaskRequest message. Does not implicitly {@link nebulaidl.admin.DeleteTaskRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.DeleteTaskRequest
                 * @static
                 * @param {nebulaidl.admin.IDeleteTaskRequest} message DeleteTaskRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteTaskRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskType);
                    if (message.resourceMeta != null && message.hasOwnProperty("resourceMeta"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.resourceMeta);
                    return writer;
                };
    
                /**
                 * Decodes a DeleteTaskRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.DeleteTaskRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.DeleteTaskRequest} DeleteTaskRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteTaskRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.DeleteTaskRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskType = reader.string();
                            break;
                        case 2:
                            message.resourceMeta = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DeleteTaskRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.DeleteTaskRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteTaskRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.resourceMeta != null && message.hasOwnProperty("resourceMeta"))
                        if (!(message.resourceMeta && typeof message.resourceMeta.length === "number" || $util.isString(message.resourceMeta)))
                            return "resourceMeta: buffer expected";
                    return null;
                };
    
                return DeleteTaskRequest;
            })();
    
            admin.DeleteTaskResponse = (function() {
    
                /**
                 * Properties of a DeleteTaskResponse.
                 * @memberof nebulaidl.admin
                 * @interface IDeleteTaskResponse
                 */
    
                /**
                 * Constructs a new DeleteTaskResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a DeleteTaskResponse.
                 * @implements IDeleteTaskResponse
                 * @constructor
                 * @param {nebulaidl.admin.IDeleteTaskResponse=} [properties] Properties to set
                 */
                function DeleteTaskResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new DeleteTaskResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.DeleteTaskResponse
                 * @static
                 * @param {nebulaidl.admin.IDeleteTaskResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.DeleteTaskResponse} DeleteTaskResponse instance
                 */
                DeleteTaskResponse.create = function create(properties) {
                    return new DeleteTaskResponse(properties);
                };
    
                /**
                 * Encodes the specified DeleteTaskResponse message. Does not implicitly {@link nebulaidl.admin.DeleteTaskResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.DeleteTaskResponse
                 * @static
                 * @param {nebulaidl.admin.IDeleteTaskResponse} message DeleteTaskResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteTaskResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a DeleteTaskResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.DeleteTaskResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.DeleteTaskResponse} DeleteTaskResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteTaskResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.DeleteTaskResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DeleteTaskResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.DeleteTaskResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteTaskResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return DeleteTaskResponse;
            })();
    
            admin.ClusterAssignment = (function() {
    
                /**
                 * Properties of a ClusterAssignment.
                 * @memberof nebulaidl.admin
                 * @interface IClusterAssignment
                 * @property {string|null} [clusterPoolName] ClusterAssignment clusterPoolName
                 */
    
                /**
                 * Constructs a new ClusterAssignment.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ClusterAssignment.
                 * @implements IClusterAssignment
                 * @constructor
                 * @param {nebulaidl.admin.IClusterAssignment=} [properties] Properties to set
                 */
                function ClusterAssignment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClusterAssignment clusterPoolName.
                 * @member {string} clusterPoolName
                 * @memberof nebulaidl.admin.ClusterAssignment
                 * @instance
                 */
                ClusterAssignment.prototype.clusterPoolName = "";
    
                /**
                 * Creates a new ClusterAssignment instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ClusterAssignment
                 * @static
                 * @param {nebulaidl.admin.IClusterAssignment=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ClusterAssignment} ClusterAssignment instance
                 */
                ClusterAssignment.create = function create(properties) {
                    return new ClusterAssignment(properties);
                };
    
                /**
                 * Encodes the specified ClusterAssignment message. Does not implicitly {@link nebulaidl.admin.ClusterAssignment.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ClusterAssignment
                 * @static
                 * @param {nebulaidl.admin.IClusterAssignment} message ClusterAssignment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClusterAssignment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.clusterPoolName != null && message.hasOwnProperty("clusterPoolName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.clusterPoolName);
                    return writer;
                };
    
                /**
                 * Decodes a ClusterAssignment message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ClusterAssignment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ClusterAssignment} ClusterAssignment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClusterAssignment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ClusterAssignment();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3:
                            message.clusterPoolName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ClusterAssignment message.
                 * @function verify
                 * @memberof nebulaidl.admin.ClusterAssignment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClusterAssignment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clusterPoolName != null && message.hasOwnProperty("clusterPoolName"))
                        if (!$util.isString(message.clusterPoolName))
                            return "clusterPoolName: string expected";
                    return null;
                };
    
                return ClusterAssignment;
            })();
    
            admin.NamedEntityIdentifier = (function() {
    
                /**
                 * Properties of a NamedEntityIdentifier.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityIdentifier
                 * @property {string|null} [project] NamedEntityIdentifier project
                 * @property {string|null} [domain] NamedEntityIdentifier domain
                 * @property {string|null} [name] NamedEntityIdentifier name
                 */
    
                /**
                 * Constructs a new NamedEntityIdentifier.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityIdentifier.
                 * @implements INamedEntityIdentifier
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityIdentifier=} [properties] Properties to set
                 */
                function NamedEntityIdentifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityIdentifier project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @instance
                 */
                NamedEntityIdentifier.prototype.project = "";
    
                /**
                 * NamedEntityIdentifier domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @instance
                 */
                NamedEntityIdentifier.prototype.domain = "";
    
                /**
                 * NamedEntityIdentifier name.
                 * @member {string} name
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @instance
                 */
                NamedEntityIdentifier.prototype.name = "";
    
                /**
                 * Creates a new NamedEntityIdentifier instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @static
                 * @param {nebulaidl.admin.INamedEntityIdentifier=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityIdentifier} NamedEntityIdentifier instance
                 */
                NamedEntityIdentifier.create = function create(properties) {
                    return new NamedEntityIdentifier(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityIdentifier message. Does not implicitly {@link nebulaidl.admin.NamedEntityIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @static
                 * @param {nebulaidl.admin.INamedEntityIdentifier} message NamedEntityIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityIdentifier} NamedEntityIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityIdentifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityIdentifier message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };
    
                return NamedEntityIdentifier;
            })();
    
            /**
             * NamedEntityState enum.
             * @name nebulaidl.admin.NamedEntityState
             * @enum {string}
             * @property {number} NAMED_ENTITY_ACTIVE=0 NAMED_ENTITY_ACTIVE value
             * @property {number} NAMED_ENTITY_ARCHIVED=1 NAMED_ENTITY_ARCHIVED value
             * @property {number} SYSTEM_GENERATED=2 SYSTEM_GENERATED value
             */
            admin.NamedEntityState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NAMED_ENTITY_ACTIVE"] = 0;
                values[valuesById[1] = "NAMED_ENTITY_ARCHIVED"] = 1;
                values[valuesById[2] = "SYSTEM_GENERATED"] = 2;
                return values;
            })();
    
            admin.NamedEntityMetadata = (function() {
    
                /**
                 * Properties of a NamedEntityMetadata.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityMetadata
                 * @property {string|null} [description] NamedEntityMetadata description
                 * @property {nebulaidl.admin.NamedEntityState|null} [state] NamedEntityMetadata state
                 */
    
                /**
                 * Constructs a new NamedEntityMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityMetadata.
                 * @implements INamedEntityMetadata
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityMetadata=} [properties] Properties to set
                 */
                function NamedEntityMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityMetadata description.
                 * @member {string} description
                 * @memberof nebulaidl.admin.NamedEntityMetadata
                 * @instance
                 */
                NamedEntityMetadata.prototype.description = "";
    
                /**
                 * NamedEntityMetadata state.
                 * @member {nebulaidl.admin.NamedEntityState} state
                 * @memberof nebulaidl.admin.NamedEntityMetadata
                 * @instance
                 */
                NamedEntityMetadata.prototype.state = 0;
    
                /**
                 * Creates a new NamedEntityMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityMetadata
                 * @static
                 * @param {nebulaidl.admin.INamedEntityMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityMetadata} NamedEntityMetadata instance
                 */
                NamedEntityMetadata.create = function create(properties) {
                    return new NamedEntityMetadata(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityMetadata message. Does not implicitly {@link nebulaidl.admin.NamedEntityMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityMetadata
                 * @static
                 * @param {nebulaidl.admin.INamedEntityMetadata} message NamedEntityMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityMetadata} NamedEntityMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.description = reader.string();
                            break;
                        case 2:
                            message.state = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                return NamedEntityMetadata;
            })();
    
            admin.NamedEntity = (function() {
    
                /**
                 * Properties of a NamedEntity.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntity
                 * @property {nebulaidl.core.ResourceType|null} [resourceType] NamedEntity resourceType
                 * @property {nebulaidl.admin.INamedEntityIdentifier|null} [id] NamedEntity id
                 * @property {nebulaidl.admin.INamedEntityMetadata|null} [metadata] NamedEntity metadata
                 */
    
                /**
                 * Constructs a new NamedEntity.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntity.
                 * @implements INamedEntity
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntity=} [properties] Properties to set
                 */
                function NamedEntity(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntity resourceType.
                 * @member {nebulaidl.core.ResourceType} resourceType
                 * @memberof nebulaidl.admin.NamedEntity
                 * @instance
                 */
                NamedEntity.prototype.resourceType = 0;
    
                /**
                 * NamedEntity id.
                 * @member {nebulaidl.admin.INamedEntityIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.NamedEntity
                 * @instance
                 */
                NamedEntity.prototype.id = null;
    
                /**
                 * NamedEntity metadata.
                 * @member {nebulaidl.admin.INamedEntityMetadata|null|undefined} metadata
                 * @memberof nebulaidl.admin.NamedEntity
                 * @instance
                 */
                NamedEntity.prototype.metadata = null;
    
                /**
                 * Creates a new NamedEntity instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntity
                 * @static
                 * @param {nebulaidl.admin.INamedEntity=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntity} NamedEntity instance
                 */
                NamedEntity.create = function create(properties) {
                    return new NamedEntity(properties);
                };
    
                /**
                 * Encodes the specified NamedEntity message. Does not implicitly {@link nebulaidl.admin.NamedEntity.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntity
                 * @static
                 * @param {nebulaidl.admin.INamedEntity} message NamedEntity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.admin.NamedEntityMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntity message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntity} NamedEntity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntity();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        case 2:
                            message.id = $root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.metadata = $root.nebulaidl.admin.NamedEntityMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntity message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.admin.NamedEntityMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                return NamedEntity;
            })();
    
            admin.Sort = (function() {
    
                /**
                 * Properties of a Sort.
                 * @memberof nebulaidl.admin
                 * @interface ISort
                 * @property {string|null} [key] Sort key
                 * @property {nebulaidl.admin.Sort.Direction|null} [direction] Sort direction
                 */
    
                /**
                 * Constructs a new Sort.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Sort.
                 * @implements ISort
                 * @constructor
                 * @param {nebulaidl.admin.ISort=} [properties] Properties to set
                 */
                function Sort(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Sort key.
                 * @member {string} key
                 * @memberof nebulaidl.admin.Sort
                 * @instance
                 */
                Sort.prototype.key = "";
    
                /**
                 * Sort direction.
                 * @member {nebulaidl.admin.Sort.Direction} direction
                 * @memberof nebulaidl.admin.Sort
                 * @instance
                 */
                Sort.prototype.direction = 0;
    
                /**
                 * Creates a new Sort instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Sort
                 * @static
                 * @param {nebulaidl.admin.ISort=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Sort} Sort instance
                 */
                Sort.create = function create(properties) {
                    return new Sort(properties);
                };
    
                /**
                 * Encodes the specified Sort message. Does not implicitly {@link nebulaidl.admin.Sort.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Sort
                 * @static
                 * @param {nebulaidl.admin.ISort} message Sort message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Sort.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && message.hasOwnProperty("key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.direction);
                    return writer;
                };
    
                /**
                 * Decodes a Sort message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Sort
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Sort} Sort
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Sort.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Sort();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.direction = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Sort message.
                 * @function verify
                 * @memberof nebulaidl.admin.Sort
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Sort.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        switch (message.direction) {
                        default:
                            return "direction: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Direction enum.
                 * @name nebulaidl.admin.Sort.Direction
                 * @enum {string}
                 * @property {number} DESCENDING=0 DESCENDING value
                 * @property {number} ASCENDING=1 ASCENDING value
                 */
                Sort.Direction = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DESCENDING"] = 0;
                    values[valuesById[1] = "ASCENDING"] = 1;
                    return values;
                })();
    
                return Sort;
            })();
    
            admin.NamedEntityIdentifierListRequest = (function() {
    
                /**
                 * Properties of a NamedEntityIdentifierListRequest.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityIdentifierListRequest
                 * @property {string|null} [project] NamedEntityIdentifierListRequest project
                 * @property {string|null} [domain] NamedEntityIdentifierListRequest domain
                 * @property {number|null} [limit] NamedEntityIdentifierListRequest limit
                 * @property {string|null} [token] NamedEntityIdentifierListRequest token
                 * @property {nebulaidl.admin.ISort|null} [sortBy] NamedEntityIdentifierListRequest sortBy
                 * @property {string|null} [filters] NamedEntityIdentifierListRequest filters
                 */
    
                /**
                 * Constructs a new NamedEntityIdentifierListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityIdentifierListRequest.
                 * @implements INamedEntityIdentifierListRequest
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest=} [properties] Properties to set
                 */
                function NamedEntityIdentifierListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityIdentifierListRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @instance
                 */
                NamedEntityIdentifierListRequest.prototype.project = "";
    
                /**
                 * NamedEntityIdentifierListRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @instance
                 */
                NamedEntityIdentifierListRequest.prototype.domain = "";
    
                /**
                 * NamedEntityIdentifierListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @instance
                 */
                NamedEntityIdentifierListRequest.prototype.limit = 0;
    
                /**
                 * NamedEntityIdentifierListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @instance
                 */
                NamedEntityIdentifierListRequest.prototype.token = "";
    
                /**
                 * NamedEntityIdentifierListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @instance
                 */
                NamedEntityIdentifierListRequest.prototype.sortBy = null;
    
                /**
                 * NamedEntityIdentifierListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @instance
                 */
                NamedEntityIdentifierListRequest.prototype.filters = "";
    
                /**
                 * Creates a new NamedEntityIdentifierListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityIdentifierListRequest} NamedEntityIdentifierListRequest instance
                 */
                NamedEntityIdentifierListRequest.create = function create(properties) {
                    return new NamedEntityIdentifierListRequest(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityIdentifierListRequest message. Does not implicitly {@link nebulaidl.admin.NamedEntityIdentifierListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} message NamedEntityIdentifierListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityIdentifierListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.token);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.filters);
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityIdentifierListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityIdentifierListRequest} NamedEntityIdentifierListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityIdentifierListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityIdentifierListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.limit = reader.uint32();
                            break;
                        case 4:
                            message.token = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.filters = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityIdentifierListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityIdentifierListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityIdentifierListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    return null;
                };
    
                return NamedEntityIdentifierListRequest;
            })();
    
            admin.NamedEntityListRequest = (function() {
    
                /**
                 * Properties of a NamedEntityListRequest.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityListRequest
                 * @property {nebulaidl.core.ResourceType|null} [resourceType] NamedEntityListRequest resourceType
                 * @property {string|null} [project] NamedEntityListRequest project
                 * @property {string|null} [domain] NamedEntityListRequest domain
                 * @property {number|null} [limit] NamedEntityListRequest limit
                 * @property {string|null} [token] NamedEntityListRequest token
                 * @property {nebulaidl.admin.ISort|null} [sortBy] NamedEntityListRequest sortBy
                 * @property {string|null} [filters] NamedEntityListRequest filters
                 */
    
                /**
                 * Constructs a new NamedEntityListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityListRequest.
                 * @implements INamedEntityListRequest
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityListRequest=} [properties] Properties to set
                 */
                function NamedEntityListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityListRequest resourceType.
                 * @member {nebulaidl.core.ResourceType} resourceType
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.resourceType = 0;
    
                /**
                 * NamedEntityListRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.project = "";
    
                /**
                 * NamedEntityListRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.domain = "";
    
                /**
                 * NamedEntityListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.limit = 0;
    
                /**
                 * NamedEntityListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.token = "";
    
                /**
                 * NamedEntityListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.sortBy = null;
    
                /**
                 * NamedEntityListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @instance
                 */
                NamedEntityListRequest.prototype.filters = "";
    
                /**
                 * Creates a new NamedEntityListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityListRequest} NamedEntityListRequest instance
                 */
                NamedEntityListRequest.create = function create(properties) {
                    return new NamedEntityListRequest(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityListRequest message. Does not implicitly {@link nebulaidl.admin.NamedEntityListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityListRequest} message NamedEntityListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.domain);
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.token);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.filters);
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityListRequest} NamedEntityListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        case 2:
                            message.project = reader.string();
                            break;
                        case 3:
                            message.domain = reader.string();
                            break;
                        case 4:
                            message.limit = reader.uint32();
                            break;
                        case 5:
                            message.token = reader.string();
                            break;
                        case 6:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.filters = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    return null;
                };
    
                return NamedEntityListRequest;
            })();
    
            admin.NamedEntityIdentifierList = (function() {
    
                /**
                 * Properties of a NamedEntityIdentifierList.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityIdentifierList
                 * @property {Array.<nebulaidl.admin.INamedEntityIdentifier>|null} [entities] NamedEntityIdentifierList entities
                 * @property {string|null} [token] NamedEntityIdentifierList token
                 */
    
                /**
                 * Constructs a new NamedEntityIdentifierList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityIdentifierList.
                 * @implements INamedEntityIdentifierList
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityIdentifierList=} [properties] Properties to set
                 */
                function NamedEntityIdentifierList(properties) {
                    this.entities = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityIdentifierList entities.
                 * @member {Array.<nebulaidl.admin.INamedEntityIdentifier>} entities
                 * @memberof nebulaidl.admin.NamedEntityIdentifierList
                 * @instance
                 */
                NamedEntityIdentifierList.prototype.entities = $util.emptyArray;
    
                /**
                 * NamedEntityIdentifierList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NamedEntityIdentifierList
                 * @instance
                 */
                NamedEntityIdentifierList.prototype.token = "";
    
                /**
                 * Creates a new NamedEntityIdentifierList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityIdentifierList
                 * @static
                 * @param {nebulaidl.admin.INamedEntityIdentifierList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityIdentifierList} NamedEntityIdentifierList instance
                 */
                NamedEntityIdentifierList.create = function create(properties) {
                    return new NamedEntityIdentifierList(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityIdentifierList message. Does not implicitly {@link nebulaidl.admin.NamedEntityIdentifierList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityIdentifierList
                 * @static
                 * @param {nebulaidl.admin.INamedEntityIdentifierList} message NamedEntityIdentifierList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityIdentifierList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entities != null && message.entities.length)
                        for (var i = 0; i < message.entities.length; ++i)
                            $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.entities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityIdentifierList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityIdentifierList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityIdentifierList} NamedEntityIdentifierList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityIdentifierList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityIdentifierList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entities && message.entities.length))
                                message.entities = [];
                            message.entities.push($root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityIdentifierList message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityIdentifierList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityIdentifierList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entities != null && message.hasOwnProperty("entities")) {
                        if (!Array.isArray(message.entities))
                            return "entities: array expected";
                        for (var i = 0; i < message.entities.length; ++i) {
                            var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.entities[i]);
                            if (error)
                                return "entities." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return NamedEntityIdentifierList;
            })();
    
            admin.NamedEntityList = (function() {
    
                /**
                 * Properties of a NamedEntityList.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityList
                 * @property {Array.<nebulaidl.admin.INamedEntity>|null} [entities] NamedEntityList entities
                 * @property {string|null} [token] NamedEntityList token
                 */
    
                /**
                 * Constructs a new NamedEntityList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityList.
                 * @implements INamedEntityList
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityList=} [properties] Properties to set
                 */
                function NamedEntityList(properties) {
                    this.entities = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityList entities.
                 * @member {Array.<nebulaidl.admin.INamedEntity>} entities
                 * @memberof nebulaidl.admin.NamedEntityList
                 * @instance
                 */
                NamedEntityList.prototype.entities = $util.emptyArray;
    
                /**
                 * NamedEntityList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NamedEntityList
                 * @instance
                 */
                NamedEntityList.prototype.token = "";
    
                /**
                 * Creates a new NamedEntityList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityList
                 * @static
                 * @param {nebulaidl.admin.INamedEntityList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityList} NamedEntityList instance
                 */
                NamedEntityList.create = function create(properties) {
                    return new NamedEntityList(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityList message. Does not implicitly {@link nebulaidl.admin.NamedEntityList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityList
                 * @static
                 * @param {nebulaidl.admin.INamedEntityList} message NamedEntityList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entities != null && message.entities.length)
                        for (var i = 0; i < message.entities.length; ++i)
                            $root.nebulaidl.admin.NamedEntity.encode(message.entities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityList} NamedEntityList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entities && message.entities.length))
                                message.entities = [];
                            message.entities.push($root.nebulaidl.admin.NamedEntity.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityList message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entities != null && message.hasOwnProperty("entities")) {
                        if (!Array.isArray(message.entities))
                            return "entities: array expected";
                        for (var i = 0; i < message.entities.length; ++i) {
                            var error = $root.nebulaidl.admin.NamedEntity.verify(message.entities[i]);
                            if (error)
                                return "entities." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return NamedEntityList;
            })();
    
            admin.NamedEntityGetRequest = (function() {
    
                /**
                 * Properties of a NamedEntityGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityGetRequest
                 * @property {nebulaidl.core.ResourceType|null} [resourceType] NamedEntityGetRequest resourceType
                 * @property {nebulaidl.admin.INamedEntityIdentifier|null} [id] NamedEntityGetRequest id
                 */
    
                /**
                 * Constructs a new NamedEntityGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityGetRequest.
                 * @implements INamedEntityGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityGetRequest=} [properties] Properties to set
                 */
                function NamedEntityGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityGetRequest resourceType.
                 * @member {nebulaidl.core.ResourceType} resourceType
                 * @memberof nebulaidl.admin.NamedEntityGetRequest
                 * @instance
                 */
                NamedEntityGetRequest.prototype.resourceType = 0;
    
                /**
                 * NamedEntityGetRequest id.
                 * @member {nebulaidl.admin.INamedEntityIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.NamedEntityGetRequest
                 * @instance
                 */
                NamedEntityGetRequest.prototype.id = null;
    
                /**
                 * Creates a new NamedEntityGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityGetRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityGetRequest} NamedEntityGetRequest instance
                 */
                NamedEntityGetRequest.create = function create(properties) {
                    return new NamedEntityGetRequest(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityGetRequest message. Does not implicitly {@link nebulaidl.admin.NamedEntityGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityGetRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityGetRequest} message NamedEntityGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityGetRequest} NamedEntityGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        case 2:
                            message.id = $root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return NamedEntityGetRequest;
            })();
    
            admin.NamedEntityUpdateRequest = (function() {
    
                /**
                 * Properties of a NamedEntityUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityUpdateRequest
                 * @property {nebulaidl.core.ResourceType|null} [resourceType] NamedEntityUpdateRequest resourceType
                 * @property {nebulaidl.admin.INamedEntityIdentifier|null} [id] NamedEntityUpdateRequest id
                 * @property {nebulaidl.admin.INamedEntityMetadata|null} [metadata] NamedEntityUpdateRequest metadata
                 */
    
                /**
                 * Constructs a new NamedEntityUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityUpdateRequest.
                 * @implements INamedEntityUpdateRequest
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityUpdateRequest=} [properties] Properties to set
                 */
                function NamedEntityUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedEntityUpdateRequest resourceType.
                 * @member {nebulaidl.core.ResourceType} resourceType
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @instance
                 */
                NamedEntityUpdateRequest.prototype.resourceType = 0;
    
                /**
                 * NamedEntityUpdateRequest id.
                 * @member {nebulaidl.admin.INamedEntityIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @instance
                 */
                NamedEntityUpdateRequest.prototype.id = null;
    
                /**
                 * NamedEntityUpdateRequest metadata.
                 * @member {nebulaidl.admin.INamedEntityMetadata|null|undefined} metadata
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @instance
                 */
                NamedEntityUpdateRequest.prototype.metadata = null;
    
                /**
                 * Creates a new NamedEntityUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityUpdateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityUpdateRequest} NamedEntityUpdateRequest instance
                 */
                NamedEntityUpdateRequest.create = function create(properties) {
                    return new NamedEntityUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityUpdateRequest message. Does not implicitly {@link nebulaidl.admin.NamedEntityUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.INamedEntityUpdateRequest} message NamedEntityUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.admin.NamedEntityMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityUpdateRequest} NamedEntityUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        case 2:
                            message.id = $root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.metadata = $root.nebulaidl.admin.NamedEntityMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityUpdateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.admin.NamedEntityMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                return NamedEntityUpdateRequest;
            })();
    
            admin.NamedEntityUpdateResponse = (function() {
    
                /**
                 * Properties of a NamedEntityUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface INamedEntityUpdateResponse
                 */
    
                /**
                 * Constructs a new NamedEntityUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NamedEntityUpdateResponse.
                 * @implements INamedEntityUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.INamedEntityUpdateResponse=} [properties] Properties to set
                 */
                function NamedEntityUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new NamedEntityUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NamedEntityUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.INamedEntityUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NamedEntityUpdateResponse} NamedEntityUpdateResponse instance
                 */
                NamedEntityUpdateResponse.create = function create(properties) {
                    return new NamedEntityUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified NamedEntityUpdateResponse message. Does not implicitly {@link nebulaidl.admin.NamedEntityUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NamedEntityUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.INamedEntityUpdateResponse} message NamedEntityUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedEntityUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a NamedEntityUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NamedEntityUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NamedEntityUpdateResponse} NamedEntityUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedEntityUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NamedEntityUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NamedEntityUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.NamedEntityUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedEntityUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return NamedEntityUpdateResponse;
            })();
    
            admin.ObjectGetRequest = (function() {
    
                /**
                 * Properties of an ObjectGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface IObjectGetRequest
                 * @property {nebulaidl.core.IIdentifier|null} [id] ObjectGetRequest id
                 */
    
                /**
                 * Constructs a new ObjectGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ObjectGetRequest.
                 * @implements IObjectGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.IObjectGetRequest=} [properties] Properties to set
                 */
                function ObjectGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ObjectGetRequest id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ObjectGetRequest
                 * @instance
                 */
                ObjectGetRequest.prototype.id = null;
    
                /**
                 * Creates a new ObjectGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ObjectGetRequest
                 * @static
                 * @param {nebulaidl.admin.IObjectGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ObjectGetRequest} ObjectGetRequest instance
                 */
                ObjectGetRequest.create = function create(properties) {
                    return new ObjectGetRequest(properties);
                };
    
                /**
                 * Encodes the specified ObjectGetRequest message. Does not implicitly {@link nebulaidl.admin.ObjectGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ObjectGetRequest
                 * @static
                 * @param {nebulaidl.admin.IObjectGetRequest} message ObjectGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ObjectGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ObjectGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ObjectGetRequest} ObjectGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ObjectGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ObjectGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ObjectGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ObjectGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return ObjectGetRequest;
            })();
    
            admin.ResourceListRequest = (function() {
    
                /**
                 * Properties of a ResourceListRequest.
                 * @memberof nebulaidl.admin
                 * @interface IResourceListRequest
                 * @property {nebulaidl.admin.INamedEntityIdentifier|null} [id] ResourceListRequest id
                 * @property {number|null} [limit] ResourceListRequest limit
                 * @property {string|null} [token] ResourceListRequest token
                 * @property {string|null} [filters] ResourceListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] ResourceListRequest sortBy
                 */
    
                /**
                 * Constructs a new ResourceListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ResourceListRequest.
                 * @implements IResourceListRequest
                 * @constructor
                 * @param {nebulaidl.admin.IResourceListRequest=} [properties] Properties to set
                 */
                function ResourceListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ResourceListRequest id.
                 * @member {nebulaidl.admin.INamedEntityIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @instance
                 */
                ResourceListRequest.prototype.id = null;
    
                /**
                 * ResourceListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @instance
                 */
                ResourceListRequest.prototype.limit = 0;
    
                /**
                 * ResourceListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @instance
                 */
                ResourceListRequest.prototype.token = "";
    
                /**
                 * ResourceListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @instance
                 */
                ResourceListRequest.prototype.filters = "";
    
                /**
                 * ResourceListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @instance
                 */
                ResourceListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new ResourceListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @static
                 * @param {nebulaidl.admin.IResourceListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ResourceListRequest} ResourceListRequest instance
                 */
                ResourceListRequest.create = function create(properties) {
                    return new ResourceListRequest(properties);
                };
    
                /**
                 * Encodes the specified ResourceListRequest message. Does not implicitly {@link nebulaidl.admin.ResourceListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @static
                 * @param {nebulaidl.admin.IResourceListRequest} message ResourceListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ResourceListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ResourceListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ResourceListRequest} ResourceListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ResourceListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ResourceListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.limit = reader.uint32();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.filters = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ResourceListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ResourceListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResourceListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return ResourceListRequest;
            })();
    
            admin.EmailNotification = (function() {
    
                /**
                 * Properties of an EmailNotification.
                 * @memberof nebulaidl.admin
                 * @interface IEmailNotification
                 * @property {Array.<string>|null} [recipientsEmail] EmailNotification recipientsEmail
                 */
    
                /**
                 * Constructs a new EmailNotification.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an EmailNotification.
                 * @implements IEmailNotification
                 * @constructor
                 * @param {nebulaidl.admin.IEmailNotification=} [properties] Properties to set
                 */
                function EmailNotification(properties) {
                    this.recipientsEmail = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EmailNotification recipientsEmail.
                 * @member {Array.<string>} recipientsEmail
                 * @memberof nebulaidl.admin.EmailNotification
                 * @instance
                 */
                EmailNotification.prototype.recipientsEmail = $util.emptyArray;
    
                /**
                 * Creates a new EmailNotification instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.EmailNotification
                 * @static
                 * @param {nebulaidl.admin.IEmailNotification=} [properties] Properties to set
                 * @returns {nebulaidl.admin.EmailNotification} EmailNotification instance
                 */
                EmailNotification.create = function create(properties) {
                    return new EmailNotification(properties);
                };
    
                /**
                 * Encodes the specified EmailNotification message. Does not implicitly {@link nebulaidl.admin.EmailNotification.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.EmailNotification
                 * @static
                 * @param {nebulaidl.admin.IEmailNotification} message EmailNotification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmailNotification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.recipientsEmail != null && message.recipientsEmail.length)
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                    return writer;
                };
    
                /**
                 * Decodes an EmailNotification message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.EmailNotification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.EmailNotification} EmailNotification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmailNotification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.EmailNotification();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.recipientsEmail && message.recipientsEmail.length))
                                message.recipientsEmail = [];
                            message.recipientsEmail.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EmailNotification message.
                 * @function verify
                 * @memberof nebulaidl.admin.EmailNotification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EmailNotification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                        if (!Array.isArray(message.recipientsEmail))
                            return "recipientsEmail: array expected";
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            if (!$util.isString(message.recipientsEmail[i]))
                                return "recipientsEmail: string[] expected";
                    }
                    return null;
                };
    
                return EmailNotification;
            })();
    
            admin.PagerDutyNotification = (function() {
    
                /**
                 * Properties of a PagerDutyNotification.
                 * @memberof nebulaidl.admin
                 * @interface IPagerDutyNotification
                 * @property {Array.<string>|null} [recipientsEmail] PagerDutyNotification recipientsEmail
                 */
    
                /**
                 * Constructs a new PagerDutyNotification.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a PagerDutyNotification.
                 * @implements IPagerDutyNotification
                 * @constructor
                 * @param {nebulaidl.admin.IPagerDutyNotification=} [properties] Properties to set
                 */
                function PagerDutyNotification(properties) {
                    this.recipientsEmail = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PagerDutyNotification recipientsEmail.
                 * @member {Array.<string>} recipientsEmail
                 * @memberof nebulaidl.admin.PagerDutyNotification
                 * @instance
                 */
                PagerDutyNotification.prototype.recipientsEmail = $util.emptyArray;
    
                /**
                 * Creates a new PagerDutyNotification instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.PagerDutyNotification
                 * @static
                 * @param {nebulaidl.admin.IPagerDutyNotification=} [properties] Properties to set
                 * @returns {nebulaidl.admin.PagerDutyNotification} PagerDutyNotification instance
                 */
                PagerDutyNotification.create = function create(properties) {
                    return new PagerDutyNotification(properties);
                };
    
                /**
                 * Encodes the specified PagerDutyNotification message. Does not implicitly {@link nebulaidl.admin.PagerDutyNotification.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.PagerDutyNotification
                 * @static
                 * @param {nebulaidl.admin.IPagerDutyNotification} message PagerDutyNotification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PagerDutyNotification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.recipientsEmail != null && message.recipientsEmail.length)
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                    return writer;
                };
    
                /**
                 * Decodes a PagerDutyNotification message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.PagerDutyNotification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.PagerDutyNotification} PagerDutyNotification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PagerDutyNotification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.PagerDutyNotification();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.recipientsEmail && message.recipientsEmail.length))
                                message.recipientsEmail = [];
                            message.recipientsEmail.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PagerDutyNotification message.
                 * @function verify
                 * @memberof nebulaidl.admin.PagerDutyNotification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PagerDutyNotification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                        if (!Array.isArray(message.recipientsEmail))
                            return "recipientsEmail: array expected";
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            if (!$util.isString(message.recipientsEmail[i]))
                                return "recipientsEmail: string[] expected";
                    }
                    return null;
                };
    
                return PagerDutyNotification;
            })();
    
            admin.SlackNotification = (function() {
    
                /**
                 * Properties of a SlackNotification.
                 * @memberof nebulaidl.admin
                 * @interface ISlackNotification
                 * @property {Array.<string>|null} [recipientsEmail] SlackNotification recipientsEmail
                 */
    
                /**
                 * Constructs a new SlackNotification.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SlackNotification.
                 * @implements ISlackNotification
                 * @constructor
                 * @param {nebulaidl.admin.ISlackNotification=} [properties] Properties to set
                 */
                function SlackNotification(properties) {
                    this.recipientsEmail = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SlackNotification recipientsEmail.
                 * @member {Array.<string>} recipientsEmail
                 * @memberof nebulaidl.admin.SlackNotification
                 * @instance
                 */
                SlackNotification.prototype.recipientsEmail = $util.emptyArray;
    
                /**
                 * Creates a new SlackNotification instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SlackNotification
                 * @static
                 * @param {nebulaidl.admin.ISlackNotification=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SlackNotification} SlackNotification instance
                 */
                SlackNotification.create = function create(properties) {
                    return new SlackNotification(properties);
                };
    
                /**
                 * Encodes the specified SlackNotification message. Does not implicitly {@link nebulaidl.admin.SlackNotification.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SlackNotification
                 * @static
                 * @param {nebulaidl.admin.ISlackNotification} message SlackNotification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlackNotification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.recipientsEmail != null && message.recipientsEmail.length)
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                    return writer;
                };
    
                /**
                 * Decodes a SlackNotification message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SlackNotification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SlackNotification} SlackNotification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlackNotification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SlackNotification();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.recipientsEmail && message.recipientsEmail.length))
                                message.recipientsEmail = [];
                            message.recipientsEmail.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SlackNotification message.
                 * @function verify
                 * @memberof nebulaidl.admin.SlackNotification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SlackNotification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                        if (!Array.isArray(message.recipientsEmail))
                            return "recipientsEmail: array expected";
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            if (!$util.isString(message.recipientsEmail[i]))
                                return "recipientsEmail: string[] expected";
                    }
                    return null;
                };
    
                return SlackNotification;
            })();
    
            admin.Notification = (function() {
    
                /**
                 * Properties of a Notification.
                 * @memberof nebulaidl.admin
                 * @interface INotification
                 * @property {Array.<nebulaidl.core.WorkflowExecution.Phase>|null} [phases] Notification phases
                 * @property {nebulaidl.admin.IEmailNotification|null} [email] Notification email
                 * @property {nebulaidl.admin.IPagerDutyNotification|null} [pagerDuty] Notification pagerDuty
                 * @property {nebulaidl.admin.ISlackNotification|null} [slack] Notification slack
                 */
    
                /**
                 * Constructs a new Notification.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Notification.
                 * @implements INotification
                 * @constructor
                 * @param {nebulaidl.admin.INotification=} [properties] Properties to set
                 */
                function Notification(properties) {
                    this.phases = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Notification phases.
                 * @member {Array.<nebulaidl.core.WorkflowExecution.Phase>} phases
                 * @memberof nebulaidl.admin.Notification
                 * @instance
                 */
                Notification.prototype.phases = $util.emptyArray;
    
                /**
                 * Notification email.
                 * @member {nebulaidl.admin.IEmailNotification|null|undefined} email
                 * @memberof nebulaidl.admin.Notification
                 * @instance
                 */
                Notification.prototype.email = null;
    
                /**
                 * Notification pagerDuty.
                 * @member {nebulaidl.admin.IPagerDutyNotification|null|undefined} pagerDuty
                 * @memberof nebulaidl.admin.Notification
                 * @instance
                 */
                Notification.prototype.pagerDuty = null;
    
                /**
                 * Notification slack.
                 * @member {nebulaidl.admin.ISlackNotification|null|undefined} slack
                 * @memberof nebulaidl.admin.Notification
                 * @instance
                 */
                Notification.prototype.slack = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Notification type.
                 * @member {"email"|"pagerDuty"|"slack"|undefined} type
                 * @memberof nebulaidl.admin.Notification
                 * @instance
                 */
                Object.defineProperty(Notification.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["email", "pagerDuty", "slack"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Notification instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Notification
                 * @static
                 * @param {nebulaidl.admin.INotification=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Notification} Notification instance
                 */
                Notification.create = function create(properties) {
                    return new Notification(properties);
                };
    
                /**
                 * Encodes the specified Notification message. Does not implicitly {@link nebulaidl.admin.Notification.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Notification
                 * @static
                 * @param {nebulaidl.admin.INotification} message Notification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.phases != null && message.phases.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.phases.length; ++i)
                            writer.int32(message.phases[i]);
                        writer.ldelim();
                    }
                    if (message.email != null && message.hasOwnProperty("email"))
                        $root.nebulaidl.admin.EmailNotification.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pagerDuty != null && message.hasOwnProperty("pagerDuty"))
                        $root.nebulaidl.admin.PagerDutyNotification.encode(message.pagerDuty, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.slack != null && message.hasOwnProperty("slack"))
                        $root.nebulaidl.admin.SlackNotification.encode(message.slack, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Notification message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Notification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Notification} Notification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Notification();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.phases && message.phases.length))
                                message.phases = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.phases.push(reader.int32());
                            } else
                                message.phases.push(reader.int32());
                            break;
                        case 2:
                            message.email = $root.nebulaidl.admin.EmailNotification.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.pagerDuty = $root.nebulaidl.admin.PagerDutyNotification.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.slack = $root.nebulaidl.admin.SlackNotification.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Notification message.
                 * @function verify
                 * @memberof nebulaidl.admin.Notification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Notification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.phases != null && message.hasOwnProperty("phases")) {
                        if (!Array.isArray(message.phases))
                            return "phases: array expected";
                        for (var i = 0; i < message.phases.length; ++i)
                            switch (message.phases[i]) {
                            default:
                                return "phases: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                                break;
                            }
                    }
                    if (message.email != null && message.hasOwnProperty("email")) {
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.admin.EmailNotification.verify(message.email);
                            if (error)
                                return "email." + error;
                        }
                    }
                    if (message.pagerDuty != null && message.hasOwnProperty("pagerDuty")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.admin.PagerDutyNotification.verify(message.pagerDuty);
                            if (error)
                                return "pagerDuty." + error;
                        }
                    }
                    if (message.slack != null && message.hasOwnProperty("slack")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            var error = $root.nebulaidl.admin.SlackNotification.verify(message.slack);
                            if (error)
                                return "slack." + error;
                        }
                    }
                    return null;
                };
    
                return Notification;
            })();
    
            admin.UrlBlob = (function() {
    
                /**
                 * Properties of an UrlBlob.
                 * @memberof nebulaidl.admin
                 * @interface IUrlBlob
                 * @property {string|null} [url] UrlBlob url
                 * @property {Long|null} [bytes] UrlBlob bytes
                 */
    
                /**
                 * Constructs a new UrlBlob.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an UrlBlob.
                 * @implements IUrlBlob
                 * @constructor
                 * @param {nebulaidl.admin.IUrlBlob=} [properties] Properties to set
                 */
                function UrlBlob(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UrlBlob url.
                 * @member {string} url
                 * @memberof nebulaidl.admin.UrlBlob
                 * @instance
                 */
                UrlBlob.prototype.url = "";
    
                /**
                 * UrlBlob bytes.
                 * @member {Long} bytes
                 * @memberof nebulaidl.admin.UrlBlob
                 * @instance
                 */
                UrlBlob.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Creates a new UrlBlob instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.UrlBlob
                 * @static
                 * @param {nebulaidl.admin.IUrlBlob=} [properties] Properties to set
                 * @returns {nebulaidl.admin.UrlBlob} UrlBlob instance
                 */
                UrlBlob.create = function create(properties) {
                    return new UrlBlob(properties);
                };
    
                /**
                 * Encodes the specified UrlBlob message. Does not implicitly {@link nebulaidl.admin.UrlBlob.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.UrlBlob
                 * @static
                 * @param {nebulaidl.admin.IUrlBlob} message UrlBlob message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UrlBlob.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.url != null && message.hasOwnProperty("url"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                    if (message.bytes != null && message.hasOwnProperty("bytes"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.bytes);
                    return writer;
                };
    
                /**
                 * Decodes an UrlBlob message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.UrlBlob
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.UrlBlob} UrlBlob
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UrlBlob.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.UrlBlob();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.url = reader.string();
                            break;
                        case 2:
                            message.bytes = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an UrlBlob message.
                 * @function verify
                 * @memberof nebulaidl.admin.UrlBlob
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UrlBlob.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    if (message.bytes != null && message.hasOwnProperty("bytes"))
                        if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                            return "bytes: integer|Long expected";
                    return null;
                };
    
                return UrlBlob;
            })();
    
            admin.Labels = (function() {
    
                /**
                 * Properties of a Labels.
                 * @memberof nebulaidl.admin
                 * @interface ILabels
                 * @property {Object.<string,string>|null} [values] Labels values
                 */
    
                /**
                 * Constructs a new Labels.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Labels.
                 * @implements ILabels
                 * @constructor
                 * @param {nebulaidl.admin.ILabels=} [properties] Properties to set
                 */
                function Labels(properties) {
                    this.values = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Labels values.
                 * @member {Object.<string,string>} values
                 * @memberof nebulaidl.admin.Labels
                 * @instance
                 */
                Labels.prototype.values = $util.emptyObject;
    
                /**
                 * Creates a new Labels instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Labels
                 * @static
                 * @param {nebulaidl.admin.ILabels=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Labels} Labels instance
                 */
                Labels.create = function create(properties) {
                    return new Labels(properties);
                };
    
                /**
                 * Encodes the specified Labels message. Does not implicitly {@link nebulaidl.admin.Labels.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Labels
                 * @static
                 * @param {nebulaidl.admin.ILabels} message Labels message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Labels.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.hasOwnProperty("values"))
                        for (var keys = Object.keys(message.values), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.values[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Labels message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Labels
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Labels} Labels
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Labels.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Labels(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.values === $util.emptyObject)
                                message.values = {};
                            key = reader.string();
                            reader.pos++;
                            message.values[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Labels message.
                 * @function verify
                 * @memberof nebulaidl.admin.Labels
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Labels.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!$util.isObject(message.values))
                            return "values: object expected";
                        var key = Object.keys(message.values);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.values[key[i]]))
                                return "values: string{k:string} expected";
                    }
                    return null;
                };
    
                return Labels;
            })();
    
            admin.Annotations = (function() {
    
                /**
                 * Properties of an Annotations.
                 * @memberof nebulaidl.admin
                 * @interface IAnnotations
                 * @property {Object.<string,string>|null} [values] Annotations values
                 */
    
                /**
                 * Constructs a new Annotations.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an Annotations.
                 * @implements IAnnotations
                 * @constructor
                 * @param {nebulaidl.admin.IAnnotations=} [properties] Properties to set
                 */
                function Annotations(properties) {
                    this.values = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Annotations values.
                 * @member {Object.<string,string>} values
                 * @memberof nebulaidl.admin.Annotations
                 * @instance
                 */
                Annotations.prototype.values = $util.emptyObject;
    
                /**
                 * Creates a new Annotations instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Annotations
                 * @static
                 * @param {nebulaidl.admin.IAnnotations=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Annotations} Annotations instance
                 */
                Annotations.create = function create(properties) {
                    return new Annotations(properties);
                };
    
                /**
                 * Encodes the specified Annotations message. Does not implicitly {@link nebulaidl.admin.Annotations.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Annotations
                 * @static
                 * @param {nebulaidl.admin.IAnnotations} message Annotations message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotations.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.hasOwnProperty("values"))
                        for (var keys = Object.keys(message.values), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.values[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an Annotations message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Annotations
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Annotations} Annotations
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotations.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Annotations(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.values === $util.emptyObject)
                                message.values = {};
                            key = reader.string();
                            reader.pos++;
                            message.values[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Annotations message.
                 * @function verify
                 * @memberof nebulaidl.admin.Annotations
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotations.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!$util.isObject(message.values))
                            return "values: object expected";
                        var key = Object.keys(message.values);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.values[key[i]]))
                                return "values: string{k:string} expected";
                    }
                    return null;
                };
    
                return Annotations;
            })();
    
            admin.Envs = (function() {
    
                /**
                 * Properties of an Envs.
                 * @memberof nebulaidl.admin
                 * @interface IEnvs
                 * @property {Array.<nebulaidl.core.IKeyValuePair>|null} [values] Envs values
                 */
    
                /**
                 * Constructs a new Envs.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an Envs.
                 * @implements IEnvs
                 * @constructor
                 * @param {nebulaidl.admin.IEnvs=} [properties] Properties to set
                 */
                function Envs(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Envs values.
                 * @member {Array.<nebulaidl.core.IKeyValuePair>} values
                 * @memberof nebulaidl.admin.Envs
                 * @instance
                 */
                Envs.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new Envs instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Envs
                 * @static
                 * @param {nebulaidl.admin.IEnvs=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Envs} Envs instance
                 */
                Envs.create = function create(properties) {
                    return new Envs(properties);
                };
    
                /**
                 * Encodes the specified Envs message. Does not implicitly {@link nebulaidl.admin.Envs.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Envs
                 * @static
                 * @param {nebulaidl.admin.IEnvs} message Envs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            $root.nebulaidl.core.KeyValuePair.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an Envs message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Envs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Envs} Envs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envs.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Envs();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.nebulaidl.core.KeyValuePair.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Envs message.
                 * @function verify
                 * @memberof nebulaidl.admin.Envs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Envs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i) {
                            var error = $root.nebulaidl.core.KeyValuePair.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };
    
                return Envs;
            })();
    
            admin.AuthRole = (function() {
    
                /**
                 * Properties of an AuthRole.
                 * @memberof nebulaidl.admin
                 * @interface IAuthRole
                 * @property {string|null} [assumableIamRole] AuthRole assumableIamRole
                 * @property {string|null} [kubernetesServiceAccount] AuthRole kubernetesServiceAccount
                 */
    
                /**
                 * Constructs a new AuthRole.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an AuthRole.
                 * @implements IAuthRole
                 * @constructor
                 * @param {nebulaidl.admin.IAuthRole=} [properties] Properties to set
                 */
                function AuthRole(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * AuthRole assumableIamRole.
                 * @member {string} assumableIamRole
                 * @memberof nebulaidl.admin.AuthRole
                 * @instance
                 */
                AuthRole.prototype.assumableIamRole = "";
    
                /**
                 * AuthRole kubernetesServiceAccount.
                 * @member {string} kubernetesServiceAccount
                 * @memberof nebulaidl.admin.AuthRole
                 * @instance
                 */
                AuthRole.prototype.kubernetesServiceAccount = "";
    
                /**
                 * Creates a new AuthRole instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.AuthRole
                 * @static
                 * @param {nebulaidl.admin.IAuthRole=} [properties] Properties to set
                 * @returns {nebulaidl.admin.AuthRole} AuthRole instance
                 */
                AuthRole.create = function create(properties) {
                    return new AuthRole(properties);
                };
    
                /**
                 * Encodes the specified AuthRole message. Does not implicitly {@link nebulaidl.admin.AuthRole.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.AuthRole
                 * @static
                 * @param {nebulaidl.admin.IAuthRole} message AuthRole message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AuthRole.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.assumableIamRole);
                    if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.kubernetesServiceAccount);
                    return writer;
                };
    
                /**
                 * Decodes an AuthRole message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.AuthRole
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.AuthRole} AuthRole
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AuthRole.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.AuthRole();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.assumableIamRole = reader.string();
                            break;
                        case 2:
                            message.kubernetesServiceAccount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an AuthRole message.
                 * @function verify
                 * @memberof nebulaidl.admin.AuthRole
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AuthRole.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole"))
                        if (!$util.isString(message.assumableIamRole))
                            return "assumableIamRole: string expected";
                    if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount"))
                        if (!$util.isString(message.kubernetesServiceAccount))
                            return "kubernetesServiceAccount: string expected";
                    return null;
                };
    
                return AuthRole;
            })();
    
            admin.RawOutputDataConfig = (function() {
    
                /**
                 * Properties of a RawOutputDataConfig.
                 * @memberof nebulaidl.admin
                 * @interface IRawOutputDataConfig
                 * @property {string|null} [outputLocationPrefix] RawOutputDataConfig outputLocationPrefix
                 */
    
                /**
                 * Constructs a new RawOutputDataConfig.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a RawOutputDataConfig.
                 * @implements IRawOutputDataConfig
                 * @constructor
                 * @param {nebulaidl.admin.IRawOutputDataConfig=} [properties] Properties to set
                 */
                function RawOutputDataConfig(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RawOutputDataConfig outputLocationPrefix.
                 * @member {string} outputLocationPrefix
                 * @memberof nebulaidl.admin.RawOutputDataConfig
                 * @instance
                 */
                RawOutputDataConfig.prototype.outputLocationPrefix = "";
    
                /**
                 * Creates a new RawOutputDataConfig instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.RawOutputDataConfig
                 * @static
                 * @param {nebulaidl.admin.IRawOutputDataConfig=} [properties] Properties to set
                 * @returns {nebulaidl.admin.RawOutputDataConfig} RawOutputDataConfig instance
                 */
                RawOutputDataConfig.create = function create(properties) {
                    return new RawOutputDataConfig(properties);
                };
    
                /**
                 * Encodes the specified RawOutputDataConfig message. Does not implicitly {@link nebulaidl.admin.RawOutputDataConfig.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.RawOutputDataConfig
                 * @static
                 * @param {nebulaidl.admin.IRawOutputDataConfig} message RawOutputDataConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RawOutputDataConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.outputLocationPrefix != null && message.hasOwnProperty("outputLocationPrefix"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputLocationPrefix);
                    return writer;
                };
    
                /**
                 * Decodes a RawOutputDataConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.RawOutputDataConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.RawOutputDataConfig} RawOutputDataConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RawOutputDataConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.RawOutputDataConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputLocationPrefix = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a RawOutputDataConfig message.
                 * @function verify
                 * @memberof nebulaidl.admin.RawOutputDataConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RawOutputDataConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.outputLocationPrefix != null && message.hasOwnProperty("outputLocationPrefix"))
                        if (!$util.isString(message.outputLocationPrefix))
                            return "outputLocationPrefix: string expected";
                    return null;
                };
    
                return RawOutputDataConfig;
            })();
    
            admin.NebulaURLs = (function() {
    
                /**
                 * Properties of a NebulaURLs.
                 * @memberof nebulaidl.admin
                 * @interface INebulaURLs
                 * @property {string|null} [inputs] NebulaURLs inputs
                 * @property {string|null} [outputs] NebulaURLs outputs
                 * @property {string|null} [deck] NebulaURLs deck
                 */
    
                /**
                 * Constructs a new NebulaURLs.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NebulaURLs.
                 * @implements INebulaURLs
                 * @constructor
                 * @param {nebulaidl.admin.INebulaURLs=} [properties] Properties to set
                 */
                function NebulaURLs(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NebulaURLs inputs.
                 * @member {string} inputs
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @instance
                 */
                NebulaURLs.prototype.inputs = "";
    
                /**
                 * NebulaURLs outputs.
                 * @member {string} outputs
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @instance
                 */
                NebulaURLs.prototype.outputs = "";
    
                /**
                 * NebulaURLs deck.
                 * @member {string} deck
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @instance
                 */
                NebulaURLs.prototype.deck = "";
    
                /**
                 * Creates a new NebulaURLs instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @static
                 * @param {nebulaidl.admin.INebulaURLs=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NebulaURLs} NebulaURLs instance
                 */
                NebulaURLs.create = function create(properties) {
                    return new NebulaURLs(properties);
                };
    
                /**
                 * Encodes the specified NebulaURLs message. Does not implicitly {@link nebulaidl.admin.NebulaURLs.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @static
                 * @param {nebulaidl.admin.INebulaURLs} message NebulaURLs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NebulaURLs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.inputs);
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.outputs);
                    if (message.deck != null && message.hasOwnProperty("deck"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.deck);
                    return writer;
                };
    
                /**
                 * Decodes a NebulaURLs message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NebulaURLs} NebulaURLs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NebulaURLs.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NebulaURLs();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputs = reader.string();
                            break;
                        case 2:
                            message.outputs = reader.string();
                            break;
                        case 3:
                            message.deck = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NebulaURLs message.
                 * @function verify
                 * @memberof nebulaidl.admin.NebulaURLs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NebulaURLs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        if (!$util.isString(message.inputs))
                            return "inputs: string expected";
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        if (!$util.isString(message.outputs))
                            return "outputs: string expected";
                    if (message.deck != null && message.hasOwnProperty("deck"))
                        if (!$util.isString(message.deck))
                            return "deck: string expected";
                    return null;
                };
    
                return NebulaURLs;
            })();
    
            admin.DescriptionEntity = (function() {
    
                /**
                 * Properties of a DescriptionEntity.
                 * @memberof nebulaidl.admin
                 * @interface IDescriptionEntity
                 * @property {nebulaidl.core.IIdentifier|null} [id] DescriptionEntity id
                 * @property {string|null} [shortDescription] DescriptionEntity shortDescription
                 * @property {nebulaidl.admin.IDescription|null} [longDescription] DescriptionEntity longDescription
                 * @property {nebulaidl.admin.ISourceCode|null} [sourceCode] DescriptionEntity sourceCode
                 * @property {Array.<string>|null} [tags] DescriptionEntity tags
                 */
    
                /**
                 * Constructs a new DescriptionEntity.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a DescriptionEntity.
                 * @implements IDescriptionEntity
                 * @constructor
                 * @param {nebulaidl.admin.IDescriptionEntity=} [properties] Properties to set
                 */
                function DescriptionEntity(properties) {
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptionEntity id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @instance
                 */
                DescriptionEntity.prototype.id = null;
    
                /**
                 * DescriptionEntity shortDescription.
                 * @member {string} shortDescription
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @instance
                 */
                DescriptionEntity.prototype.shortDescription = "";
    
                /**
                 * DescriptionEntity longDescription.
                 * @member {nebulaidl.admin.IDescription|null|undefined} longDescription
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @instance
                 */
                DescriptionEntity.prototype.longDescription = null;
    
                /**
                 * DescriptionEntity sourceCode.
                 * @member {nebulaidl.admin.ISourceCode|null|undefined} sourceCode
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @instance
                 */
                DescriptionEntity.prototype.sourceCode = null;
    
                /**
                 * DescriptionEntity tags.
                 * @member {Array.<string>} tags
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @instance
                 */
                DescriptionEntity.prototype.tags = $util.emptyArray;
    
                /**
                 * Creates a new DescriptionEntity instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @static
                 * @param {nebulaidl.admin.IDescriptionEntity=} [properties] Properties to set
                 * @returns {nebulaidl.admin.DescriptionEntity} DescriptionEntity instance
                 */
                DescriptionEntity.create = function create(properties) {
                    return new DescriptionEntity(properties);
                };
    
                /**
                 * Encodes the specified DescriptionEntity message. Does not implicitly {@link nebulaidl.admin.DescriptionEntity.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @static
                 * @param {nebulaidl.admin.IDescriptionEntity} message DescriptionEntity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptionEntity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.shortDescription);
                    if (message.longDescription != null && message.hasOwnProperty("longDescription"))
                        $root.nebulaidl.admin.Description.encode(message.longDescription, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.sourceCode != null && message.hasOwnProperty("sourceCode"))
                        $root.nebulaidl.admin.SourceCode.encode(message.sourceCode, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
                    return writer;
                };
    
                /**
                 * Decodes a DescriptionEntity message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.DescriptionEntity} DescriptionEntity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptionEntity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.DescriptionEntity();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.shortDescription = reader.string();
                            break;
                        case 3:
                            message.longDescription = $root.nebulaidl.admin.Description.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.sourceCode = $root.nebulaidl.admin.SourceCode.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DescriptionEntity message.
                 * @function verify
                 * @memberof nebulaidl.admin.DescriptionEntity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptionEntity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    if (message.longDescription != null && message.hasOwnProperty("longDescription")) {
                        var error = $root.nebulaidl.admin.Description.verify(message.longDescription);
                        if (error)
                            return "longDescription." + error;
                    }
                    if (message.sourceCode != null && message.hasOwnProperty("sourceCode")) {
                        var error = $root.nebulaidl.admin.SourceCode.verify(message.sourceCode);
                        if (error)
                            return "sourceCode." + error;
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    return null;
                };
    
                return DescriptionEntity;
            })();
    
            /**
             * DescriptionFormat enum.
             * @name nebulaidl.admin.DescriptionFormat
             * @enum {string}
             * @property {number} DESCRIPTION_FORMAT_UNKNOWN=0 DESCRIPTION_FORMAT_UNKNOWN value
             * @property {number} DESCRIPTION_FORMAT_MARKDOWN=1 DESCRIPTION_FORMAT_MARKDOWN value
             * @property {number} DESCRIPTION_FORMAT_HTML=2 DESCRIPTION_FORMAT_HTML value
             * @property {number} DESCRIPTION_FORMAT_RST=3 DESCRIPTION_FORMAT_RST value
             */
            admin.DescriptionFormat = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DESCRIPTION_FORMAT_UNKNOWN"] = 0;
                values[valuesById[1] = "DESCRIPTION_FORMAT_MARKDOWN"] = 1;
                values[valuesById[2] = "DESCRIPTION_FORMAT_HTML"] = 2;
                values[valuesById[3] = "DESCRIPTION_FORMAT_RST"] = 3;
                return values;
            })();
    
            admin.Description = (function() {
    
                /**
                 * Properties of a Description.
                 * @memberof nebulaidl.admin
                 * @interface IDescription
                 * @property {string|null} [value] Description value
                 * @property {string|null} [uri] Description uri
                 * @property {nebulaidl.admin.DescriptionFormat|null} [format] Description format
                 * @property {string|null} [iconLink] Description iconLink
                 */
    
                /**
                 * Constructs a new Description.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Description.
                 * @implements IDescription
                 * @constructor
                 * @param {nebulaidl.admin.IDescription=} [properties] Properties to set
                 */
                function Description(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Description value.
                 * @member {string} value
                 * @memberof nebulaidl.admin.Description
                 * @instance
                 */
                Description.prototype.value = "";
    
                /**
                 * Description uri.
                 * @member {string} uri
                 * @memberof nebulaidl.admin.Description
                 * @instance
                 */
                Description.prototype.uri = "";
    
                /**
                 * Description format.
                 * @member {nebulaidl.admin.DescriptionFormat} format
                 * @memberof nebulaidl.admin.Description
                 * @instance
                 */
                Description.prototype.format = 0;
    
                /**
                 * Description iconLink.
                 * @member {string} iconLink
                 * @memberof nebulaidl.admin.Description
                 * @instance
                 */
                Description.prototype.iconLink = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Description content.
                 * @member {"value"|"uri"|undefined} content
                 * @memberof nebulaidl.admin.Description
                 * @instance
                 */
                Object.defineProperty(Description.prototype, "content", {
                    get: $util.oneOfGetter($oneOfFields = ["value", "uri"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Description instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Description
                 * @static
                 * @param {nebulaidl.admin.IDescription=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Description} Description instance
                 */
                Description.create = function create(properties) {
                    return new Description(properties);
                };
    
                /**
                 * Encodes the specified Description message. Does not implicitly {@link nebulaidl.admin.Description.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Description
                 * @static
                 * @param {nebulaidl.admin.IDescription} message Description message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Description.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                    if (message.format != null && message.hasOwnProperty("format"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.format);
                    if (message.iconLink != null && message.hasOwnProperty("iconLink"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.iconLink);
                    return writer;
                };
    
                /**
                 * Decodes a Description message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Description
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Description} Description
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Description.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Description();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.string();
                            break;
                        case 2:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.format = reader.int32();
                            break;
                        case 4:
                            message.iconLink = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Description message.
                 * @function verify
                 * @memberof nebulaidl.admin.Description
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Description.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.value != null && message.hasOwnProperty("value")) {
                        properties.content = 1;
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    }
                    if (message.uri != null && message.hasOwnProperty("uri")) {
                        if (properties.content === 1)
                            return "content: multiple values";
                        properties.content = 1;
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    }
                    if (message.format != null && message.hasOwnProperty("format"))
                        switch (message.format) {
                        default:
                            return "format: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.iconLink != null && message.hasOwnProperty("iconLink"))
                        if (!$util.isString(message.iconLink))
                            return "iconLink: string expected";
                    return null;
                };
    
                return Description;
            })();
    
            admin.SourceCode = (function() {
    
                /**
                 * Properties of a SourceCode.
                 * @memberof nebulaidl.admin
                 * @interface ISourceCode
                 * @property {string|null} [link] SourceCode link
                 */
    
                /**
                 * Constructs a new SourceCode.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SourceCode.
                 * @implements ISourceCode
                 * @constructor
                 * @param {nebulaidl.admin.ISourceCode=} [properties] Properties to set
                 */
                function SourceCode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCode link.
                 * @member {string} link
                 * @memberof nebulaidl.admin.SourceCode
                 * @instance
                 */
                SourceCode.prototype.link = "";
    
                /**
                 * Creates a new SourceCode instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SourceCode
                 * @static
                 * @param {nebulaidl.admin.ISourceCode=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SourceCode} SourceCode instance
                 */
                SourceCode.create = function create(properties) {
                    return new SourceCode(properties);
                };
    
                /**
                 * Encodes the specified SourceCode message. Does not implicitly {@link nebulaidl.admin.SourceCode.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SourceCode
                 * @static
                 * @param {nebulaidl.admin.ISourceCode} message SourceCode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.link != null && message.hasOwnProperty("link"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.link);
                    return writer;
                };
    
                /**
                 * Decodes a SourceCode message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SourceCode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SourceCode} SourceCode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SourceCode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.link = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SourceCode message.
                 * @function verify
                 * @memberof nebulaidl.admin.SourceCode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.link != null && message.hasOwnProperty("link"))
                        if (!$util.isString(message.link))
                            return "link: string expected";
                    return null;
                };
    
                return SourceCode;
            })();
    
            admin.DescriptionEntityList = (function() {
    
                /**
                 * Properties of a DescriptionEntityList.
                 * @memberof nebulaidl.admin
                 * @interface IDescriptionEntityList
                 * @property {Array.<nebulaidl.admin.IDescriptionEntity>|null} [descriptionEntities] DescriptionEntityList descriptionEntities
                 * @property {string|null} [token] DescriptionEntityList token
                 */
    
                /**
                 * Constructs a new DescriptionEntityList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a DescriptionEntityList.
                 * @implements IDescriptionEntityList
                 * @constructor
                 * @param {nebulaidl.admin.IDescriptionEntityList=} [properties] Properties to set
                 */
                function DescriptionEntityList(properties) {
                    this.descriptionEntities = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptionEntityList descriptionEntities.
                 * @member {Array.<nebulaidl.admin.IDescriptionEntity>} descriptionEntities
                 * @memberof nebulaidl.admin.DescriptionEntityList
                 * @instance
                 */
                DescriptionEntityList.prototype.descriptionEntities = $util.emptyArray;
    
                /**
                 * DescriptionEntityList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.DescriptionEntityList
                 * @instance
                 */
                DescriptionEntityList.prototype.token = "";
    
                /**
                 * Creates a new DescriptionEntityList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.DescriptionEntityList
                 * @static
                 * @param {nebulaidl.admin.IDescriptionEntityList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.DescriptionEntityList} DescriptionEntityList instance
                 */
                DescriptionEntityList.create = function create(properties) {
                    return new DescriptionEntityList(properties);
                };
    
                /**
                 * Encodes the specified DescriptionEntityList message. Does not implicitly {@link nebulaidl.admin.DescriptionEntityList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.DescriptionEntityList
                 * @static
                 * @param {nebulaidl.admin.IDescriptionEntityList} message DescriptionEntityList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptionEntityList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.descriptionEntities != null && message.descriptionEntities.length)
                        for (var i = 0; i < message.descriptionEntities.length; ++i)
                            $root.nebulaidl.admin.DescriptionEntity.encode(message.descriptionEntities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a DescriptionEntityList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.DescriptionEntityList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.DescriptionEntityList} DescriptionEntityList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptionEntityList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.DescriptionEntityList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.descriptionEntities && message.descriptionEntities.length))
                                message.descriptionEntities = [];
                            message.descriptionEntities.push($root.nebulaidl.admin.DescriptionEntity.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DescriptionEntityList message.
                 * @function verify
                 * @memberof nebulaidl.admin.DescriptionEntityList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptionEntityList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.descriptionEntities != null && message.hasOwnProperty("descriptionEntities")) {
                        if (!Array.isArray(message.descriptionEntities))
                            return "descriptionEntities: array expected";
                        for (var i = 0; i < message.descriptionEntities.length; ++i) {
                            var error = $root.nebulaidl.admin.DescriptionEntity.verify(message.descriptionEntities[i]);
                            if (error)
                                return "descriptionEntities." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return DescriptionEntityList;
            })();
    
            admin.DescriptionEntityListRequest = (function() {
    
                /**
                 * Properties of a DescriptionEntityListRequest.
                 * @memberof nebulaidl.admin
                 * @interface IDescriptionEntityListRequest
                 * @property {nebulaidl.core.ResourceType|null} [resourceType] DescriptionEntityListRequest resourceType
                 * @property {nebulaidl.admin.INamedEntityIdentifier|null} [id] DescriptionEntityListRequest id
                 * @property {number|null} [limit] DescriptionEntityListRequest limit
                 * @property {string|null} [token] DescriptionEntityListRequest token
                 * @property {string|null} [filters] DescriptionEntityListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] DescriptionEntityListRequest sortBy
                 */
    
                /**
                 * Constructs a new DescriptionEntityListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a DescriptionEntityListRequest.
                 * @implements IDescriptionEntityListRequest
                 * @constructor
                 * @param {nebulaidl.admin.IDescriptionEntityListRequest=} [properties] Properties to set
                 */
                function DescriptionEntityListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptionEntityListRequest resourceType.
                 * @member {nebulaidl.core.ResourceType} resourceType
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @instance
                 */
                DescriptionEntityListRequest.prototype.resourceType = 0;
    
                /**
                 * DescriptionEntityListRequest id.
                 * @member {nebulaidl.admin.INamedEntityIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @instance
                 */
                DescriptionEntityListRequest.prototype.id = null;
    
                /**
                 * DescriptionEntityListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @instance
                 */
                DescriptionEntityListRequest.prototype.limit = 0;
    
                /**
                 * DescriptionEntityListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @instance
                 */
                DescriptionEntityListRequest.prototype.token = "";
    
                /**
                 * DescriptionEntityListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @instance
                 */
                DescriptionEntityListRequest.prototype.filters = "";
    
                /**
                 * DescriptionEntityListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @instance
                 */
                DescriptionEntityListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new DescriptionEntityListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @static
                 * @param {nebulaidl.admin.IDescriptionEntityListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.DescriptionEntityListRequest} DescriptionEntityListRequest instance
                 */
                DescriptionEntityListRequest.create = function create(properties) {
                    return new DescriptionEntityListRequest(properties);
                };
    
                /**
                 * Encodes the specified DescriptionEntityListRequest message. Does not implicitly {@link nebulaidl.admin.DescriptionEntityListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @static
                 * @param {nebulaidl.admin.IDescriptionEntityListRequest} message DescriptionEntityListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptionEntityListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a DescriptionEntityListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.DescriptionEntityListRequest} DescriptionEntityListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptionEntityListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.DescriptionEntityListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        case 2:
                            message.id = $root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.limit = reader.uint32();
                            break;
                        case 4:
                            message.token = reader.string();
                            break;
                        case 5:
                            message.filters = reader.string();
                            break;
                        case 6:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DescriptionEntityListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.DescriptionEntityListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptionEntityListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return DescriptionEntityListRequest;
            })();
    
            admin.EventErrorAlreadyInTerminalState = (function() {
    
                /**
                 * Properties of an EventErrorAlreadyInTerminalState.
                 * @memberof nebulaidl.admin
                 * @interface IEventErrorAlreadyInTerminalState
                 * @property {string|null} [currentPhase] EventErrorAlreadyInTerminalState currentPhase
                 */
    
                /**
                 * Constructs a new EventErrorAlreadyInTerminalState.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an EventErrorAlreadyInTerminalState.
                 * @implements IEventErrorAlreadyInTerminalState
                 * @constructor
                 * @param {nebulaidl.admin.IEventErrorAlreadyInTerminalState=} [properties] Properties to set
                 */
                function EventErrorAlreadyInTerminalState(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventErrorAlreadyInTerminalState currentPhase.
                 * @member {string} currentPhase
                 * @memberof nebulaidl.admin.EventErrorAlreadyInTerminalState
                 * @instance
                 */
                EventErrorAlreadyInTerminalState.prototype.currentPhase = "";
    
                /**
                 * Creates a new EventErrorAlreadyInTerminalState instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.EventErrorAlreadyInTerminalState
                 * @static
                 * @param {nebulaidl.admin.IEventErrorAlreadyInTerminalState=} [properties] Properties to set
                 * @returns {nebulaidl.admin.EventErrorAlreadyInTerminalState} EventErrorAlreadyInTerminalState instance
                 */
                EventErrorAlreadyInTerminalState.create = function create(properties) {
                    return new EventErrorAlreadyInTerminalState(properties);
                };
    
                /**
                 * Encodes the specified EventErrorAlreadyInTerminalState message. Does not implicitly {@link nebulaidl.admin.EventErrorAlreadyInTerminalState.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.EventErrorAlreadyInTerminalState
                 * @static
                 * @param {nebulaidl.admin.IEventErrorAlreadyInTerminalState} message EventErrorAlreadyInTerminalState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventErrorAlreadyInTerminalState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.currentPhase != null && message.hasOwnProperty("currentPhase"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.currentPhase);
                    return writer;
                };
    
                /**
                 * Decodes an EventErrorAlreadyInTerminalState message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.EventErrorAlreadyInTerminalState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.EventErrorAlreadyInTerminalState} EventErrorAlreadyInTerminalState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventErrorAlreadyInTerminalState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.EventErrorAlreadyInTerminalState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.currentPhase = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EventErrorAlreadyInTerminalState message.
                 * @function verify
                 * @memberof nebulaidl.admin.EventErrorAlreadyInTerminalState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventErrorAlreadyInTerminalState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.currentPhase != null && message.hasOwnProperty("currentPhase"))
                        if (!$util.isString(message.currentPhase))
                            return "currentPhase: string expected";
                    return null;
                };
    
                return EventErrorAlreadyInTerminalState;
            })();
    
            admin.EventErrorIncompatibleCluster = (function() {
    
                /**
                 * Properties of an EventErrorIncompatibleCluster.
                 * @memberof nebulaidl.admin
                 * @interface IEventErrorIncompatibleCluster
                 * @property {string|null} [cluster] EventErrorIncompatibleCluster cluster
                 */
    
                /**
                 * Constructs a new EventErrorIncompatibleCluster.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an EventErrorIncompatibleCluster.
                 * @implements IEventErrorIncompatibleCluster
                 * @constructor
                 * @param {nebulaidl.admin.IEventErrorIncompatibleCluster=} [properties] Properties to set
                 */
                function EventErrorIncompatibleCluster(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventErrorIncompatibleCluster cluster.
                 * @member {string} cluster
                 * @memberof nebulaidl.admin.EventErrorIncompatibleCluster
                 * @instance
                 */
                EventErrorIncompatibleCluster.prototype.cluster = "";
    
                /**
                 * Creates a new EventErrorIncompatibleCluster instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.EventErrorIncompatibleCluster
                 * @static
                 * @param {nebulaidl.admin.IEventErrorIncompatibleCluster=} [properties] Properties to set
                 * @returns {nebulaidl.admin.EventErrorIncompatibleCluster} EventErrorIncompatibleCluster instance
                 */
                EventErrorIncompatibleCluster.create = function create(properties) {
                    return new EventErrorIncompatibleCluster(properties);
                };
    
                /**
                 * Encodes the specified EventErrorIncompatibleCluster message. Does not implicitly {@link nebulaidl.admin.EventErrorIncompatibleCluster.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.EventErrorIncompatibleCluster
                 * @static
                 * @param {nebulaidl.admin.IEventErrorIncompatibleCluster} message EventErrorIncompatibleCluster message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventErrorIncompatibleCluster.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster);
                    return writer;
                };
    
                /**
                 * Decodes an EventErrorIncompatibleCluster message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.EventErrorIncompatibleCluster
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.EventErrorIncompatibleCluster} EventErrorIncompatibleCluster
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventErrorIncompatibleCluster.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.EventErrorIncompatibleCluster();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cluster = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EventErrorIncompatibleCluster message.
                 * @function verify
                 * @memberof nebulaidl.admin.EventErrorIncompatibleCluster
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventErrorIncompatibleCluster.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    return null;
                };
    
                return EventErrorIncompatibleCluster;
            })();
    
            admin.EventFailureReason = (function() {
    
                /**
                 * Properties of an EventFailureReason.
                 * @memberof nebulaidl.admin
                 * @interface IEventFailureReason
                 * @property {nebulaidl.admin.IEventErrorAlreadyInTerminalState|null} [alreadyInTerminalState] EventFailureReason alreadyInTerminalState
                 * @property {nebulaidl.admin.IEventErrorIncompatibleCluster|null} [incompatibleCluster] EventFailureReason incompatibleCluster
                 */
    
                /**
                 * Constructs a new EventFailureReason.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an EventFailureReason.
                 * @implements IEventFailureReason
                 * @constructor
                 * @param {nebulaidl.admin.IEventFailureReason=} [properties] Properties to set
                 */
                function EventFailureReason(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EventFailureReason alreadyInTerminalState.
                 * @member {nebulaidl.admin.IEventErrorAlreadyInTerminalState|null|undefined} alreadyInTerminalState
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @instance
                 */
                EventFailureReason.prototype.alreadyInTerminalState = null;
    
                /**
                 * EventFailureReason incompatibleCluster.
                 * @member {nebulaidl.admin.IEventErrorIncompatibleCluster|null|undefined} incompatibleCluster
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @instance
                 */
                EventFailureReason.prototype.incompatibleCluster = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * EventFailureReason reason.
                 * @member {"alreadyInTerminalState"|"incompatibleCluster"|undefined} reason
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @instance
                 */
                Object.defineProperty(EventFailureReason.prototype, "reason", {
                    get: $util.oneOfGetter($oneOfFields = ["alreadyInTerminalState", "incompatibleCluster"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new EventFailureReason instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @static
                 * @param {nebulaidl.admin.IEventFailureReason=} [properties] Properties to set
                 * @returns {nebulaidl.admin.EventFailureReason} EventFailureReason instance
                 */
                EventFailureReason.create = function create(properties) {
                    return new EventFailureReason(properties);
                };
    
                /**
                 * Encodes the specified EventFailureReason message. Does not implicitly {@link nebulaidl.admin.EventFailureReason.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @static
                 * @param {nebulaidl.admin.IEventFailureReason} message EventFailureReason message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventFailureReason.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alreadyInTerminalState != null && message.hasOwnProperty("alreadyInTerminalState"))
                        $root.nebulaidl.admin.EventErrorAlreadyInTerminalState.encode(message.alreadyInTerminalState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.incompatibleCluster != null && message.hasOwnProperty("incompatibleCluster"))
                        $root.nebulaidl.admin.EventErrorIncompatibleCluster.encode(message.incompatibleCluster, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EventFailureReason message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.EventFailureReason} EventFailureReason
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventFailureReason.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.EventFailureReason();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alreadyInTerminalState = $root.nebulaidl.admin.EventErrorAlreadyInTerminalState.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.incompatibleCluster = $root.nebulaidl.admin.EventErrorIncompatibleCluster.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EventFailureReason message.
                 * @function verify
                 * @memberof nebulaidl.admin.EventFailureReason
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventFailureReason.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.alreadyInTerminalState != null && message.hasOwnProperty("alreadyInTerminalState")) {
                        properties.reason = 1;
                        {
                            var error = $root.nebulaidl.admin.EventErrorAlreadyInTerminalState.verify(message.alreadyInTerminalState);
                            if (error)
                                return "alreadyInTerminalState." + error;
                        }
                    }
                    if (message.incompatibleCluster != null && message.hasOwnProperty("incompatibleCluster")) {
                        if (properties.reason === 1)
                            return "reason: multiple values";
                        properties.reason = 1;
                        {
                            var error = $root.nebulaidl.admin.EventErrorIncompatibleCluster.verify(message.incompatibleCluster);
                            if (error)
                                return "incompatibleCluster." + error;
                        }
                    }
                    return null;
                };
    
                return EventFailureReason;
            })();
    
            admin.WorkflowExecutionEventRequest = (function() {
    
                /**
                 * Properties of a WorkflowExecutionEventRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionEventRequest
                 * @property {string|null} [requestId] WorkflowExecutionEventRequest requestId
                 * @property {nebulaidl.event.IWorkflowExecutionEvent|null} [event] WorkflowExecutionEventRequest event
                 */
    
                /**
                 * Constructs a new WorkflowExecutionEventRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionEventRequest.
                 * @implements IWorkflowExecutionEventRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionEventRequest=} [properties] Properties to set
                 */
                function WorkflowExecutionEventRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionEventRequest requestId.
                 * @member {string} requestId
                 * @memberof nebulaidl.admin.WorkflowExecutionEventRequest
                 * @instance
                 */
                WorkflowExecutionEventRequest.prototype.requestId = "";
    
                /**
                 * WorkflowExecutionEventRequest event.
                 * @member {nebulaidl.event.IWorkflowExecutionEvent|null|undefined} event
                 * @memberof nebulaidl.admin.WorkflowExecutionEventRequest
                 * @instance
                 */
                WorkflowExecutionEventRequest.prototype.event = null;
    
                /**
                 * Creates a new WorkflowExecutionEventRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionEventRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionEventRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionEventRequest} WorkflowExecutionEventRequest instance
                 */
                WorkflowExecutionEventRequest.create = function create(properties) {
                    return new WorkflowExecutionEventRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionEventRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionEventRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionEventRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionEventRequest} message WorkflowExecutionEventRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionEventRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestId);
                    if (message.event != null && message.hasOwnProperty("event"))
                        $root.nebulaidl.event.WorkflowExecutionEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionEventRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionEventRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionEventRequest} WorkflowExecutionEventRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionEventRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionEventRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.requestId = reader.string();
                            break;
                        case 2:
                            message.event = $root.nebulaidl.event.WorkflowExecutionEvent.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionEventRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionEventRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionEventRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        if (!$util.isString(message.requestId))
                            return "requestId: string expected";
                    if (message.event != null && message.hasOwnProperty("event")) {
                        var error = $root.nebulaidl.event.WorkflowExecutionEvent.verify(message.event);
                        if (error)
                            return "event." + error;
                    }
                    return null;
                };
    
                return WorkflowExecutionEventRequest;
            })();
    
            admin.WorkflowExecutionEventResponse = (function() {
    
                /**
                 * Properties of a WorkflowExecutionEventResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionEventResponse
                 */
    
                /**
                 * Constructs a new WorkflowExecutionEventResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionEventResponse.
                 * @implements IWorkflowExecutionEventResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionEventResponse=} [properties] Properties to set
                 */
                function WorkflowExecutionEventResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WorkflowExecutionEventResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionEventResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionEventResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionEventResponse} WorkflowExecutionEventResponse instance
                 */
                WorkflowExecutionEventResponse.create = function create(properties) {
                    return new WorkflowExecutionEventResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionEventResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionEventResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionEventResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionEventResponse} message WorkflowExecutionEventResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionEventResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionEventResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionEventResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionEventResponse} WorkflowExecutionEventResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionEventResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionEventResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionEventResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionEventResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionEventResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return WorkflowExecutionEventResponse;
            })();
    
            admin.NodeExecutionEventRequest = (function() {
    
                /**
                 * Properties of a NodeExecutionEventRequest.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionEventRequest
                 * @property {string|null} [requestId] NodeExecutionEventRequest requestId
                 * @property {nebulaidl.event.INodeExecutionEvent|null} [event] NodeExecutionEventRequest event
                 */
    
                /**
                 * Constructs a new NodeExecutionEventRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionEventRequest.
                 * @implements INodeExecutionEventRequest
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionEventRequest=} [properties] Properties to set
                 */
                function NodeExecutionEventRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionEventRequest requestId.
                 * @member {string} requestId
                 * @memberof nebulaidl.admin.NodeExecutionEventRequest
                 * @instance
                 */
                NodeExecutionEventRequest.prototype.requestId = "";
    
                /**
                 * NodeExecutionEventRequest event.
                 * @member {nebulaidl.event.INodeExecutionEvent|null|undefined} event
                 * @memberof nebulaidl.admin.NodeExecutionEventRequest
                 * @instance
                 */
                NodeExecutionEventRequest.prototype.event = null;
    
                /**
                 * Creates a new NodeExecutionEventRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionEventRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionEventRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionEventRequest} NodeExecutionEventRequest instance
                 */
                NodeExecutionEventRequest.create = function create(properties) {
                    return new NodeExecutionEventRequest(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionEventRequest message. Does not implicitly {@link nebulaidl.admin.NodeExecutionEventRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionEventRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionEventRequest} message NodeExecutionEventRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionEventRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestId);
                    if (message.event != null && message.hasOwnProperty("event"))
                        $root.nebulaidl.event.NodeExecutionEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionEventRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionEventRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionEventRequest} NodeExecutionEventRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionEventRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionEventRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.requestId = reader.string();
                            break;
                        case 2:
                            message.event = $root.nebulaidl.event.NodeExecutionEvent.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionEventRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionEventRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionEventRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        if (!$util.isString(message.requestId))
                            return "requestId: string expected";
                    if (message.event != null && message.hasOwnProperty("event")) {
                        var error = $root.nebulaidl.event.NodeExecutionEvent.verify(message.event);
                        if (error)
                            return "event." + error;
                    }
                    return null;
                };
    
                return NodeExecutionEventRequest;
            })();
    
            admin.NodeExecutionEventResponse = (function() {
    
                /**
                 * Properties of a NodeExecutionEventResponse.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionEventResponse
                 */
    
                /**
                 * Constructs a new NodeExecutionEventResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionEventResponse.
                 * @implements INodeExecutionEventResponse
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionEventResponse=} [properties] Properties to set
                 */
                function NodeExecutionEventResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new NodeExecutionEventResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionEventResponse
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionEventResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionEventResponse} NodeExecutionEventResponse instance
                 */
                NodeExecutionEventResponse.create = function create(properties) {
                    return new NodeExecutionEventResponse(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionEventResponse message. Does not implicitly {@link nebulaidl.admin.NodeExecutionEventResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionEventResponse
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionEventResponse} message NodeExecutionEventResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionEventResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionEventResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionEventResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionEventResponse} NodeExecutionEventResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionEventResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionEventResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionEventResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionEventResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionEventResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return NodeExecutionEventResponse;
            })();
    
            admin.TaskExecutionEventRequest = (function() {
    
                /**
                 * Properties of a TaskExecutionEventRequest.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionEventRequest
                 * @property {string|null} [requestId] TaskExecutionEventRequest requestId
                 * @property {nebulaidl.event.ITaskExecutionEvent|null} [event] TaskExecutionEventRequest event
                 */
    
                /**
                 * Constructs a new TaskExecutionEventRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionEventRequest.
                 * @implements ITaskExecutionEventRequest
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionEventRequest=} [properties] Properties to set
                 */
                function TaskExecutionEventRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionEventRequest requestId.
                 * @member {string} requestId
                 * @memberof nebulaidl.admin.TaskExecutionEventRequest
                 * @instance
                 */
                TaskExecutionEventRequest.prototype.requestId = "";
    
                /**
                 * TaskExecutionEventRequest event.
                 * @member {nebulaidl.event.ITaskExecutionEvent|null|undefined} event
                 * @memberof nebulaidl.admin.TaskExecutionEventRequest
                 * @instance
                 */
                TaskExecutionEventRequest.prototype.event = null;
    
                /**
                 * Creates a new TaskExecutionEventRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionEventRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionEventRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionEventRequest} TaskExecutionEventRequest instance
                 */
                TaskExecutionEventRequest.create = function create(properties) {
                    return new TaskExecutionEventRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionEventRequest message. Does not implicitly {@link nebulaidl.admin.TaskExecutionEventRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionEventRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionEventRequest} message TaskExecutionEventRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionEventRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.requestId);
                    if (message.event != null && message.hasOwnProperty("event"))
                        $root.nebulaidl.event.TaskExecutionEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionEventRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionEventRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionEventRequest} TaskExecutionEventRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionEventRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionEventRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.requestId = reader.string();
                            break;
                        case 2:
                            message.event = $root.nebulaidl.event.TaskExecutionEvent.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionEventRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionEventRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionEventRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        if (!$util.isString(message.requestId))
                            return "requestId: string expected";
                    if (message.event != null && message.hasOwnProperty("event")) {
                        var error = $root.nebulaidl.event.TaskExecutionEvent.verify(message.event);
                        if (error)
                            return "event." + error;
                    }
                    return null;
                };
    
                return TaskExecutionEventRequest;
            })();
    
            admin.TaskExecutionEventResponse = (function() {
    
                /**
                 * Properties of a TaskExecutionEventResponse.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionEventResponse
                 */
    
                /**
                 * Constructs a new TaskExecutionEventResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionEventResponse.
                 * @implements ITaskExecutionEventResponse
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionEventResponse=} [properties] Properties to set
                 */
                function TaskExecutionEventResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new TaskExecutionEventResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionEventResponse
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionEventResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionEventResponse} TaskExecutionEventResponse instance
                 */
                TaskExecutionEventResponse.create = function create(properties) {
                    return new TaskExecutionEventResponse(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionEventResponse message. Does not implicitly {@link nebulaidl.admin.TaskExecutionEventResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionEventResponse
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionEventResponse} message TaskExecutionEventResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionEventResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionEventResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionEventResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionEventResponse} TaskExecutionEventResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionEventResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionEventResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionEventResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionEventResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionEventResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return TaskExecutionEventResponse;
            })();
    
            admin.ExecutionCreateRequest = (function() {
    
                /**
                 * Properties of an ExecutionCreateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionCreateRequest
                 * @property {string|null} [project] ExecutionCreateRequest project
                 * @property {string|null} [domain] ExecutionCreateRequest domain
                 * @property {string|null} [name] ExecutionCreateRequest name
                 * @property {nebulaidl.admin.IExecutionSpec|null} [spec] ExecutionCreateRequest spec
                 * @property {nebulaidl.core.ILiteralMap|null} [inputs] ExecutionCreateRequest inputs
                 */
    
                /**
                 * Constructs a new ExecutionCreateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionCreateRequest.
                 * @implements IExecutionCreateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionCreateRequest=} [properties] Properties to set
                 */
                function ExecutionCreateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionCreateRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @instance
                 */
                ExecutionCreateRequest.prototype.project = "";
    
                /**
                 * ExecutionCreateRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @instance
                 */
                ExecutionCreateRequest.prototype.domain = "";
    
                /**
                 * ExecutionCreateRequest name.
                 * @member {string} name
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @instance
                 */
                ExecutionCreateRequest.prototype.name = "";
    
                /**
                 * ExecutionCreateRequest spec.
                 * @member {nebulaidl.admin.IExecutionSpec|null|undefined} spec
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @instance
                 */
                ExecutionCreateRequest.prototype.spec = null;
    
                /**
                 * ExecutionCreateRequest inputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} inputs
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @instance
                 */
                ExecutionCreateRequest.prototype.inputs = null;
    
                /**
                 * Creates a new ExecutionCreateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionCreateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionCreateRequest} ExecutionCreateRequest instance
                 */
                ExecutionCreateRequest.create = function create(properties) {
                    return new ExecutionCreateRequest(properties);
                };
    
                /**
                 * Encodes the specified ExecutionCreateRequest message. Does not implicitly {@link nebulaidl.admin.ExecutionCreateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionCreateRequest} message ExecutionCreateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionCreateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.admin.ExecutionSpec.encode(message.spec, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.inputs, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionCreateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionCreateRequest} ExecutionCreateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionCreateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionCreateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.spec = $root.nebulaidl.admin.ExecutionSpec.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.inputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionCreateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionCreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionCreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.nebulaidl.admin.ExecutionSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    return null;
                };
    
                return ExecutionCreateRequest;
            })();
    
            admin.ExecutionRelaunchRequest = (function() {
    
                /**
                 * Properties of an ExecutionRelaunchRequest.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionRelaunchRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionRelaunchRequest id
                 * @property {string|null} [name] ExecutionRelaunchRequest name
                 * @property {boolean|null} [overwriteCache] ExecutionRelaunchRequest overwriteCache
                 */
    
                /**
                 * Constructs a new ExecutionRelaunchRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionRelaunchRequest.
                 * @implements IExecutionRelaunchRequest
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionRelaunchRequest=} [properties] Properties to set
                 */
                function ExecutionRelaunchRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionRelaunchRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @instance
                 */
                ExecutionRelaunchRequest.prototype.id = null;
    
                /**
                 * ExecutionRelaunchRequest name.
                 * @member {string} name
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @instance
                 */
                ExecutionRelaunchRequest.prototype.name = "";
    
                /**
                 * ExecutionRelaunchRequest overwriteCache.
                 * @member {boolean} overwriteCache
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @instance
                 */
                ExecutionRelaunchRequest.prototype.overwriteCache = false;
    
                /**
                 * Creates a new ExecutionRelaunchRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionRelaunchRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionRelaunchRequest} ExecutionRelaunchRequest instance
                 */
                ExecutionRelaunchRequest.create = function create(properties) {
                    return new ExecutionRelaunchRequest(properties);
                };
    
                /**
                 * Encodes the specified ExecutionRelaunchRequest message. Does not implicitly {@link nebulaidl.admin.ExecutionRelaunchRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionRelaunchRequest} message ExecutionRelaunchRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionRelaunchRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.overwriteCache);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionRelaunchRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionRelaunchRequest} ExecutionRelaunchRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionRelaunchRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionRelaunchRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.overwriteCache = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionRelaunchRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionRelaunchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionRelaunchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        if (typeof message.overwriteCache !== "boolean")
                            return "overwriteCache: boolean expected";
                    return null;
                };
    
                return ExecutionRelaunchRequest;
            })();
    
            admin.ExecutionRecoverRequest = (function() {
    
                /**
                 * Properties of an ExecutionRecoverRequest.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionRecoverRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionRecoverRequest id
                 * @property {string|null} [name] ExecutionRecoverRequest name
                 * @property {nebulaidl.admin.IExecutionMetadata|null} [metadata] ExecutionRecoverRequest metadata
                 */
    
                /**
                 * Constructs a new ExecutionRecoverRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionRecoverRequest.
                 * @implements IExecutionRecoverRequest
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionRecoverRequest=} [properties] Properties to set
                 */
                function ExecutionRecoverRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionRecoverRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @instance
                 */
                ExecutionRecoverRequest.prototype.id = null;
    
                /**
                 * ExecutionRecoverRequest name.
                 * @member {string} name
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @instance
                 */
                ExecutionRecoverRequest.prototype.name = "";
    
                /**
                 * ExecutionRecoverRequest metadata.
                 * @member {nebulaidl.admin.IExecutionMetadata|null|undefined} metadata
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @instance
                 */
                ExecutionRecoverRequest.prototype.metadata = null;
    
                /**
                 * Creates a new ExecutionRecoverRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionRecoverRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionRecoverRequest} ExecutionRecoverRequest instance
                 */
                ExecutionRecoverRequest.create = function create(properties) {
                    return new ExecutionRecoverRequest(properties);
                };
    
                /**
                 * Encodes the specified ExecutionRecoverRequest message. Does not implicitly {@link nebulaidl.admin.ExecutionRecoverRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionRecoverRequest} message ExecutionRecoverRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionRecoverRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.admin.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionRecoverRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionRecoverRequest} ExecutionRecoverRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionRecoverRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionRecoverRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.metadata = $root.nebulaidl.admin.ExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionRecoverRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionRecoverRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionRecoverRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.admin.ExecutionMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                return ExecutionRecoverRequest;
            })();
    
            admin.ExecutionCreateResponse = (function() {
    
                /**
                 * Properties of an ExecutionCreateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionCreateResponse
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionCreateResponse id
                 */
    
                /**
                 * Constructs a new ExecutionCreateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionCreateResponse.
                 * @implements IExecutionCreateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionCreateResponse=} [properties] Properties to set
                 */
                function ExecutionCreateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionCreateResponse id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ExecutionCreateResponse
                 * @instance
                 */
                ExecutionCreateResponse.prototype.id = null;
    
                /**
                 * Creates a new ExecutionCreateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionCreateResponse
                 * @static
                 * @param {nebulaidl.admin.IExecutionCreateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionCreateResponse} ExecutionCreateResponse instance
                 */
                ExecutionCreateResponse.create = function create(properties) {
                    return new ExecutionCreateResponse(properties);
                };
    
                /**
                 * Encodes the specified ExecutionCreateResponse message. Does not implicitly {@link nebulaidl.admin.ExecutionCreateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionCreateResponse
                 * @static
                 * @param {nebulaidl.admin.IExecutionCreateResponse} message ExecutionCreateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionCreateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionCreateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionCreateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionCreateResponse} ExecutionCreateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionCreateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionCreateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionCreateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionCreateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionCreateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return ExecutionCreateResponse;
            })();
    
            admin.WorkflowExecutionGetRequest = (function() {
    
                /**
                 * Properties of a WorkflowExecutionGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionGetRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] WorkflowExecutionGetRequest id
                 */
    
                /**
                 * Constructs a new WorkflowExecutionGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionGetRequest.
                 * @implements IWorkflowExecutionGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionGetRequest=} [properties] Properties to set
                 */
                function WorkflowExecutionGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionGetRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.WorkflowExecutionGetRequest
                 * @instance
                 */
                WorkflowExecutionGetRequest.prototype.id = null;
    
                /**
                 * Creates a new WorkflowExecutionGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionGetRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionGetRequest} WorkflowExecutionGetRequest instance
                 */
                WorkflowExecutionGetRequest.create = function create(properties) {
                    return new WorkflowExecutionGetRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionGetRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetRequest} message WorkflowExecutionGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionGetRequest} WorkflowExecutionGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return WorkflowExecutionGetRequest;
            })();
    
            admin.Execution = (function() {
    
                /**
                 * Properties of an Execution.
                 * @memberof nebulaidl.admin
                 * @interface IExecution
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] Execution id
                 * @property {nebulaidl.admin.IExecutionSpec|null} [spec] Execution spec
                 * @property {nebulaidl.admin.IExecutionClosure|null} [closure] Execution closure
                 */
    
                /**
                 * Constructs a new Execution.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an Execution.
                 * @implements IExecution
                 * @constructor
                 * @param {nebulaidl.admin.IExecution=} [properties] Properties to set
                 */
                function Execution(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Execution id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.Execution
                 * @instance
                 */
                Execution.prototype.id = null;
    
                /**
                 * Execution spec.
                 * @member {nebulaidl.admin.IExecutionSpec|null|undefined} spec
                 * @memberof nebulaidl.admin.Execution
                 * @instance
                 */
                Execution.prototype.spec = null;
    
                /**
                 * Execution closure.
                 * @member {nebulaidl.admin.IExecutionClosure|null|undefined} closure
                 * @memberof nebulaidl.admin.Execution
                 * @instance
                 */
                Execution.prototype.closure = null;
    
                /**
                 * Creates a new Execution instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Execution
                 * @static
                 * @param {nebulaidl.admin.IExecution=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Execution} Execution instance
                 */
                Execution.create = function create(properties) {
                    return new Execution(properties);
                };
    
                /**
                 * Encodes the specified Execution message. Does not implicitly {@link nebulaidl.admin.Execution.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Execution
                 * @static
                 * @param {nebulaidl.admin.IExecution} message Execution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Execution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.admin.ExecutionSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.closure != null && message.hasOwnProperty("closure"))
                        $root.nebulaidl.admin.ExecutionClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an Execution message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Execution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Execution} Execution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Execution.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Execution();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.spec = $root.nebulaidl.admin.ExecutionSpec.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.closure = $root.nebulaidl.admin.ExecutionClosure.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Execution message.
                 * @function verify
                 * @memberof nebulaidl.admin.Execution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Execution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.nebulaidl.admin.ExecutionSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    if (message.closure != null && message.hasOwnProperty("closure")) {
                        var error = $root.nebulaidl.admin.ExecutionClosure.verify(message.closure);
                        if (error)
                            return "closure." + error;
                    }
                    return null;
                };
    
                return Execution;
            })();
    
            admin.ExecutionList = (function() {
    
                /**
                 * Properties of an ExecutionList.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionList
                 * @property {Array.<nebulaidl.admin.IExecution>|null} [executions] ExecutionList executions
                 * @property {string|null} [token] ExecutionList token
                 */
    
                /**
                 * Constructs a new ExecutionList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionList.
                 * @implements IExecutionList
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionList=} [properties] Properties to set
                 */
                function ExecutionList(properties) {
                    this.executions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionList executions.
                 * @member {Array.<nebulaidl.admin.IExecution>} executions
                 * @memberof nebulaidl.admin.ExecutionList
                 * @instance
                 */
                ExecutionList.prototype.executions = $util.emptyArray;
    
                /**
                 * ExecutionList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.ExecutionList
                 * @instance
                 */
                ExecutionList.prototype.token = "";
    
                /**
                 * Creates a new ExecutionList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionList
                 * @static
                 * @param {nebulaidl.admin.IExecutionList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionList} ExecutionList instance
                 */
                ExecutionList.create = function create(properties) {
                    return new ExecutionList(properties);
                };
    
                /**
                 * Encodes the specified ExecutionList message. Does not implicitly {@link nebulaidl.admin.ExecutionList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionList
                 * @static
                 * @param {nebulaidl.admin.IExecutionList} message ExecutionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.executions != null && message.executions.length)
                        for (var i = 0; i < message.executions.length; ++i)
                            $root.nebulaidl.admin.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionList} ExecutionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.executions && message.executions.length))
                                message.executions = [];
                            message.executions.push($root.nebulaidl.admin.Execution.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionList message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.executions != null && message.hasOwnProperty("executions")) {
                        if (!Array.isArray(message.executions))
                            return "executions: array expected";
                        for (var i = 0; i < message.executions.length; ++i) {
                            var error = $root.nebulaidl.admin.Execution.verify(message.executions[i]);
                            if (error)
                                return "executions." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return ExecutionList;
            })();
    
            admin.LiteralMapBlob = (function() {
    
                /**
                 * Properties of a LiteralMapBlob.
                 * @memberof nebulaidl.admin
                 * @interface ILiteralMapBlob
                 * @property {nebulaidl.core.ILiteralMap|null} [values] LiteralMapBlob values
                 * @property {string|null} [uri] LiteralMapBlob uri
                 */
    
                /**
                 * Constructs a new LiteralMapBlob.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LiteralMapBlob.
                 * @implements ILiteralMapBlob
                 * @constructor
                 * @param {nebulaidl.admin.ILiteralMapBlob=} [properties] Properties to set
                 */
                function LiteralMapBlob(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LiteralMapBlob values.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} values
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @instance
                 */
                LiteralMapBlob.prototype.values = null;
    
                /**
                 * LiteralMapBlob uri.
                 * @member {string} uri
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @instance
                 */
                LiteralMapBlob.prototype.uri = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * LiteralMapBlob data.
                 * @member {"values"|"uri"|undefined} data
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @instance
                 */
                Object.defineProperty(LiteralMapBlob.prototype, "data", {
                    get: $util.oneOfGetter($oneOfFields = ["values", "uri"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new LiteralMapBlob instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @static
                 * @param {nebulaidl.admin.ILiteralMapBlob=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LiteralMapBlob} LiteralMapBlob instance
                 */
                LiteralMapBlob.create = function create(properties) {
                    return new LiteralMapBlob(properties);
                };
    
                /**
                 * Encodes the specified LiteralMapBlob message. Does not implicitly {@link nebulaidl.admin.LiteralMapBlob.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @static
                 * @param {nebulaidl.admin.ILiteralMapBlob} message LiteralMapBlob message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiteralMapBlob.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.hasOwnProperty("values"))
                        $root.nebulaidl.core.LiteralMap.encode(message.values, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                    return writer;
                };
    
                /**
                 * Decodes a LiteralMapBlob message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LiteralMapBlob} LiteralMapBlob
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiteralMapBlob.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LiteralMapBlob();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.values = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.uri = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LiteralMapBlob message.
                 * @function verify
                 * @memberof nebulaidl.admin.LiteralMapBlob
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LiteralMapBlob.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.values != null && message.hasOwnProperty("values")) {
                        properties.data = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.values);
                            if (error)
                                return "values." + error;
                        }
                    }
                    if (message.uri != null && message.hasOwnProperty("uri")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    }
                    return null;
                };
    
                return LiteralMapBlob;
            })();
    
            admin.AbortMetadata = (function() {
    
                /**
                 * Properties of an AbortMetadata.
                 * @memberof nebulaidl.admin
                 * @interface IAbortMetadata
                 * @property {string|null} [cause] AbortMetadata cause
                 * @property {string|null} [principal] AbortMetadata principal
                 */
    
                /**
                 * Constructs a new AbortMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an AbortMetadata.
                 * @implements IAbortMetadata
                 * @constructor
                 * @param {nebulaidl.admin.IAbortMetadata=} [properties] Properties to set
                 */
                function AbortMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * AbortMetadata cause.
                 * @member {string} cause
                 * @memberof nebulaidl.admin.AbortMetadata
                 * @instance
                 */
                AbortMetadata.prototype.cause = "";
    
                /**
                 * AbortMetadata principal.
                 * @member {string} principal
                 * @memberof nebulaidl.admin.AbortMetadata
                 * @instance
                 */
                AbortMetadata.prototype.principal = "";
    
                /**
                 * Creates a new AbortMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.AbortMetadata
                 * @static
                 * @param {nebulaidl.admin.IAbortMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.AbortMetadata} AbortMetadata instance
                 */
                AbortMetadata.create = function create(properties) {
                    return new AbortMetadata(properties);
                };
    
                /**
                 * Encodes the specified AbortMetadata message. Does not implicitly {@link nebulaidl.admin.AbortMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.AbortMetadata
                 * @static
                 * @param {nebulaidl.admin.IAbortMetadata} message AbortMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AbortMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cause != null && message.hasOwnProperty("cause"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cause);
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.principal);
                    return writer;
                };
    
                /**
                 * Decodes an AbortMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.AbortMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.AbortMetadata} AbortMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AbortMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.AbortMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cause = reader.string();
                            break;
                        case 2:
                            message.principal = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an AbortMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.AbortMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AbortMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cause != null && message.hasOwnProperty("cause"))
                        if (!$util.isString(message.cause))
                            return "cause: string expected";
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        if (!$util.isString(message.principal))
                            return "principal: string expected";
                    return null;
                };
    
                return AbortMetadata;
            })();
    
            admin.ExecutionClosure = (function() {
    
                /**
                 * Properties of an ExecutionClosure.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionClosure
                 * @property {nebulaidl.admin.ILiteralMapBlob|null} [outputs] ExecutionClosure outputs
                 * @property {nebulaidl.core.IExecutionError|null} [error] ExecutionClosure error
                 * @property {string|null} [abortCause] ExecutionClosure abortCause
                 * @property {nebulaidl.admin.IAbortMetadata|null} [abortMetadata] ExecutionClosure abortMetadata
                 * @property {nebulaidl.core.ILiteralMap|null} [outputData] ExecutionClosure outputData
                 * @property {nebulaidl.core.ILiteralMap|null} [computedInputs] ExecutionClosure computedInputs
                 * @property {nebulaidl.core.WorkflowExecution.Phase|null} [phase] ExecutionClosure phase
                 * @property {google.protobuf.ITimestamp|null} [startedAt] ExecutionClosure startedAt
                 * @property {google.protobuf.IDuration|null} [duration] ExecutionClosure duration
                 * @property {google.protobuf.ITimestamp|null} [createdAt] ExecutionClosure createdAt
                 * @property {google.protobuf.ITimestamp|null} [updatedAt] ExecutionClosure updatedAt
                 * @property {Array.<nebulaidl.admin.INotification>|null} [notifications] ExecutionClosure notifications
                 * @property {nebulaidl.core.IIdentifier|null} [workflowId] ExecutionClosure workflowId
                 * @property {nebulaidl.admin.IExecutionStateChangeDetails|null} [stateChangeDetails] ExecutionClosure stateChangeDetails
                 */
    
                /**
                 * Constructs a new ExecutionClosure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionClosure.
                 * @implements IExecutionClosure
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionClosure=} [properties] Properties to set
                 */
                function ExecutionClosure(properties) {
                    this.notifications = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionClosure outputs.
                 * @member {nebulaidl.admin.ILiteralMapBlob|null|undefined} outputs
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.outputs = null;
    
                /**
                 * ExecutionClosure error.
                 * @member {nebulaidl.core.IExecutionError|null|undefined} error
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.error = null;
    
                /**
                 * ExecutionClosure abortCause.
                 * @member {string} abortCause
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.abortCause = "";
    
                /**
                 * ExecutionClosure abortMetadata.
                 * @member {nebulaidl.admin.IAbortMetadata|null|undefined} abortMetadata
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.abortMetadata = null;
    
                /**
                 * ExecutionClosure outputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputData
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.outputData = null;
    
                /**
                 * ExecutionClosure computedInputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} computedInputs
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.computedInputs = null;
    
                /**
                 * ExecutionClosure phase.
                 * @member {nebulaidl.core.WorkflowExecution.Phase} phase
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.phase = 0;
    
                /**
                 * ExecutionClosure startedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} startedAt
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.startedAt = null;
    
                /**
                 * ExecutionClosure duration.
                 * @member {google.protobuf.IDuration|null|undefined} duration
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.duration = null;
    
                /**
                 * ExecutionClosure createdAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} createdAt
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.createdAt = null;
    
                /**
                 * ExecutionClosure updatedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.updatedAt = null;
    
                /**
                 * ExecutionClosure notifications.
                 * @member {Array.<nebulaidl.admin.INotification>} notifications
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.notifications = $util.emptyArray;
    
                /**
                 * ExecutionClosure workflowId.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} workflowId
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.workflowId = null;
    
                /**
                 * ExecutionClosure stateChangeDetails.
                 * @member {nebulaidl.admin.IExecutionStateChangeDetails|null|undefined} stateChangeDetails
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                ExecutionClosure.prototype.stateChangeDetails = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * ExecutionClosure outputResult.
                 * @member {"outputs"|"error"|"abortCause"|"abortMetadata"|"outputData"|undefined} outputResult
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @instance
                 */
                Object.defineProperty(ExecutionClosure.prototype, "outputResult", {
                    get: $util.oneOfGetter($oneOfFields = ["outputs", "error", "abortCause", "abortMetadata", "outputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new ExecutionClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @static
                 * @param {nebulaidl.admin.IExecutionClosure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionClosure} ExecutionClosure instance
                 */
                ExecutionClosure.create = function create(properties) {
                    return new ExecutionClosure(properties);
                };
    
                /**
                 * Encodes the specified ExecutionClosure message. Does not implicitly {@link nebulaidl.admin.ExecutionClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @static
                 * @param {nebulaidl.admin.IExecutionClosure} message ExecutionClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.admin.LiteralMapBlob.encode(message.outputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.computedInputs != null && message.hasOwnProperty("computedInputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.computedInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.phase);
                    if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                        $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                        $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.notifications != null && message.notifications.length)
                        for (var i = 0; i < message.notifications.length; ++i)
                            $root.nebulaidl.admin.Notification.encode(message.notifications[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.abortCause != null && message.hasOwnProperty("abortCause"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.abortCause);
                    if (message.workflowId != null && message.hasOwnProperty("workflowId"))
                        $root.nebulaidl.core.Identifier.encode(message.workflowId, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.abortMetadata != null && message.hasOwnProperty("abortMetadata"))
                        $root.nebulaidl.admin.AbortMetadata.encode(message.abortMetadata, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.outputData != null && message.hasOwnProperty("outputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputData, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.stateChangeDetails != null && message.hasOwnProperty("stateChangeDetails"))
                        $root.nebulaidl.admin.ExecutionStateChangeDetails.encode(message.stateChangeDetails, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionClosure} ExecutionClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputs = $root.nebulaidl.admin.LiteralMapBlob.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.error = $root.nebulaidl.core.ExecutionError.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.abortCause = reader.string();
                            break;
                        case 12:
                            message.abortMetadata = $root.nebulaidl.admin.AbortMetadata.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.outputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.computedInputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.phase = reader.int32();
                            break;
                        case 5:
                            message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.notifications && message.notifications.length))
                                message.notifications = [];
                            message.notifications.push($root.nebulaidl.admin.Notification.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            message.workflowId = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.stateChangeDetails = $root.nebulaidl.admin.ExecutionStateChangeDetails.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionClosure message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.admin.LiteralMapBlob.verify(message.outputs);
                            if (error)
                                return "outputs." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.ExecutionError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.abortCause != null && message.hasOwnProperty("abortCause")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        if (!$util.isString(message.abortCause))
                            return "abortCause: string expected";
                    }
                    if (message.abortMetadata != null && message.hasOwnProperty("abortMetadata")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.admin.AbortMetadata.verify(message.abortMetadata);
                            if (error)
                                return "abortMetadata." + error;
                        }
                    }
                    if (message.outputData != null && message.hasOwnProperty("outputData")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.outputData);
                            if (error)
                                return "outputData." + error;
                        }
                    }
                    if (message.computedInputs != null && message.hasOwnProperty("computedInputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.computedInputs);
                        if (error)
                            return "computedInputs." + error;
                    }
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                        if (error)
                            return "startedAt." + error;
                    }
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                        if (error)
                            return "updatedAt." + error;
                    }
                    if (message.notifications != null && message.hasOwnProperty("notifications")) {
                        if (!Array.isArray(message.notifications))
                            return "notifications: array expected";
                        for (var i = 0; i < message.notifications.length; ++i) {
                            var error = $root.nebulaidl.admin.Notification.verify(message.notifications[i]);
                            if (error)
                                return "notifications." + error;
                        }
                    }
                    if (message.workflowId != null && message.hasOwnProperty("workflowId")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.workflowId);
                        if (error)
                            return "workflowId." + error;
                    }
                    if (message.stateChangeDetails != null && message.hasOwnProperty("stateChangeDetails")) {
                        var error = $root.nebulaidl.admin.ExecutionStateChangeDetails.verify(message.stateChangeDetails);
                        if (error)
                            return "stateChangeDetails." + error;
                    }
                    return null;
                };
    
                return ExecutionClosure;
            })();
    
            admin.SystemMetadata = (function() {
    
                /**
                 * Properties of a SystemMetadata.
                 * @memberof nebulaidl.admin
                 * @interface ISystemMetadata
                 * @property {string|null} [executionCluster] SystemMetadata executionCluster
                 * @property {string|null} [namespace] SystemMetadata namespace
                 */
    
                /**
                 * Constructs a new SystemMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SystemMetadata.
                 * @implements ISystemMetadata
                 * @constructor
                 * @param {nebulaidl.admin.ISystemMetadata=} [properties] Properties to set
                 */
                function SystemMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SystemMetadata executionCluster.
                 * @member {string} executionCluster
                 * @memberof nebulaidl.admin.SystemMetadata
                 * @instance
                 */
                SystemMetadata.prototype.executionCluster = "";
    
                /**
                 * SystemMetadata namespace.
                 * @member {string} namespace
                 * @memberof nebulaidl.admin.SystemMetadata
                 * @instance
                 */
                SystemMetadata.prototype.namespace = "";
    
                /**
                 * Creates a new SystemMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SystemMetadata
                 * @static
                 * @param {nebulaidl.admin.ISystemMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SystemMetadata} SystemMetadata instance
                 */
                SystemMetadata.create = function create(properties) {
                    return new SystemMetadata(properties);
                };
    
                /**
                 * Encodes the specified SystemMetadata message. Does not implicitly {@link nebulaidl.admin.SystemMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SystemMetadata
                 * @static
                 * @param {nebulaidl.admin.ISystemMetadata} message SystemMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SystemMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.executionCluster != null && message.hasOwnProperty("executionCluster"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.executionCluster);
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                    return writer;
                };
    
                /**
                 * Decodes a SystemMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SystemMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SystemMetadata} SystemMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SystemMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SystemMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executionCluster = reader.string();
                            break;
                        case 2:
                            message.namespace = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SystemMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.SystemMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SystemMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.executionCluster != null && message.hasOwnProperty("executionCluster"))
                        if (!$util.isString(message.executionCluster))
                            return "executionCluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    return null;
                };
    
                return SystemMetadata;
            })();
    
            admin.ExecutionMetadata = (function() {
    
                /**
                 * Properties of an ExecutionMetadata.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionMetadata
                 * @property {nebulaidl.admin.ExecutionMetadata.ExecutionMode|null} [mode] ExecutionMetadata mode
                 * @property {string|null} [principal] ExecutionMetadata principal
                 * @property {number|null} [nesting] ExecutionMetadata nesting
                 * @property {google.protobuf.ITimestamp|null} [scheduledAt] ExecutionMetadata scheduledAt
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [parentNodeExecution] ExecutionMetadata parentNodeExecution
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [referenceExecution] ExecutionMetadata referenceExecution
                 * @property {nebulaidl.admin.ISystemMetadata|null} [systemMetadata] ExecutionMetadata systemMetadata
                 */
    
                /**
                 * Constructs a new ExecutionMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionMetadata.
                 * @implements IExecutionMetadata
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionMetadata=} [properties] Properties to set
                 */
                function ExecutionMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionMetadata mode.
                 * @member {nebulaidl.admin.ExecutionMetadata.ExecutionMode} mode
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.mode = 0;
    
                /**
                 * ExecutionMetadata principal.
                 * @member {string} principal
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.principal = "";
    
                /**
                 * ExecutionMetadata nesting.
                 * @member {number} nesting
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.nesting = 0;
    
                /**
                 * ExecutionMetadata scheduledAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} scheduledAt
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.scheduledAt = null;
    
                /**
                 * ExecutionMetadata parentNodeExecution.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} parentNodeExecution
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.parentNodeExecution = null;
    
                /**
                 * ExecutionMetadata referenceExecution.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} referenceExecution
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.referenceExecution = null;
    
                /**
                 * ExecutionMetadata systemMetadata.
                 * @member {nebulaidl.admin.ISystemMetadata|null|undefined} systemMetadata
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @instance
                 */
                ExecutionMetadata.prototype.systemMetadata = null;
    
                /**
                 * Creates a new ExecutionMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @static
                 * @param {nebulaidl.admin.IExecutionMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionMetadata} ExecutionMetadata instance
                 */
                ExecutionMetadata.create = function create(properties) {
                    return new ExecutionMetadata(properties);
                };
    
                /**
                 * Encodes the specified ExecutionMetadata message. Does not implicitly {@link nebulaidl.admin.ExecutionMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @static
                 * @param {nebulaidl.admin.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.principal);
                    if (message.nesting != null && message.hasOwnProperty("nesting"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.nesting);
                    if (message.scheduledAt != null && message.hasOwnProperty("scheduledAt"))
                        $root.google.protobuf.Timestamp.encode(message.scheduledAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.parentNodeExecution != null && message.hasOwnProperty("parentNodeExecution"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.parentNodeExecution, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.referenceExecution != null && message.hasOwnProperty("referenceExecution"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.referenceExecution, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.systemMetadata != null && message.hasOwnProperty("systemMetadata"))
                        $root.nebulaidl.admin.SystemMetadata.encode(message.systemMetadata, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionMetadata} ExecutionMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        case 2:
                            message.principal = reader.string();
                            break;
                        case 3:
                            message.nesting = reader.uint32();
                            break;
                        case 4:
                            message.scheduledAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.parentNodeExecution = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.referenceExecution = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.systemMetadata = $root.nebulaidl.admin.SystemMetadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        if (!$util.isString(message.principal))
                            return "principal: string expected";
                    if (message.nesting != null && message.hasOwnProperty("nesting"))
                        if (!$util.isInteger(message.nesting))
                            return "nesting: integer expected";
                    if (message.scheduledAt != null && message.hasOwnProperty("scheduledAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.scheduledAt);
                        if (error)
                            return "scheduledAt." + error;
                    }
                    if (message.parentNodeExecution != null && message.hasOwnProperty("parentNodeExecution")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.parentNodeExecution);
                        if (error)
                            return "parentNodeExecution." + error;
                    }
                    if (message.referenceExecution != null && message.hasOwnProperty("referenceExecution")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.referenceExecution);
                        if (error)
                            return "referenceExecution." + error;
                    }
                    if (message.systemMetadata != null && message.hasOwnProperty("systemMetadata")) {
                        var error = $root.nebulaidl.admin.SystemMetadata.verify(message.systemMetadata);
                        if (error)
                            return "systemMetadata." + error;
                    }
                    return null;
                };
    
                /**
                 * ExecutionMode enum.
                 * @name nebulaidl.admin.ExecutionMetadata.ExecutionMode
                 * @enum {string}
                 * @property {number} MANUAL=0 MANUAL value
                 * @property {number} SCHEDULED=1 SCHEDULED value
                 * @property {number} SYSTEM=2 SYSTEM value
                 * @property {number} RELAUNCH=3 RELAUNCH value
                 * @property {number} CHILD_WORKFLOW=4 CHILD_WORKFLOW value
                 * @property {number} RECOVERED=5 RECOVERED value
                 */
                ExecutionMetadata.ExecutionMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "MANUAL"] = 0;
                    values[valuesById[1] = "SCHEDULED"] = 1;
                    values[valuesById[2] = "SYSTEM"] = 2;
                    values[valuesById[3] = "RELAUNCH"] = 3;
                    values[valuesById[4] = "CHILD_WORKFLOW"] = 4;
                    values[valuesById[5] = "RECOVERED"] = 5;
                    return values;
                })();
    
                return ExecutionMetadata;
            })();
    
            admin.NotificationList = (function() {
    
                /**
                 * Properties of a NotificationList.
                 * @memberof nebulaidl.admin
                 * @interface INotificationList
                 * @property {Array.<nebulaidl.admin.INotification>|null} [notifications] NotificationList notifications
                 */
    
                /**
                 * Constructs a new NotificationList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NotificationList.
                 * @implements INotificationList
                 * @constructor
                 * @param {nebulaidl.admin.INotificationList=} [properties] Properties to set
                 */
                function NotificationList(properties) {
                    this.notifications = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NotificationList notifications.
                 * @member {Array.<nebulaidl.admin.INotification>} notifications
                 * @memberof nebulaidl.admin.NotificationList
                 * @instance
                 */
                NotificationList.prototype.notifications = $util.emptyArray;
    
                /**
                 * Creates a new NotificationList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NotificationList
                 * @static
                 * @param {nebulaidl.admin.INotificationList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NotificationList} NotificationList instance
                 */
                NotificationList.create = function create(properties) {
                    return new NotificationList(properties);
                };
    
                /**
                 * Encodes the specified NotificationList message. Does not implicitly {@link nebulaidl.admin.NotificationList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NotificationList
                 * @static
                 * @param {nebulaidl.admin.INotificationList} message NotificationList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotificationList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.notifications != null && message.notifications.length)
                        for (var i = 0; i < message.notifications.length; ++i)
                            $root.nebulaidl.admin.Notification.encode(message.notifications[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NotificationList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NotificationList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NotificationList} NotificationList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotificationList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NotificationList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.notifications && message.notifications.length))
                                message.notifications = [];
                            message.notifications.push($root.nebulaidl.admin.Notification.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NotificationList message.
                 * @function verify
                 * @memberof nebulaidl.admin.NotificationList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NotificationList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.notifications != null && message.hasOwnProperty("notifications")) {
                        if (!Array.isArray(message.notifications))
                            return "notifications: array expected";
                        for (var i = 0; i < message.notifications.length; ++i) {
                            var error = $root.nebulaidl.admin.Notification.verify(message.notifications[i]);
                            if (error)
                                return "notifications." + error;
                        }
                    }
                    return null;
                };
    
                return NotificationList;
            })();
    
            admin.ExecutionSpec = (function() {
    
                /**
                 * Properties of an ExecutionSpec.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionSpec
                 * @property {nebulaidl.core.IIdentifier|null} [launchPlan] ExecutionSpec launchPlan
                 * @property {nebulaidl.core.ILiteralMap|null} [inputs] ExecutionSpec inputs
                 * @property {nebulaidl.admin.IExecutionMetadata|null} [metadata] ExecutionSpec metadata
                 * @property {nebulaidl.admin.INotificationList|null} [notifications] ExecutionSpec notifications
                 * @property {boolean|null} [disableAll] ExecutionSpec disableAll
                 * @property {nebulaidl.admin.ILabels|null} [labels] ExecutionSpec labels
                 * @property {nebulaidl.admin.IAnnotations|null} [annotations] ExecutionSpec annotations
                 * @property {nebulaidl.core.ISecurityContext|null} [securityContext] ExecutionSpec securityContext
                 * @property {nebulaidl.admin.IAuthRole|null} [authRole] ExecutionSpec authRole
                 * @property {nebulaidl.core.IQualityOfService|null} [qualityOfService] ExecutionSpec qualityOfService
                 * @property {number|null} [maxParallelism] ExecutionSpec maxParallelism
                 * @property {nebulaidl.admin.IRawOutputDataConfig|null} [rawOutputDataConfig] ExecutionSpec rawOutputDataConfig
                 * @property {nebulaidl.admin.IClusterAssignment|null} [clusterAssignment] ExecutionSpec clusterAssignment
                 * @property {google.protobuf.IBoolValue|null} [interruptible] ExecutionSpec interruptible
                 * @property {boolean|null} [overwriteCache] ExecutionSpec overwriteCache
                 * @property {nebulaidl.admin.IEnvs|null} [envs] ExecutionSpec envs
                 * @property {Array.<string>|null} [tags] ExecutionSpec tags
                 */
    
                /**
                 * Constructs a new ExecutionSpec.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionSpec.
                 * @implements IExecutionSpec
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionSpec=} [properties] Properties to set
                 */
                function ExecutionSpec(properties) {
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionSpec launchPlan.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} launchPlan
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.launchPlan = null;
    
                /**
                 * ExecutionSpec inputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} inputs
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.inputs = null;
    
                /**
                 * ExecutionSpec metadata.
                 * @member {nebulaidl.admin.IExecutionMetadata|null|undefined} metadata
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.metadata = null;
    
                /**
                 * ExecutionSpec notifications.
                 * @member {nebulaidl.admin.INotificationList|null|undefined} notifications
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.notifications = null;
    
                /**
                 * ExecutionSpec disableAll.
                 * @member {boolean} disableAll
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.disableAll = false;
    
                /**
                 * ExecutionSpec labels.
                 * @member {nebulaidl.admin.ILabels|null|undefined} labels
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.labels = null;
    
                /**
                 * ExecutionSpec annotations.
                 * @member {nebulaidl.admin.IAnnotations|null|undefined} annotations
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.annotations = null;
    
                /**
                 * ExecutionSpec securityContext.
                 * @member {nebulaidl.core.ISecurityContext|null|undefined} securityContext
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.securityContext = null;
    
                /**
                 * ExecutionSpec authRole.
                 * @member {nebulaidl.admin.IAuthRole|null|undefined} authRole
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.authRole = null;
    
                /**
                 * ExecutionSpec qualityOfService.
                 * @member {nebulaidl.core.IQualityOfService|null|undefined} qualityOfService
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.qualityOfService = null;
    
                /**
                 * ExecutionSpec maxParallelism.
                 * @member {number} maxParallelism
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.maxParallelism = 0;
    
                /**
                 * ExecutionSpec rawOutputDataConfig.
                 * @member {nebulaidl.admin.IRawOutputDataConfig|null|undefined} rawOutputDataConfig
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.rawOutputDataConfig = null;
    
                /**
                 * ExecutionSpec clusterAssignment.
                 * @member {nebulaidl.admin.IClusterAssignment|null|undefined} clusterAssignment
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.clusterAssignment = null;
    
                /**
                 * ExecutionSpec interruptible.
                 * @member {google.protobuf.IBoolValue|null|undefined} interruptible
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.interruptible = null;
    
                /**
                 * ExecutionSpec overwriteCache.
                 * @member {boolean} overwriteCache
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.overwriteCache = false;
    
                /**
                 * ExecutionSpec envs.
                 * @member {nebulaidl.admin.IEnvs|null|undefined} envs
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.envs = null;
    
                /**
                 * ExecutionSpec tags.
                 * @member {Array.<string>} tags
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                ExecutionSpec.prototype.tags = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * ExecutionSpec notificationOverrides.
                 * @member {"notifications"|"disableAll"|undefined} notificationOverrides
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @instance
                 */
                Object.defineProperty(ExecutionSpec.prototype, "notificationOverrides", {
                    get: $util.oneOfGetter($oneOfFields = ["notifications", "disableAll"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new ExecutionSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @static
                 * @param {nebulaidl.admin.IExecutionSpec=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionSpec} ExecutionSpec instance
                 */
                ExecutionSpec.create = function create(properties) {
                    return new ExecutionSpec(properties);
                };
    
                /**
                 * Encodes the specified ExecutionSpec message. Does not implicitly {@link nebulaidl.admin.ExecutionSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @static
                 * @param {nebulaidl.admin.IExecutionSpec} message ExecutionSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.launchPlan != null && message.hasOwnProperty("launchPlan"))
                        $root.nebulaidl.core.Identifier.encode(message.launchPlan, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.inputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.admin.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.notifications != null && message.hasOwnProperty("notifications"))
                        $root.nebulaidl.admin.NotificationList.encode(message.notifications, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.disableAll != null && message.hasOwnProperty("disableAll"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disableAll);
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        $root.nebulaidl.admin.Labels.encode(message.labels, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.annotations != null && message.hasOwnProperty("annotations"))
                        $root.nebulaidl.admin.Annotations.encode(message.annotations, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.securityContext != null && message.hasOwnProperty("securityContext"))
                        $root.nebulaidl.core.SecurityContext.encode(message.securityContext, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.authRole != null && message.hasOwnProperty("authRole"))
                        $root.nebulaidl.admin.AuthRole.encode(message.authRole, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService"))
                        $root.nebulaidl.core.QualityOfService.encode(message.qualityOfService, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.maxParallelism != null && message.hasOwnProperty("maxParallelism"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.maxParallelism);
                    if (message.rawOutputDataConfig != null && message.hasOwnProperty("rawOutputDataConfig"))
                        $root.nebulaidl.admin.RawOutputDataConfig.encode(message.rawOutputDataConfig, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.clusterAssignment != null && message.hasOwnProperty("clusterAssignment"))
                        $root.nebulaidl.admin.ClusterAssignment.encode(message.clusterAssignment, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        $root.google.protobuf.BoolValue.encode(message.interruptible, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        writer.uint32(/* id 22, wireType 0 =*/176).bool(message.overwriteCache);
                    if (message.envs != null && message.hasOwnProperty("envs"))
                        $root.nebulaidl.admin.Envs.encode(message.envs, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 24, wireType 2 =*/194).string(message.tags[i]);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionSpec} ExecutionSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.launchPlan = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.inputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.metadata = $root.nebulaidl.admin.ExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.notifications = $root.nebulaidl.admin.NotificationList.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.disableAll = reader.bool();
                            break;
                        case 7:
                            message.labels = $root.nebulaidl.admin.Labels.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.annotations = $root.nebulaidl.admin.Annotations.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.securityContext = $root.nebulaidl.core.SecurityContext.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.authRole = $root.nebulaidl.admin.AuthRole.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.qualityOfService = $root.nebulaidl.core.QualityOfService.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.maxParallelism = reader.int32();
                            break;
                        case 19:
                            message.rawOutputDataConfig = $root.nebulaidl.admin.RawOutputDataConfig.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.clusterAssignment = $root.nebulaidl.admin.ClusterAssignment.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.interruptible = $root.google.protobuf.BoolValue.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.overwriteCache = reader.bool();
                            break;
                        case 23:
                            message.envs = $root.nebulaidl.admin.Envs.decode(reader, reader.uint32());
                            break;
                        case 24:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionSpec message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.launchPlan != null && message.hasOwnProperty("launchPlan")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.launchPlan);
                        if (error)
                            return "launchPlan." + error;
                    }
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.admin.ExecutionMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.notifications != null && message.hasOwnProperty("notifications")) {
                        properties.notificationOverrides = 1;
                        {
                            var error = $root.nebulaidl.admin.NotificationList.verify(message.notifications);
                            if (error)
                                return "notifications." + error;
                        }
                    }
                    if (message.disableAll != null && message.hasOwnProperty("disableAll")) {
                        if (properties.notificationOverrides === 1)
                            return "notificationOverrides: multiple values";
                        properties.notificationOverrides = 1;
                        if (typeof message.disableAll !== "boolean")
                            return "disableAll: boolean expected";
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        var error = $root.nebulaidl.admin.Labels.verify(message.labels);
                        if (error)
                            return "labels." + error;
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        var error = $root.nebulaidl.admin.Annotations.verify(message.annotations);
                        if (error)
                            return "annotations." + error;
                    }
                    if (message.securityContext != null && message.hasOwnProperty("securityContext")) {
                        var error = $root.nebulaidl.core.SecurityContext.verify(message.securityContext);
                        if (error)
                            return "securityContext." + error;
                    }
                    if (message.authRole != null && message.hasOwnProperty("authRole")) {
                        var error = $root.nebulaidl.admin.AuthRole.verify(message.authRole);
                        if (error)
                            return "authRole." + error;
                    }
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService")) {
                        var error = $root.nebulaidl.core.QualityOfService.verify(message.qualityOfService);
                        if (error)
                            return "qualityOfService." + error;
                    }
                    if (message.maxParallelism != null && message.hasOwnProperty("maxParallelism"))
                        if (!$util.isInteger(message.maxParallelism))
                            return "maxParallelism: integer expected";
                    if (message.rawOutputDataConfig != null && message.hasOwnProperty("rawOutputDataConfig")) {
                        var error = $root.nebulaidl.admin.RawOutputDataConfig.verify(message.rawOutputDataConfig);
                        if (error)
                            return "rawOutputDataConfig." + error;
                    }
                    if (message.clusterAssignment != null && message.hasOwnProperty("clusterAssignment")) {
                        var error = $root.nebulaidl.admin.ClusterAssignment.verify(message.clusterAssignment);
                        if (error)
                            return "clusterAssignment." + error;
                    }
                    if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                        var error = $root.google.protobuf.BoolValue.verify(message.interruptible);
                        if (error)
                            return "interruptible." + error;
                    }
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        if (typeof message.overwriteCache !== "boolean")
                            return "overwriteCache: boolean expected";
                    if (message.envs != null && message.hasOwnProperty("envs")) {
                        var error = $root.nebulaidl.admin.Envs.verify(message.envs);
                        if (error)
                            return "envs." + error;
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    return null;
                };
    
                return ExecutionSpec;
            })();
    
            admin.ExecutionTerminateRequest = (function() {
    
                /**
                 * Properties of an ExecutionTerminateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionTerminateRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionTerminateRequest id
                 * @property {string|null} [cause] ExecutionTerminateRequest cause
                 */
    
                /**
                 * Constructs a new ExecutionTerminateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionTerminateRequest.
                 * @implements IExecutionTerminateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionTerminateRequest=} [properties] Properties to set
                 */
                function ExecutionTerminateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionTerminateRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ExecutionTerminateRequest
                 * @instance
                 */
                ExecutionTerminateRequest.prototype.id = null;
    
                /**
                 * ExecutionTerminateRequest cause.
                 * @member {string} cause
                 * @memberof nebulaidl.admin.ExecutionTerminateRequest
                 * @instance
                 */
                ExecutionTerminateRequest.prototype.cause = "";
    
                /**
                 * Creates a new ExecutionTerminateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionTerminateRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionTerminateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionTerminateRequest} ExecutionTerminateRequest instance
                 */
                ExecutionTerminateRequest.create = function create(properties) {
                    return new ExecutionTerminateRequest(properties);
                };
    
                /**
                 * Encodes the specified ExecutionTerminateRequest message. Does not implicitly {@link nebulaidl.admin.ExecutionTerminateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionTerminateRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionTerminateRequest} message ExecutionTerminateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionTerminateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.cause != null && message.hasOwnProperty("cause"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.cause);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionTerminateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionTerminateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionTerminateRequest} ExecutionTerminateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionTerminateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionTerminateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.cause = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionTerminateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionTerminateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionTerminateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.cause != null && message.hasOwnProperty("cause"))
                        if (!$util.isString(message.cause))
                            return "cause: string expected";
                    return null;
                };
    
                return ExecutionTerminateRequest;
            })();
    
            admin.ExecutionTerminateResponse = (function() {
    
                /**
                 * Properties of an ExecutionTerminateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionTerminateResponse
                 */
    
                /**
                 * Constructs a new ExecutionTerminateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionTerminateResponse.
                 * @implements IExecutionTerminateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionTerminateResponse=} [properties] Properties to set
                 */
                function ExecutionTerminateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ExecutionTerminateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionTerminateResponse
                 * @static
                 * @param {nebulaidl.admin.IExecutionTerminateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionTerminateResponse} ExecutionTerminateResponse instance
                 */
                ExecutionTerminateResponse.create = function create(properties) {
                    return new ExecutionTerminateResponse(properties);
                };
    
                /**
                 * Encodes the specified ExecutionTerminateResponse message. Does not implicitly {@link nebulaidl.admin.ExecutionTerminateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionTerminateResponse
                 * @static
                 * @param {nebulaidl.admin.IExecutionTerminateResponse} message ExecutionTerminateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionTerminateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionTerminateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionTerminateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionTerminateResponse} ExecutionTerminateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionTerminateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionTerminateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionTerminateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionTerminateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionTerminateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ExecutionTerminateResponse;
            })();
    
            admin.WorkflowExecutionGetDataRequest = (function() {
    
                /**
                 * Properties of a WorkflowExecutionGetDataRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionGetDataRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] WorkflowExecutionGetDataRequest id
                 */
    
                /**
                 * Constructs a new WorkflowExecutionGetDataRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionGetDataRequest.
                 * @implements IWorkflowExecutionGetDataRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataRequest=} [properties] Properties to set
                 */
                function WorkflowExecutionGetDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionGetDataRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataRequest
                 * @instance
                 */
                WorkflowExecutionGetDataRequest.prototype.id = null;
    
                /**
                 * Creates a new WorkflowExecutionGetDataRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionGetDataRequest} WorkflowExecutionGetDataRequest instance
                 */
                WorkflowExecutionGetDataRequest.create = function create(properties) {
                    return new WorkflowExecutionGetDataRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionGetDataRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionGetDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataRequest} message WorkflowExecutionGetDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionGetDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionGetDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionGetDataRequest} WorkflowExecutionGetDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionGetDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionGetDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionGetDataRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionGetDataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return WorkflowExecutionGetDataRequest;
            })();
    
            admin.WorkflowExecutionGetDataResponse = (function() {
    
                /**
                 * Properties of a WorkflowExecutionGetDataResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionGetDataResponse
                 * @property {nebulaidl.admin.IUrlBlob|null} [outputs] WorkflowExecutionGetDataResponse outputs
                 * @property {nebulaidl.admin.IUrlBlob|null} [inputs] WorkflowExecutionGetDataResponse inputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fullInputs] WorkflowExecutionGetDataResponse fullInputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fullOutputs] WorkflowExecutionGetDataResponse fullOutputs
                 */
    
                /**
                 * Constructs a new WorkflowExecutionGetDataResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionGetDataResponse.
                 * @implements IWorkflowExecutionGetDataResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataResponse=} [properties] Properties to set
                 */
                function WorkflowExecutionGetDataResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionGetDataResponse outputs.
                 * @member {nebulaidl.admin.IUrlBlob|null|undefined} outputs
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @instance
                 */
                WorkflowExecutionGetDataResponse.prototype.outputs = null;
    
                /**
                 * WorkflowExecutionGetDataResponse inputs.
                 * @member {nebulaidl.admin.IUrlBlob|null|undefined} inputs
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @instance
                 */
                WorkflowExecutionGetDataResponse.prototype.inputs = null;
    
                /**
                 * WorkflowExecutionGetDataResponse fullInputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fullInputs
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @instance
                 */
                WorkflowExecutionGetDataResponse.prototype.fullInputs = null;
    
                /**
                 * WorkflowExecutionGetDataResponse fullOutputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fullOutputs
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @instance
                 */
                WorkflowExecutionGetDataResponse.prototype.fullOutputs = null;
    
                /**
                 * Creates a new WorkflowExecutionGetDataResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionGetDataResponse} WorkflowExecutionGetDataResponse instance
                 */
                WorkflowExecutionGetDataResponse.create = function create(properties) {
                    return new WorkflowExecutionGetDataResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionGetDataResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionGetDataResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataResponse} message WorkflowExecutionGetDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionGetDataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.admin.UrlBlob.encode(message.outputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.admin.UrlBlob.encode(message.inputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.fullInputs != null && message.hasOwnProperty("fullInputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fullInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fullOutputs != null && message.hasOwnProperty("fullOutputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fullOutputs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionGetDataResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionGetDataResponse} WorkflowExecutionGetDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionGetDataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionGetDataResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputs = $root.nebulaidl.admin.UrlBlob.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.inputs = $root.nebulaidl.admin.UrlBlob.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.fullInputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.fullOutputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionGetDataResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionGetDataResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionGetDataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        var error = $root.nebulaidl.admin.UrlBlob.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.admin.UrlBlob.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.fullInputs != null && message.hasOwnProperty("fullInputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fullInputs);
                        if (error)
                            return "fullInputs." + error;
                    }
                    if (message.fullOutputs != null && message.hasOwnProperty("fullOutputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fullOutputs);
                        if (error)
                            return "fullOutputs." + error;
                    }
                    return null;
                };
    
                return WorkflowExecutionGetDataResponse;
            })();
    
            /**
             * ExecutionState enum.
             * @name nebulaidl.admin.ExecutionState
             * @enum {string}
             * @property {number} EXECUTION_ACTIVE=0 EXECUTION_ACTIVE value
             * @property {number} EXECUTION_ARCHIVED=1 EXECUTION_ARCHIVED value
             */
            admin.ExecutionState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "EXECUTION_ACTIVE"] = 0;
                values[valuesById[1] = "EXECUTION_ARCHIVED"] = 1;
                return values;
            })();
    
            admin.ExecutionUpdateRequest = (function() {
    
                /**
                 * Properties of an ExecutionUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionUpdateRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] ExecutionUpdateRequest id
                 * @property {nebulaidl.admin.ExecutionState|null} [state] ExecutionUpdateRequest state
                 */
    
                /**
                 * Constructs a new ExecutionUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionUpdateRequest.
                 * @implements IExecutionUpdateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionUpdateRequest=} [properties] Properties to set
                 */
                function ExecutionUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionUpdateRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ExecutionUpdateRequest
                 * @instance
                 */
                ExecutionUpdateRequest.prototype.id = null;
    
                /**
                 * ExecutionUpdateRequest state.
                 * @member {nebulaidl.admin.ExecutionState} state
                 * @memberof nebulaidl.admin.ExecutionUpdateRequest
                 * @instance
                 */
                ExecutionUpdateRequest.prototype.state = 0;
    
                /**
                 * Creates a new ExecutionUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionUpdateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionUpdateRequest} ExecutionUpdateRequest instance
                 */
                ExecutionUpdateRequest.create = function create(properties) {
                    return new ExecutionUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified ExecutionUpdateRequest message. Does not implicitly {@link nebulaidl.admin.ExecutionUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IExecutionUpdateRequest} message ExecutionUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionUpdateRequest} ExecutionUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.state = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionUpdateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                return ExecutionUpdateRequest;
            })();
    
            admin.ExecutionStateChangeDetails = (function() {
    
                /**
                 * Properties of an ExecutionStateChangeDetails.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionStateChangeDetails
                 * @property {nebulaidl.admin.ExecutionState|null} [state] ExecutionStateChangeDetails state
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] ExecutionStateChangeDetails occurredAt
                 * @property {string|null} [principal] ExecutionStateChangeDetails principal
                 */
    
                /**
                 * Constructs a new ExecutionStateChangeDetails.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionStateChangeDetails.
                 * @implements IExecutionStateChangeDetails
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionStateChangeDetails=} [properties] Properties to set
                 */
                function ExecutionStateChangeDetails(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionStateChangeDetails state.
                 * @member {nebulaidl.admin.ExecutionState} state
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @instance
                 */
                ExecutionStateChangeDetails.prototype.state = 0;
    
                /**
                 * ExecutionStateChangeDetails occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @instance
                 */
                ExecutionStateChangeDetails.prototype.occurredAt = null;
    
                /**
                 * ExecutionStateChangeDetails principal.
                 * @member {string} principal
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @instance
                 */
                ExecutionStateChangeDetails.prototype.principal = "";
    
                /**
                 * Creates a new ExecutionStateChangeDetails instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @static
                 * @param {nebulaidl.admin.IExecutionStateChangeDetails=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionStateChangeDetails} ExecutionStateChangeDetails instance
                 */
                ExecutionStateChangeDetails.create = function create(properties) {
                    return new ExecutionStateChangeDetails(properties);
                };
    
                /**
                 * Encodes the specified ExecutionStateChangeDetails message. Does not implicitly {@link nebulaidl.admin.ExecutionStateChangeDetails.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @static
                 * @param {nebulaidl.admin.IExecutionStateChangeDetails} message ExecutionStateChangeDetails message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionStateChangeDetails.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.principal);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionStateChangeDetails message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionStateChangeDetails} ExecutionStateChangeDetails
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionStateChangeDetails.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionStateChangeDetails();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = reader.int32();
                            break;
                        case 2:
                            message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.principal = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionStateChangeDetails message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionStateChangeDetails
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionStateChangeDetails.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        if (!$util.isString(message.principal))
                            return "principal: string expected";
                    return null;
                };
    
                return ExecutionStateChangeDetails;
            })();
    
            admin.ExecutionUpdateResponse = (function() {
    
                /**
                 * Properties of an ExecutionUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionUpdateResponse
                 */
    
                /**
                 * Constructs a new ExecutionUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionUpdateResponse.
                 * @implements IExecutionUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionUpdateResponse=} [properties] Properties to set
                 */
                function ExecutionUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ExecutionUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IExecutionUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionUpdateResponse} ExecutionUpdateResponse instance
                 */
                ExecutionUpdateResponse.create = function create(properties) {
                    return new ExecutionUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified ExecutionUpdateResponse message. Does not implicitly {@link nebulaidl.admin.ExecutionUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IExecutionUpdateResponse} message ExecutionUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionUpdateResponse} ExecutionUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ExecutionUpdateResponse;
            })();
    
            admin.WorkflowExecutionGetMetricsRequest = (function() {
    
                /**
                 * Properties of a WorkflowExecutionGetMetricsRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionGetMetricsRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [id] WorkflowExecutionGetMetricsRequest id
                 * @property {number|null} [depth] WorkflowExecutionGetMetricsRequest depth
                 */
    
                /**
                 * Constructs a new WorkflowExecutionGetMetricsRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionGetMetricsRequest.
                 * @implements IWorkflowExecutionGetMetricsRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsRequest=} [properties] Properties to set
                 */
                function WorkflowExecutionGetMetricsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionGetMetricsRequest id.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsRequest
                 * @instance
                 */
                WorkflowExecutionGetMetricsRequest.prototype.id = null;
    
                /**
                 * WorkflowExecutionGetMetricsRequest depth.
                 * @member {number} depth
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsRequest
                 * @instance
                 */
                WorkflowExecutionGetMetricsRequest.prototype.depth = 0;
    
                /**
                 * Creates a new WorkflowExecutionGetMetricsRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionGetMetricsRequest} WorkflowExecutionGetMetricsRequest instance
                 */
                WorkflowExecutionGetMetricsRequest.create = function create(properties) {
                    return new WorkflowExecutionGetMetricsRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionGetMetricsRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionGetMetricsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsRequest} message WorkflowExecutionGetMetricsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionGetMetricsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.depth != null && message.hasOwnProperty("depth"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.depth);
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionGetMetricsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionGetMetricsRequest} WorkflowExecutionGetMetricsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionGetMetricsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionGetMetricsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.depth = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionGetMetricsRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionGetMetricsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.depth != null && message.hasOwnProperty("depth"))
                        if (!$util.isInteger(message.depth))
                            return "depth: integer expected";
                    return null;
                };
    
                return WorkflowExecutionGetMetricsRequest;
            })();
    
            admin.WorkflowExecutionGetMetricsResponse = (function() {
    
                /**
                 * Properties of a WorkflowExecutionGetMetricsResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionGetMetricsResponse
                 * @property {nebulaidl.core.ISpan|null} [span] WorkflowExecutionGetMetricsResponse span
                 */
    
                /**
                 * Constructs a new WorkflowExecutionGetMetricsResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionGetMetricsResponse.
                 * @implements IWorkflowExecutionGetMetricsResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsResponse=} [properties] Properties to set
                 */
                function WorkflowExecutionGetMetricsResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionGetMetricsResponse span.
                 * @member {nebulaidl.core.ISpan|null|undefined} span
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsResponse
                 * @instance
                 */
                WorkflowExecutionGetMetricsResponse.prototype.span = null;
    
                /**
                 * Creates a new WorkflowExecutionGetMetricsResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionGetMetricsResponse} WorkflowExecutionGetMetricsResponse instance
                 */
                WorkflowExecutionGetMetricsResponse.create = function create(properties) {
                    return new WorkflowExecutionGetMetricsResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionGetMetricsResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionGetMetricsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsResponse} message WorkflowExecutionGetMetricsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionGetMetricsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.span != null && message.hasOwnProperty("span"))
                        $root.nebulaidl.core.Span.encode(message.span, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionGetMetricsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionGetMetricsResponse} WorkflowExecutionGetMetricsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionGetMetricsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionGetMetricsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.span = $root.nebulaidl.core.Span.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionGetMetricsResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionGetMetricsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionGetMetricsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.span != null && message.hasOwnProperty("span")) {
                        var error = $root.nebulaidl.core.Span.verify(message.span);
                        if (error)
                            return "span." + error;
                    }
                    return null;
                };
    
                return WorkflowExecutionGetMetricsResponse;
            })();
    
            admin.LaunchPlanCreateRequest = (function() {
    
                /**
                 * Properties of a LaunchPlanCreateRequest.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanCreateRequest
                 * @property {nebulaidl.core.IIdentifier|null} [id] LaunchPlanCreateRequest id
                 * @property {nebulaidl.admin.ILaunchPlanSpec|null} [spec] LaunchPlanCreateRequest spec
                 */
    
                /**
                 * Constructs a new LaunchPlanCreateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanCreateRequest.
                 * @implements ILaunchPlanCreateRequest
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanCreateRequest=} [properties] Properties to set
                 */
                function LaunchPlanCreateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlanCreateRequest id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.LaunchPlanCreateRequest
                 * @instance
                 */
                LaunchPlanCreateRequest.prototype.id = null;
    
                /**
                 * LaunchPlanCreateRequest spec.
                 * @member {nebulaidl.admin.ILaunchPlanSpec|null|undefined} spec
                 * @memberof nebulaidl.admin.LaunchPlanCreateRequest
                 * @instance
                 */
                LaunchPlanCreateRequest.prototype.spec = null;
    
                /**
                 * Creates a new LaunchPlanCreateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanCreateRequest
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanCreateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanCreateRequest} LaunchPlanCreateRequest instance
                 */
                LaunchPlanCreateRequest.create = function create(properties) {
                    return new LaunchPlanCreateRequest(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanCreateRequest message. Does not implicitly {@link nebulaidl.admin.LaunchPlanCreateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanCreateRequest
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanCreateRequest} message LaunchPlanCreateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanCreateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.admin.LaunchPlanSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanCreateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanCreateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanCreateRequest} LaunchPlanCreateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanCreateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanCreateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.spec = $root.nebulaidl.admin.LaunchPlanSpec.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanCreateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanCreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanCreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.nebulaidl.admin.LaunchPlanSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    return null;
                };
    
                return LaunchPlanCreateRequest;
            })();
    
            admin.LaunchPlanCreateResponse = (function() {
    
                /**
                 * Properties of a LaunchPlanCreateResponse.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanCreateResponse
                 */
    
                /**
                 * Constructs a new LaunchPlanCreateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanCreateResponse.
                 * @implements ILaunchPlanCreateResponse
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanCreateResponse=} [properties] Properties to set
                 */
                function LaunchPlanCreateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new LaunchPlanCreateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanCreateResponse
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanCreateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanCreateResponse} LaunchPlanCreateResponse instance
                 */
                LaunchPlanCreateResponse.create = function create(properties) {
                    return new LaunchPlanCreateResponse(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanCreateResponse message. Does not implicitly {@link nebulaidl.admin.LaunchPlanCreateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanCreateResponse
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanCreateResponse} message LaunchPlanCreateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanCreateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanCreateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanCreateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanCreateResponse} LaunchPlanCreateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanCreateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanCreateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanCreateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanCreateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanCreateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return LaunchPlanCreateResponse;
            })();
    
            /**
             * LaunchPlanState enum.
             * @name nebulaidl.admin.LaunchPlanState
             * @enum {string}
             * @property {number} INACTIVE=0 INACTIVE value
             * @property {number} ACTIVE=1 ACTIVE value
             */
            admin.LaunchPlanState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INACTIVE"] = 0;
                values[valuesById[1] = "ACTIVE"] = 1;
                return values;
            })();
    
            admin.LaunchPlan = (function() {
    
                /**
                 * Properties of a LaunchPlan.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlan
                 * @property {nebulaidl.core.IIdentifier|null} [id] LaunchPlan id
                 * @property {nebulaidl.admin.ILaunchPlanSpec|null} [spec] LaunchPlan spec
                 * @property {nebulaidl.admin.ILaunchPlanClosure|null} [closure] LaunchPlan closure
                 */
    
                /**
                 * Constructs a new LaunchPlan.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlan.
                 * @implements ILaunchPlan
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlan=} [properties] Properties to set
                 */
                function LaunchPlan(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlan id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @instance
                 */
                LaunchPlan.prototype.id = null;
    
                /**
                 * LaunchPlan spec.
                 * @member {nebulaidl.admin.ILaunchPlanSpec|null|undefined} spec
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @instance
                 */
                LaunchPlan.prototype.spec = null;
    
                /**
                 * LaunchPlan closure.
                 * @member {nebulaidl.admin.ILaunchPlanClosure|null|undefined} closure
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @instance
                 */
                LaunchPlan.prototype.closure = null;
    
                /**
                 * Creates a new LaunchPlan instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlan=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlan} LaunchPlan instance
                 */
                LaunchPlan.create = function create(properties) {
                    return new LaunchPlan(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlan message. Does not implicitly {@link nebulaidl.admin.LaunchPlan.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlan} message LaunchPlan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlan.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.admin.LaunchPlanSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.closure != null && message.hasOwnProperty("closure"))
                        $root.nebulaidl.admin.LaunchPlanClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlan message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlan} LaunchPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlan.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlan();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.spec = $root.nebulaidl.admin.LaunchPlanSpec.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.closure = $root.nebulaidl.admin.LaunchPlanClosure.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlan message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlan
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlan.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.nebulaidl.admin.LaunchPlanSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    if (message.closure != null && message.hasOwnProperty("closure")) {
                        var error = $root.nebulaidl.admin.LaunchPlanClosure.verify(message.closure);
                        if (error)
                            return "closure." + error;
                    }
                    return null;
                };
    
                return LaunchPlan;
            })();
    
            admin.LaunchPlanList = (function() {
    
                /**
                 * Properties of a LaunchPlanList.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanList
                 * @property {Array.<nebulaidl.admin.ILaunchPlan>|null} [launchPlans] LaunchPlanList launchPlans
                 * @property {string|null} [token] LaunchPlanList token
                 */
    
                /**
                 * Constructs a new LaunchPlanList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanList.
                 * @implements ILaunchPlanList
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanList=} [properties] Properties to set
                 */
                function LaunchPlanList(properties) {
                    this.launchPlans = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlanList launchPlans.
                 * @member {Array.<nebulaidl.admin.ILaunchPlan>} launchPlans
                 * @memberof nebulaidl.admin.LaunchPlanList
                 * @instance
                 */
                LaunchPlanList.prototype.launchPlans = $util.emptyArray;
    
                /**
                 * LaunchPlanList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.LaunchPlanList
                 * @instance
                 */
                LaunchPlanList.prototype.token = "";
    
                /**
                 * Creates a new LaunchPlanList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanList
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanList} LaunchPlanList instance
                 */
                LaunchPlanList.create = function create(properties) {
                    return new LaunchPlanList(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanList message. Does not implicitly {@link nebulaidl.admin.LaunchPlanList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanList
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanList} message LaunchPlanList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.launchPlans != null && message.launchPlans.length)
                        for (var i = 0; i < message.launchPlans.length; ++i)
                            $root.nebulaidl.admin.LaunchPlan.encode(message.launchPlans[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanList} LaunchPlanList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.launchPlans && message.launchPlans.length))
                                message.launchPlans = [];
                            message.launchPlans.push($root.nebulaidl.admin.LaunchPlan.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanList message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.launchPlans != null && message.hasOwnProperty("launchPlans")) {
                        if (!Array.isArray(message.launchPlans))
                            return "launchPlans: array expected";
                        for (var i = 0; i < message.launchPlans.length; ++i) {
                            var error = $root.nebulaidl.admin.LaunchPlan.verify(message.launchPlans[i]);
                            if (error)
                                return "launchPlans." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return LaunchPlanList;
            })();
    
            admin.Auth = (function() {
    
                /**
                 * Properties of an Auth.
                 * @memberof nebulaidl.admin
                 * @interface IAuth
                 * @property {string|null} [assumableIamRole] Auth assumableIamRole
                 * @property {string|null} [kubernetesServiceAccount] Auth kubernetesServiceAccount
                 */
    
                /**
                 * Constructs a new Auth.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an Auth.
                 * @implements IAuth
                 * @constructor
                 * @param {nebulaidl.admin.IAuth=} [properties] Properties to set
                 */
                function Auth(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Auth assumableIamRole.
                 * @member {string} assumableIamRole
                 * @memberof nebulaidl.admin.Auth
                 * @instance
                 */
                Auth.prototype.assumableIamRole = "";
    
                /**
                 * Auth kubernetesServiceAccount.
                 * @member {string} kubernetesServiceAccount
                 * @memberof nebulaidl.admin.Auth
                 * @instance
                 */
                Auth.prototype.kubernetesServiceAccount = "";
    
                /**
                 * Creates a new Auth instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Auth
                 * @static
                 * @param {nebulaidl.admin.IAuth=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Auth} Auth instance
                 */
                Auth.create = function create(properties) {
                    return new Auth(properties);
                };
    
                /**
                 * Encodes the specified Auth message. Does not implicitly {@link nebulaidl.admin.Auth.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Auth
                 * @static
                 * @param {nebulaidl.admin.IAuth} message Auth message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Auth.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.assumableIamRole);
                    if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.kubernetesServiceAccount);
                    return writer;
                };
    
                /**
                 * Decodes an Auth message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Auth
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Auth} Auth
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Auth.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Auth();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.assumableIamRole = reader.string();
                            break;
                        case 2:
                            message.kubernetesServiceAccount = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Auth message.
                 * @function verify
                 * @memberof nebulaidl.admin.Auth
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Auth.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.assumableIamRole != null && message.hasOwnProperty("assumableIamRole"))
                        if (!$util.isString(message.assumableIamRole))
                            return "assumableIamRole: string expected";
                    if (message.kubernetesServiceAccount != null && message.hasOwnProperty("kubernetesServiceAccount"))
                        if (!$util.isString(message.kubernetesServiceAccount))
                            return "kubernetesServiceAccount: string expected";
                    return null;
                };
    
                return Auth;
            })();
    
            admin.LaunchPlanSpec = (function() {
    
                /**
                 * Properties of a LaunchPlanSpec.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanSpec
                 * @property {nebulaidl.core.IIdentifier|null} [workflowId] LaunchPlanSpec workflowId
                 * @property {nebulaidl.admin.ILaunchPlanMetadata|null} [entityMetadata] LaunchPlanSpec entityMetadata
                 * @property {nebulaidl.core.IParameterMap|null} [defaultInputs] LaunchPlanSpec defaultInputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fixedInputs] LaunchPlanSpec fixedInputs
                 * @property {string|null} [role] LaunchPlanSpec role
                 * @property {nebulaidl.admin.ILabels|null} [labels] LaunchPlanSpec labels
                 * @property {nebulaidl.admin.IAnnotations|null} [annotations] LaunchPlanSpec annotations
                 * @property {nebulaidl.admin.IAuth|null} [auth] LaunchPlanSpec auth
                 * @property {nebulaidl.admin.IAuthRole|null} [authRole] LaunchPlanSpec authRole
                 * @property {nebulaidl.core.ISecurityContext|null} [securityContext] LaunchPlanSpec securityContext
                 * @property {nebulaidl.core.IQualityOfService|null} [qualityOfService] LaunchPlanSpec qualityOfService
                 * @property {nebulaidl.admin.IRawOutputDataConfig|null} [rawOutputDataConfig] LaunchPlanSpec rawOutputDataConfig
                 * @property {number|null} [maxParallelism] LaunchPlanSpec maxParallelism
                 * @property {google.protobuf.IBoolValue|null} [interruptible] LaunchPlanSpec interruptible
                 * @property {boolean|null} [overwriteCache] LaunchPlanSpec overwriteCache
                 * @property {nebulaidl.admin.IEnvs|null} [envs] LaunchPlanSpec envs
                 */
    
                /**
                 * Constructs a new LaunchPlanSpec.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanSpec.
                 * @implements ILaunchPlanSpec
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanSpec=} [properties] Properties to set
                 */
                function LaunchPlanSpec(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlanSpec workflowId.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} workflowId
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.workflowId = null;
    
                /**
                 * LaunchPlanSpec entityMetadata.
                 * @member {nebulaidl.admin.ILaunchPlanMetadata|null|undefined} entityMetadata
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.entityMetadata = null;
    
                /**
                 * LaunchPlanSpec defaultInputs.
                 * @member {nebulaidl.core.IParameterMap|null|undefined} defaultInputs
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.defaultInputs = null;
    
                /**
                 * LaunchPlanSpec fixedInputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fixedInputs
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.fixedInputs = null;
    
                /**
                 * LaunchPlanSpec role.
                 * @member {string} role
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.role = "";
    
                /**
                 * LaunchPlanSpec labels.
                 * @member {nebulaidl.admin.ILabels|null|undefined} labels
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.labels = null;
    
                /**
                 * LaunchPlanSpec annotations.
                 * @member {nebulaidl.admin.IAnnotations|null|undefined} annotations
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.annotations = null;
    
                /**
                 * LaunchPlanSpec auth.
                 * @member {nebulaidl.admin.IAuth|null|undefined} auth
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.auth = null;
    
                /**
                 * LaunchPlanSpec authRole.
                 * @member {nebulaidl.admin.IAuthRole|null|undefined} authRole
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.authRole = null;
    
                /**
                 * LaunchPlanSpec securityContext.
                 * @member {nebulaidl.core.ISecurityContext|null|undefined} securityContext
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.securityContext = null;
    
                /**
                 * LaunchPlanSpec qualityOfService.
                 * @member {nebulaidl.core.IQualityOfService|null|undefined} qualityOfService
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.qualityOfService = null;
    
                /**
                 * LaunchPlanSpec rawOutputDataConfig.
                 * @member {nebulaidl.admin.IRawOutputDataConfig|null|undefined} rawOutputDataConfig
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.rawOutputDataConfig = null;
    
                /**
                 * LaunchPlanSpec maxParallelism.
                 * @member {number} maxParallelism
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.maxParallelism = 0;
    
                /**
                 * LaunchPlanSpec interruptible.
                 * @member {google.protobuf.IBoolValue|null|undefined} interruptible
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.interruptible = null;
    
                /**
                 * LaunchPlanSpec overwriteCache.
                 * @member {boolean} overwriteCache
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.overwriteCache = false;
    
                /**
                 * LaunchPlanSpec envs.
                 * @member {nebulaidl.admin.IEnvs|null|undefined} envs
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @instance
                 */
                LaunchPlanSpec.prototype.envs = null;
    
                /**
                 * Creates a new LaunchPlanSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanSpec=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanSpec} LaunchPlanSpec instance
                 */
                LaunchPlanSpec.create = function create(properties) {
                    return new LaunchPlanSpec(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanSpec message. Does not implicitly {@link nebulaidl.admin.LaunchPlanSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanSpec} message LaunchPlanSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.workflowId != null && message.hasOwnProperty("workflowId"))
                        $root.nebulaidl.core.Identifier.encode(message.workflowId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.entityMetadata != null && message.hasOwnProperty("entityMetadata"))
                        $root.nebulaidl.admin.LaunchPlanMetadata.encode(message.entityMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.defaultInputs != null && message.hasOwnProperty("defaultInputs"))
                        $root.nebulaidl.core.ParameterMap.encode(message.defaultInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fixedInputs != null && message.hasOwnProperty("fixedInputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fixedInputs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.role != null && message.hasOwnProperty("role"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.role);
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        $root.nebulaidl.admin.Labels.encode(message.labels, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.annotations != null && message.hasOwnProperty("annotations"))
                        $root.nebulaidl.admin.Annotations.encode(message.annotations, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.auth != null && message.hasOwnProperty("auth"))
                        $root.nebulaidl.admin.Auth.encode(message.auth, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.authRole != null && message.hasOwnProperty("authRole"))
                        $root.nebulaidl.admin.AuthRole.encode(message.authRole, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.securityContext != null && message.hasOwnProperty("securityContext"))
                        $root.nebulaidl.core.SecurityContext.encode(message.securityContext, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService"))
                        $root.nebulaidl.core.QualityOfService.encode(message.qualityOfService, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.rawOutputDataConfig != null && message.hasOwnProperty("rawOutputDataConfig"))
                        $root.nebulaidl.admin.RawOutputDataConfig.encode(message.rawOutputDataConfig, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.maxParallelism != null && message.hasOwnProperty("maxParallelism"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.maxParallelism);
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        $root.google.protobuf.BoolValue.encode(message.interruptible, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.overwriteCache);
                    if (message.envs != null && message.hasOwnProperty("envs"))
                        $root.nebulaidl.admin.Envs.encode(message.envs, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanSpec} LaunchPlanSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.workflowId = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.entityMetadata = $root.nebulaidl.admin.LaunchPlanMetadata.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.defaultInputs = $root.nebulaidl.core.ParameterMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.fixedInputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.role = reader.string();
                            break;
                        case 6:
                            message.labels = $root.nebulaidl.admin.Labels.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.annotations = $root.nebulaidl.admin.Annotations.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.auth = $root.nebulaidl.admin.Auth.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.authRole = $root.nebulaidl.admin.AuthRole.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.securityContext = $root.nebulaidl.core.SecurityContext.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.qualityOfService = $root.nebulaidl.core.QualityOfService.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.rawOutputDataConfig = $root.nebulaidl.admin.RawOutputDataConfig.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.maxParallelism = reader.int32();
                            break;
                        case 19:
                            message.interruptible = $root.google.protobuf.BoolValue.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.overwriteCache = reader.bool();
                            break;
                        case 21:
                            message.envs = $root.nebulaidl.admin.Envs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanSpec message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.workflowId != null && message.hasOwnProperty("workflowId")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.workflowId);
                        if (error)
                            return "workflowId." + error;
                    }
                    if (message.entityMetadata != null && message.hasOwnProperty("entityMetadata")) {
                        var error = $root.nebulaidl.admin.LaunchPlanMetadata.verify(message.entityMetadata);
                        if (error)
                            return "entityMetadata." + error;
                    }
                    if (message.defaultInputs != null && message.hasOwnProperty("defaultInputs")) {
                        var error = $root.nebulaidl.core.ParameterMap.verify(message.defaultInputs);
                        if (error)
                            return "defaultInputs." + error;
                    }
                    if (message.fixedInputs != null && message.hasOwnProperty("fixedInputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fixedInputs);
                        if (error)
                            return "fixedInputs." + error;
                    }
                    if (message.role != null && message.hasOwnProperty("role"))
                        if (!$util.isString(message.role))
                            return "role: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        var error = $root.nebulaidl.admin.Labels.verify(message.labels);
                        if (error)
                            return "labels." + error;
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        var error = $root.nebulaidl.admin.Annotations.verify(message.annotations);
                        if (error)
                            return "annotations." + error;
                    }
                    if (message.auth != null && message.hasOwnProperty("auth")) {
                        var error = $root.nebulaidl.admin.Auth.verify(message.auth);
                        if (error)
                            return "auth." + error;
                    }
                    if (message.authRole != null && message.hasOwnProperty("authRole")) {
                        var error = $root.nebulaidl.admin.AuthRole.verify(message.authRole);
                        if (error)
                            return "authRole." + error;
                    }
                    if (message.securityContext != null && message.hasOwnProperty("securityContext")) {
                        var error = $root.nebulaidl.core.SecurityContext.verify(message.securityContext);
                        if (error)
                            return "securityContext." + error;
                    }
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService")) {
                        var error = $root.nebulaidl.core.QualityOfService.verify(message.qualityOfService);
                        if (error)
                            return "qualityOfService." + error;
                    }
                    if (message.rawOutputDataConfig != null && message.hasOwnProperty("rawOutputDataConfig")) {
                        var error = $root.nebulaidl.admin.RawOutputDataConfig.verify(message.rawOutputDataConfig);
                        if (error)
                            return "rawOutputDataConfig." + error;
                    }
                    if (message.maxParallelism != null && message.hasOwnProperty("maxParallelism"))
                        if (!$util.isInteger(message.maxParallelism))
                            return "maxParallelism: integer expected";
                    if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                        var error = $root.google.protobuf.BoolValue.verify(message.interruptible);
                        if (error)
                            return "interruptible." + error;
                    }
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        if (typeof message.overwriteCache !== "boolean")
                            return "overwriteCache: boolean expected";
                    if (message.envs != null && message.hasOwnProperty("envs")) {
                        var error = $root.nebulaidl.admin.Envs.verify(message.envs);
                        if (error)
                            return "envs." + error;
                    }
                    return null;
                };
    
                return LaunchPlanSpec;
            })();
    
            admin.LaunchPlanClosure = (function() {
    
                /**
                 * Properties of a LaunchPlanClosure.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanClosure
                 * @property {nebulaidl.admin.LaunchPlanState|null} [state] LaunchPlanClosure state
                 * @property {nebulaidl.core.IParameterMap|null} [expectedInputs] LaunchPlanClosure expectedInputs
                 * @property {nebulaidl.core.IVariableMap|null} [expectedOutputs] LaunchPlanClosure expectedOutputs
                 * @property {google.protobuf.ITimestamp|null} [createdAt] LaunchPlanClosure createdAt
                 * @property {google.protobuf.ITimestamp|null} [updatedAt] LaunchPlanClosure updatedAt
                 */
    
                /**
                 * Constructs a new LaunchPlanClosure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanClosure.
                 * @implements ILaunchPlanClosure
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanClosure=} [properties] Properties to set
                 */
                function LaunchPlanClosure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlanClosure state.
                 * @member {nebulaidl.admin.LaunchPlanState} state
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @instance
                 */
                LaunchPlanClosure.prototype.state = 0;
    
                /**
                 * LaunchPlanClosure expectedInputs.
                 * @member {nebulaidl.core.IParameterMap|null|undefined} expectedInputs
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @instance
                 */
                LaunchPlanClosure.prototype.expectedInputs = null;
    
                /**
                 * LaunchPlanClosure expectedOutputs.
                 * @member {nebulaidl.core.IVariableMap|null|undefined} expectedOutputs
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @instance
                 */
                LaunchPlanClosure.prototype.expectedOutputs = null;
    
                /**
                 * LaunchPlanClosure createdAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} createdAt
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @instance
                 */
                LaunchPlanClosure.prototype.createdAt = null;
    
                /**
                 * LaunchPlanClosure updatedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @instance
                 */
                LaunchPlanClosure.prototype.updatedAt = null;
    
                /**
                 * Creates a new LaunchPlanClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanClosure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanClosure} LaunchPlanClosure instance
                 */
                LaunchPlanClosure.create = function create(properties) {
                    return new LaunchPlanClosure(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanClosure message. Does not implicitly {@link nebulaidl.admin.LaunchPlanClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanClosure} message LaunchPlanClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.expectedInputs != null && message.hasOwnProperty("expectedInputs"))
                        $root.nebulaidl.core.ParameterMap.encode(message.expectedInputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.expectedOutputs != null && message.hasOwnProperty("expectedOutputs"))
                        $root.nebulaidl.core.VariableMap.encode(message.expectedOutputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                        $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanClosure} LaunchPlanClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = reader.int32();
                            break;
                        case 2:
                            message.expectedInputs = $root.nebulaidl.core.ParameterMap.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.expectedOutputs = $root.nebulaidl.core.VariableMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanClosure message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.expectedInputs != null && message.hasOwnProperty("expectedInputs")) {
                        var error = $root.nebulaidl.core.ParameterMap.verify(message.expectedInputs);
                        if (error)
                            return "expectedInputs." + error;
                    }
                    if (message.expectedOutputs != null && message.hasOwnProperty("expectedOutputs")) {
                        var error = $root.nebulaidl.core.VariableMap.verify(message.expectedOutputs);
                        if (error)
                            return "expectedOutputs." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                        if (error)
                            return "updatedAt." + error;
                    }
                    return null;
                };
    
                return LaunchPlanClosure;
            })();
    
            admin.LaunchPlanMetadata = (function() {
    
                /**
                 * Properties of a LaunchPlanMetadata.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanMetadata
                 * @property {nebulaidl.admin.ISchedule|null} [schedule] LaunchPlanMetadata schedule
                 * @property {Array.<nebulaidl.admin.INotification>|null} [notifications] LaunchPlanMetadata notifications
                 */
    
                /**
                 * Constructs a new LaunchPlanMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanMetadata.
                 * @implements ILaunchPlanMetadata
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanMetadata=} [properties] Properties to set
                 */
                function LaunchPlanMetadata(properties) {
                    this.notifications = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlanMetadata schedule.
                 * @member {nebulaidl.admin.ISchedule|null|undefined} schedule
                 * @memberof nebulaidl.admin.LaunchPlanMetadata
                 * @instance
                 */
                LaunchPlanMetadata.prototype.schedule = null;
    
                /**
                 * LaunchPlanMetadata notifications.
                 * @member {Array.<nebulaidl.admin.INotification>} notifications
                 * @memberof nebulaidl.admin.LaunchPlanMetadata
                 * @instance
                 */
                LaunchPlanMetadata.prototype.notifications = $util.emptyArray;
    
                /**
                 * Creates a new LaunchPlanMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanMetadata
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanMetadata} LaunchPlanMetadata instance
                 */
                LaunchPlanMetadata.create = function create(properties) {
                    return new LaunchPlanMetadata(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanMetadata message. Does not implicitly {@link nebulaidl.admin.LaunchPlanMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanMetadata
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanMetadata} message LaunchPlanMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.schedule != null && message.hasOwnProperty("schedule"))
                        $root.nebulaidl.admin.Schedule.encode(message.schedule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.notifications != null && message.notifications.length)
                        for (var i = 0; i < message.notifications.length; ++i)
                            $root.nebulaidl.admin.Notification.encode(message.notifications[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanMetadata} LaunchPlanMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.schedule = $root.nebulaidl.admin.Schedule.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.notifications && message.notifications.length))
                                message.notifications = [];
                            message.notifications.push($root.nebulaidl.admin.Notification.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.schedule != null && message.hasOwnProperty("schedule")) {
                        var error = $root.nebulaidl.admin.Schedule.verify(message.schedule);
                        if (error)
                            return "schedule." + error;
                    }
                    if (message.notifications != null && message.hasOwnProperty("notifications")) {
                        if (!Array.isArray(message.notifications))
                            return "notifications: array expected";
                        for (var i = 0; i < message.notifications.length; ++i) {
                            var error = $root.nebulaidl.admin.Notification.verify(message.notifications[i]);
                            if (error)
                                return "notifications." + error;
                        }
                    }
                    return null;
                };
    
                return LaunchPlanMetadata;
            })();
    
            admin.LaunchPlanUpdateRequest = (function() {
    
                /**
                 * Properties of a LaunchPlanUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanUpdateRequest
                 * @property {nebulaidl.core.IIdentifier|null} [id] LaunchPlanUpdateRequest id
                 * @property {nebulaidl.admin.LaunchPlanState|null} [state] LaunchPlanUpdateRequest state
                 */
    
                /**
                 * Constructs a new LaunchPlanUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanUpdateRequest.
                 * @implements ILaunchPlanUpdateRequest
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanUpdateRequest=} [properties] Properties to set
                 */
                function LaunchPlanUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LaunchPlanUpdateRequest id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.LaunchPlanUpdateRequest
                 * @instance
                 */
                LaunchPlanUpdateRequest.prototype.id = null;
    
                /**
                 * LaunchPlanUpdateRequest state.
                 * @member {nebulaidl.admin.LaunchPlanState} state
                 * @memberof nebulaidl.admin.LaunchPlanUpdateRequest
                 * @instance
                 */
                LaunchPlanUpdateRequest.prototype.state = 0;
    
                /**
                 * Creates a new LaunchPlanUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanUpdateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanUpdateRequest} LaunchPlanUpdateRequest instance
                 */
                LaunchPlanUpdateRequest.create = function create(properties) {
                    return new LaunchPlanUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanUpdateRequest message. Does not implicitly {@link nebulaidl.admin.LaunchPlanUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanUpdateRequest} message LaunchPlanUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanUpdateRequest} LaunchPlanUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.state = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanUpdateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                return LaunchPlanUpdateRequest;
            })();
    
            admin.LaunchPlanUpdateResponse = (function() {
    
                /**
                 * Properties of a LaunchPlanUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface ILaunchPlanUpdateResponse
                 */
    
                /**
                 * Constructs a new LaunchPlanUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a LaunchPlanUpdateResponse.
                 * @implements ILaunchPlanUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.ILaunchPlanUpdateResponse=} [properties] Properties to set
                 */
                function LaunchPlanUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new LaunchPlanUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.LaunchPlanUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.LaunchPlanUpdateResponse} LaunchPlanUpdateResponse instance
                 */
                LaunchPlanUpdateResponse.create = function create(properties) {
                    return new LaunchPlanUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified LaunchPlanUpdateResponse message. Does not implicitly {@link nebulaidl.admin.LaunchPlanUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.LaunchPlanUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.ILaunchPlanUpdateResponse} message LaunchPlanUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchPlanUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a LaunchPlanUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.LaunchPlanUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.LaunchPlanUpdateResponse} LaunchPlanUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchPlanUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.LaunchPlanUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a LaunchPlanUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.LaunchPlanUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchPlanUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return LaunchPlanUpdateResponse;
            })();
    
            admin.ActiveLaunchPlanRequest = (function() {
    
                /**
                 * Properties of an ActiveLaunchPlanRequest.
                 * @memberof nebulaidl.admin
                 * @interface IActiveLaunchPlanRequest
                 * @property {nebulaidl.admin.INamedEntityIdentifier|null} [id] ActiveLaunchPlanRequest id
                 */
    
                /**
                 * Constructs a new ActiveLaunchPlanRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ActiveLaunchPlanRequest.
                 * @implements IActiveLaunchPlanRequest
                 * @constructor
                 * @param {nebulaidl.admin.IActiveLaunchPlanRequest=} [properties] Properties to set
                 */
                function ActiveLaunchPlanRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActiveLaunchPlanRequest id.
                 * @member {nebulaidl.admin.INamedEntityIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.ActiveLaunchPlanRequest
                 * @instance
                 */
                ActiveLaunchPlanRequest.prototype.id = null;
    
                /**
                 * Creates a new ActiveLaunchPlanRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ActiveLaunchPlanRequest
                 * @static
                 * @param {nebulaidl.admin.IActiveLaunchPlanRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ActiveLaunchPlanRequest} ActiveLaunchPlanRequest instance
                 */
                ActiveLaunchPlanRequest.create = function create(properties) {
                    return new ActiveLaunchPlanRequest(properties);
                };
    
                /**
                 * Encodes the specified ActiveLaunchPlanRequest message. Does not implicitly {@link nebulaidl.admin.ActiveLaunchPlanRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ActiveLaunchPlanRequest
                 * @static
                 * @param {nebulaidl.admin.IActiveLaunchPlanRequest} message ActiveLaunchPlanRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActiveLaunchPlanRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.admin.NamedEntityIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ActiveLaunchPlanRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ActiveLaunchPlanRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ActiveLaunchPlanRequest} ActiveLaunchPlanRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActiveLaunchPlanRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ActiveLaunchPlanRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.admin.NamedEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ActiveLaunchPlanRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ActiveLaunchPlanRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActiveLaunchPlanRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.admin.NamedEntityIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return ActiveLaunchPlanRequest;
            })();
    
            admin.ActiveLaunchPlanListRequest = (function() {
    
                /**
                 * Properties of an ActiveLaunchPlanListRequest.
                 * @memberof nebulaidl.admin
                 * @interface IActiveLaunchPlanListRequest
                 * @property {string|null} [project] ActiveLaunchPlanListRequest project
                 * @property {string|null} [domain] ActiveLaunchPlanListRequest domain
                 * @property {number|null} [limit] ActiveLaunchPlanListRequest limit
                 * @property {string|null} [token] ActiveLaunchPlanListRequest token
                 * @property {nebulaidl.admin.ISort|null} [sortBy] ActiveLaunchPlanListRequest sortBy
                 */
    
                /**
                 * Constructs a new ActiveLaunchPlanListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ActiveLaunchPlanListRequest.
                 * @implements IActiveLaunchPlanListRequest
                 * @constructor
                 * @param {nebulaidl.admin.IActiveLaunchPlanListRequest=} [properties] Properties to set
                 */
                function ActiveLaunchPlanListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActiveLaunchPlanListRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @instance
                 */
                ActiveLaunchPlanListRequest.prototype.project = "";
    
                /**
                 * ActiveLaunchPlanListRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @instance
                 */
                ActiveLaunchPlanListRequest.prototype.domain = "";
    
                /**
                 * ActiveLaunchPlanListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @instance
                 */
                ActiveLaunchPlanListRequest.prototype.limit = 0;
    
                /**
                 * ActiveLaunchPlanListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @instance
                 */
                ActiveLaunchPlanListRequest.prototype.token = "";
    
                /**
                 * ActiveLaunchPlanListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @instance
                 */
                ActiveLaunchPlanListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new ActiveLaunchPlanListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @static
                 * @param {nebulaidl.admin.IActiveLaunchPlanListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ActiveLaunchPlanListRequest} ActiveLaunchPlanListRequest instance
                 */
                ActiveLaunchPlanListRequest.create = function create(properties) {
                    return new ActiveLaunchPlanListRequest(properties);
                };
    
                /**
                 * Encodes the specified ActiveLaunchPlanListRequest message. Does not implicitly {@link nebulaidl.admin.ActiveLaunchPlanListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @static
                 * @param {nebulaidl.admin.IActiveLaunchPlanListRequest} message ActiveLaunchPlanListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActiveLaunchPlanListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.token);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an ActiveLaunchPlanListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ActiveLaunchPlanListRequest} ActiveLaunchPlanListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActiveLaunchPlanListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ActiveLaunchPlanListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.limit = reader.uint32();
                            break;
                        case 4:
                            message.token = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ActiveLaunchPlanListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ActiveLaunchPlanListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActiveLaunchPlanListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return ActiveLaunchPlanListRequest;
            })();
    
            /**
             * FixedRateUnit enum.
             * @name nebulaidl.admin.FixedRateUnit
             * @enum {string}
             * @property {number} MINUTE=0 MINUTE value
             * @property {number} HOUR=1 HOUR value
             * @property {number} DAY=2 DAY value
             */
            admin.FixedRateUnit = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MINUTE"] = 0;
                values[valuesById[1] = "HOUR"] = 1;
                values[valuesById[2] = "DAY"] = 2;
                return values;
            })();
    
            admin.FixedRate = (function() {
    
                /**
                 * Properties of a FixedRate.
                 * @memberof nebulaidl.admin
                 * @interface IFixedRate
                 * @property {number|null} [value] FixedRate value
                 * @property {nebulaidl.admin.FixedRateUnit|null} [unit] FixedRate unit
                 */
    
                /**
                 * Constructs a new FixedRate.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a FixedRate.
                 * @implements IFixedRate
                 * @constructor
                 * @param {nebulaidl.admin.IFixedRate=} [properties] Properties to set
                 */
                function FixedRate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FixedRate value.
                 * @member {number} value
                 * @memberof nebulaidl.admin.FixedRate
                 * @instance
                 */
                FixedRate.prototype.value = 0;
    
                /**
                 * FixedRate unit.
                 * @member {nebulaidl.admin.FixedRateUnit} unit
                 * @memberof nebulaidl.admin.FixedRate
                 * @instance
                 */
                FixedRate.prototype.unit = 0;
    
                /**
                 * Creates a new FixedRate instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.FixedRate
                 * @static
                 * @param {nebulaidl.admin.IFixedRate=} [properties] Properties to set
                 * @returns {nebulaidl.admin.FixedRate} FixedRate instance
                 */
                FixedRate.create = function create(properties) {
                    return new FixedRate(properties);
                };
    
                /**
                 * Encodes the specified FixedRate message. Does not implicitly {@link nebulaidl.admin.FixedRate.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.FixedRate
                 * @static
                 * @param {nebulaidl.admin.IFixedRate} message FixedRate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FixedRate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                    if (message.unit != null && message.hasOwnProperty("unit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unit);
                    return writer;
                };
    
                /**
                 * Decodes a FixedRate message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.FixedRate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.FixedRate} FixedRate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FixedRate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.FixedRate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.uint32();
                            break;
                        case 2:
                            message.unit = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FixedRate message.
                 * @function verify
                 * @memberof nebulaidl.admin.FixedRate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FixedRate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value))
                            return "value: integer expected";
                    if (message.unit != null && message.hasOwnProperty("unit"))
                        switch (message.unit) {
                        default:
                            return "unit: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                return FixedRate;
            })();
    
            admin.CronSchedule = (function() {
    
                /**
                 * Properties of a CronSchedule.
                 * @memberof nebulaidl.admin
                 * @interface ICronSchedule
                 * @property {string|null} [schedule] CronSchedule schedule
                 * @property {string|null} [offset] CronSchedule offset
                 */
    
                /**
                 * Constructs a new CronSchedule.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a CronSchedule.
                 * @implements ICronSchedule
                 * @constructor
                 * @param {nebulaidl.admin.ICronSchedule=} [properties] Properties to set
                 */
                function CronSchedule(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CronSchedule schedule.
                 * @member {string} schedule
                 * @memberof nebulaidl.admin.CronSchedule
                 * @instance
                 */
                CronSchedule.prototype.schedule = "";
    
                /**
                 * CronSchedule offset.
                 * @member {string} offset
                 * @memberof nebulaidl.admin.CronSchedule
                 * @instance
                 */
                CronSchedule.prototype.offset = "";
    
                /**
                 * Creates a new CronSchedule instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.CronSchedule
                 * @static
                 * @param {nebulaidl.admin.ICronSchedule=} [properties] Properties to set
                 * @returns {nebulaidl.admin.CronSchedule} CronSchedule instance
                 */
                CronSchedule.create = function create(properties) {
                    return new CronSchedule(properties);
                };
    
                /**
                 * Encodes the specified CronSchedule message. Does not implicitly {@link nebulaidl.admin.CronSchedule.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.CronSchedule
                 * @static
                 * @param {nebulaidl.admin.ICronSchedule} message CronSchedule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CronSchedule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.schedule != null && message.hasOwnProperty("schedule"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.schedule);
                    if (message.offset != null && message.hasOwnProperty("offset"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
                    return writer;
                };
    
                /**
                 * Decodes a CronSchedule message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.CronSchedule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.CronSchedule} CronSchedule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CronSchedule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.CronSchedule();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.schedule = reader.string();
                            break;
                        case 2:
                            message.offset = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CronSchedule message.
                 * @function verify
                 * @memberof nebulaidl.admin.CronSchedule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CronSchedule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.schedule != null && message.hasOwnProperty("schedule"))
                        if (!$util.isString(message.schedule))
                            return "schedule: string expected";
                    if (message.offset != null && message.hasOwnProperty("offset"))
                        if (!$util.isString(message.offset))
                            return "offset: string expected";
                    return null;
                };
    
                return CronSchedule;
            })();
    
            admin.Schedule = (function() {
    
                /**
                 * Properties of a Schedule.
                 * @memberof nebulaidl.admin
                 * @interface ISchedule
                 * @property {string|null} [cronExpression] Schedule cronExpression
                 * @property {nebulaidl.admin.IFixedRate|null} [rate] Schedule rate
                 * @property {nebulaidl.admin.ICronSchedule|null} [cronSchedule] Schedule cronSchedule
                 * @property {string|null} [kickoffTimeInputArg] Schedule kickoffTimeInputArg
                 */
    
                /**
                 * Constructs a new Schedule.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Schedule.
                 * @implements ISchedule
                 * @constructor
                 * @param {nebulaidl.admin.ISchedule=} [properties] Properties to set
                 */
                function Schedule(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Schedule cronExpression.
                 * @member {string} cronExpression
                 * @memberof nebulaidl.admin.Schedule
                 * @instance
                 */
                Schedule.prototype.cronExpression = "";
    
                /**
                 * Schedule rate.
                 * @member {nebulaidl.admin.IFixedRate|null|undefined} rate
                 * @memberof nebulaidl.admin.Schedule
                 * @instance
                 */
                Schedule.prototype.rate = null;
    
                /**
                 * Schedule cronSchedule.
                 * @member {nebulaidl.admin.ICronSchedule|null|undefined} cronSchedule
                 * @memberof nebulaidl.admin.Schedule
                 * @instance
                 */
                Schedule.prototype.cronSchedule = null;
    
                /**
                 * Schedule kickoffTimeInputArg.
                 * @member {string} kickoffTimeInputArg
                 * @memberof nebulaidl.admin.Schedule
                 * @instance
                 */
                Schedule.prototype.kickoffTimeInputArg = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Schedule ScheduleExpression.
                 * @member {"cronExpression"|"rate"|"cronSchedule"|undefined} ScheduleExpression
                 * @memberof nebulaidl.admin.Schedule
                 * @instance
                 */
                Object.defineProperty(Schedule.prototype, "ScheduleExpression", {
                    get: $util.oneOfGetter($oneOfFields = ["cronExpression", "rate", "cronSchedule"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Schedule instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Schedule
                 * @static
                 * @param {nebulaidl.admin.ISchedule=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Schedule} Schedule instance
                 */
                Schedule.create = function create(properties) {
                    return new Schedule(properties);
                };
    
                /**
                 * Encodes the specified Schedule message. Does not implicitly {@link nebulaidl.admin.Schedule.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Schedule
                 * @static
                 * @param {nebulaidl.admin.ISchedule} message Schedule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Schedule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cronExpression != null && message.hasOwnProperty("cronExpression"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cronExpression);
                    if (message.rate != null && message.hasOwnProperty("rate"))
                        $root.nebulaidl.admin.FixedRate.encode(message.rate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.kickoffTimeInputArg != null && message.hasOwnProperty("kickoffTimeInputArg"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.kickoffTimeInputArg);
                    if (message.cronSchedule != null && message.hasOwnProperty("cronSchedule"))
                        $root.nebulaidl.admin.CronSchedule.encode(message.cronSchedule, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Schedule message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Schedule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Schedule} Schedule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Schedule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Schedule();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cronExpression = reader.string();
                            break;
                        case 2:
                            message.rate = $root.nebulaidl.admin.FixedRate.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.cronSchedule = $root.nebulaidl.admin.CronSchedule.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.kickoffTimeInputArg = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Schedule message.
                 * @function verify
                 * @memberof nebulaidl.admin.Schedule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Schedule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.cronExpression != null && message.hasOwnProperty("cronExpression")) {
                        properties.ScheduleExpression = 1;
                        if (!$util.isString(message.cronExpression))
                            return "cronExpression: string expected";
                    }
                    if (message.rate != null && message.hasOwnProperty("rate")) {
                        if (properties.ScheduleExpression === 1)
                            return "ScheduleExpression: multiple values";
                        properties.ScheduleExpression = 1;
                        {
                            var error = $root.nebulaidl.admin.FixedRate.verify(message.rate);
                            if (error)
                                return "rate." + error;
                        }
                    }
                    if (message.cronSchedule != null && message.hasOwnProperty("cronSchedule")) {
                        if (properties.ScheduleExpression === 1)
                            return "ScheduleExpression: multiple values";
                        properties.ScheduleExpression = 1;
                        {
                            var error = $root.nebulaidl.admin.CronSchedule.verify(message.cronSchedule);
                            if (error)
                                return "cronSchedule." + error;
                        }
                    }
                    if (message.kickoffTimeInputArg != null && message.hasOwnProperty("kickoffTimeInputArg"))
                        if (!$util.isString(message.kickoffTimeInputArg))
                            return "kickoffTimeInputArg: string expected";
                    return null;
                };
    
                return Schedule;
            })();
    
            /**
             * MatchableResource enum.
             * @name nebulaidl.admin.MatchableResource
             * @enum {string}
             * @property {number} TASK_RESOURCE=0 TASK_RESOURCE value
             * @property {number} CLUSTER_RESOURCE=1 CLUSTER_RESOURCE value
             * @property {number} EXECUTION_QUEUE=2 EXECUTION_QUEUE value
             * @property {number} EXECUTION_CLUSTER_LABEL=3 EXECUTION_CLUSTER_LABEL value
             * @property {number} QUALITY_OF_SERVICE_SPECIFICATION=4 QUALITY_OF_SERVICE_SPECIFICATION value
             * @property {number} PLUGIN_OVERRIDE=5 PLUGIN_OVERRIDE value
             * @property {number} WORKFLOW_EXECUTION_CONFIG=6 WORKFLOW_EXECUTION_CONFIG value
             * @property {number} CLUSTER_ASSIGNMENT=7 CLUSTER_ASSIGNMENT value
             */
            admin.MatchableResource = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TASK_RESOURCE"] = 0;
                values[valuesById[1] = "CLUSTER_RESOURCE"] = 1;
                values[valuesById[2] = "EXECUTION_QUEUE"] = 2;
                values[valuesById[3] = "EXECUTION_CLUSTER_LABEL"] = 3;
                values[valuesById[4] = "QUALITY_OF_SERVICE_SPECIFICATION"] = 4;
                values[valuesById[5] = "PLUGIN_OVERRIDE"] = 5;
                values[valuesById[6] = "WORKFLOW_EXECUTION_CONFIG"] = 6;
                values[valuesById[7] = "CLUSTER_ASSIGNMENT"] = 7;
                return values;
            })();
    
            admin.TaskResourceSpec = (function() {
    
                /**
                 * Properties of a TaskResourceSpec.
                 * @memberof nebulaidl.admin
                 * @interface ITaskResourceSpec
                 * @property {string|null} [cpu] TaskResourceSpec cpu
                 * @property {string|null} [gpu] TaskResourceSpec gpu
                 * @property {string|null} [memory] TaskResourceSpec memory
                 * @property {string|null} [storage] TaskResourceSpec storage
                 * @property {string|null} [ephemeralStorage] TaskResourceSpec ephemeralStorage
                 */
    
                /**
                 * Constructs a new TaskResourceSpec.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskResourceSpec.
                 * @implements ITaskResourceSpec
                 * @constructor
                 * @param {nebulaidl.admin.ITaskResourceSpec=} [properties] Properties to set
                 */
                function TaskResourceSpec(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskResourceSpec cpu.
                 * @member {string} cpu
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @instance
                 */
                TaskResourceSpec.prototype.cpu = "";
    
                /**
                 * TaskResourceSpec gpu.
                 * @member {string} gpu
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @instance
                 */
                TaskResourceSpec.prototype.gpu = "";
    
                /**
                 * TaskResourceSpec memory.
                 * @member {string} memory
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @instance
                 */
                TaskResourceSpec.prototype.memory = "";
    
                /**
                 * TaskResourceSpec storage.
                 * @member {string} storage
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @instance
                 */
                TaskResourceSpec.prototype.storage = "";
    
                /**
                 * TaskResourceSpec ephemeralStorage.
                 * @member {string} ephemeralStorage
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @instance
                 */
                TaskResourceSpec.prototype.ephemeralStorage = "";
    
                /**
                 * Creates a new TaskResourceSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @static
                 * @param {nebulaidl.admin.ITaskResourceSpec=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskResourceSpec} TaskResourceSpec instance
                 */
                TaskResourceSpec.create = function create(properties) {
                    return new TaskResourceSpec(properties);
                };
    
                /**
                 * Encodes the specified TaskResourceSpec message. Does not implicitly {@link nebulaidl.admin.TaskResourceSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @static
                 * @param {nebulaidl.admin.ITaskResourceSpec} message TaskResourceSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskResourceSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cpu != null && message.hasOwnProperty("cpu"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cpu);
                    if (message.gpu != null && message.hasOwnProperty("gpu"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.gpu);
                    if (message.memory != null && message.hasOwnProperty("memory"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.memory);
                    if (message.storage != null && message.hasOwnProperty("storage"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.storage);
                    if (message.ephemeralStorage != null && message.hasOwnProperty("ephemeralStorage"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.ephemeralStorage);
                    return writer;
                };
    
                /**
                 * Decodes a TaskResourceSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskResourceSpec} TaskResourceSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskResourceSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskResourceSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cpu = reader.string();
                            break;
                        case 2:
                            message.gpu = reader.string();
                            break;
                        case 3:
                            message.memory = reader.string();
                            break;
                        case 4:
                            message.storage = reader.string();
                            break;
                        case 5:
                            message.ephemeralStorage = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskResourceSpec message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskResourceSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskResourceSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cpu != null && message.hasOwnProperty("cpu"))
                        if (!$util.isString(message.cpu))
                            return "cpu: string expected";
                    if (message.gpu != null && message.hasOwnProperty("gpu"))
                        if (!$util.isString(message.gpu))
                            return "gpu: string expected";
                    if (message.memory != null && message.hasOwnProperty("memory"))
                        if (!$util.isString(message.memory))
                            return "memory: string expected";
                    if (message.storage != null && message.hasOwnProperty("storage"))
                        if (!$util.isString(message.storage))
                            return "storage: string expected";
                    if (message.ephemeralStorage != null && message.hasOwnProperty("ephemeralStorage"))
                        if (!$util.isString(message.ephemeralStorage))
                            return "ephemeralStorage: string expected";
                    return null;
                };
    
                return TaskResourceSpec;
            })();
    
            admin.TaskResourceAttributes = (function() {
    
                /**
                 * Properties of a TaskResourceAttributes.
                 * @memberof nebulaidl.admin
                 * @interface ITaskResourceAttributes
                 * @property {nebulaidl.admin.ITaskResourceSpec|null} [defaults] TaskResourceAttributes defaults
                 * @property {nebulaidl.admin.ITaskResourceSpec|null} [limits] TaskResourceAttributes limits
                 */
    
                /**
                 * Constructs a new TaskResourceAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskResourceAttributes.
                 * @implements ITaskResourceAttributes
                 * @constructor
                 * @param {nebulaidl.admin.ITaskResourceAttributes=} [properties] Properties to set
                 */
                function TaskResourceAttributes(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskResourceAttributes defaults.
                 * @member {nebulaidl.admin.ITaskResourceSpec|null|undefined} defaults
                 * @memberof nebulaidl.admin.TaskResourceAttributes
                 * @instance
                 */
                TaskResourceAttributes.prototype.defaults = null;
    
                /**
                 * TaskResourceAttributes limits.
                 * @member {nebulaidl.admin.ITaskResourceSpec|null|undefined} limits
                 * @memberof nebulaidl.admin.TaskResourceAttributes
                 * @instance
                 */
                TaskResourceAttributes.prototype.limits = null;
    
                /**
                 * Creates a new TaskResourceAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskResourceAttributes
                 * @static
                 * @param {nebulaidl.admin.ITaskResourceAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskResourceAttributes} TaskResourceAttributes instance
                 */
                TaskResourceAttributes.create = function create(properties) {
                    return new TaskResourceAttributes(properties);
                };
    
                /**
                 * Encodes the specified TaskResourceAttributes message. Does not implicitly {@link nebulaidl.admin.TaskResourceAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskResourceAttributes
                 * @static
                 * @param {nebulaidl.admin.ITaskResourceAttributes} message TaskResourceAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskResourceAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.defaults != null && message.hasOwnProperty("defaults"))
                        $root.nebulaidl.admin.TaskResourceSpec.encode(message.defaults, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limits != null && message.hasOwnProperty("limits"))
                        $root.nebulaidl.admin.TaskResourceSpec.encode(message.limits, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskResourceAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskResourceAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskResourceAttributes} TaskResourceAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskResourceAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskResourceAttributes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.defaults = $root.nebulaidl.admin.TaskResourceSpec.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.limits = $root.nebulaidl.admin.TaskResourceSpec.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskResourceAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskResourceAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskResourceAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.defaults != null && message.hasOwnProperty("defaults")) {
                        var error = $root.nebulaidl.admin.TaskResourceSpec.verify(message.defaults);
                        if (error)
                            return "defaults." + error;
                    }
                    if (message.limits != null && message.hasOwnProperty("limits")) {
                        var error = $root.nebulaidl.admin.TaskResourceSpec.verify(message.limits);
                        if (error)
                            return "limits." + error;
                    }
                    return null;
                };
    
                return TaskResourceAttributes;
            })();
    
            admin.ClusterResourceAttributes = (function() {
    
                /**
                 * Properties of a ClusterResourceAttributes.
                 * @memberof nebulaidl.admin
                 * @interface IClusterResourceAttributes
                 * @property {Object.<string,string>|null} [attributes] ClusterResourceAttributes attributes
                 */
    
                /**
                 * Constructs a new ClusterResourceAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ClusterResourceAttributes.
                 * @implements IClusterResourceAttributes
                 * @constructor
                 * @param {nebulaidl.admin.IClusterResourceAttributes=} [properties] Properties to set
                 */
                function ClusterResourceAttributes(properties) {
                    this.attributes = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClusterResourceAttributes attributes.
                 * @member {Object.<string,string>} attributes
                 * @memberof nebulaidl.admin.ClusterResourceAttributes
                 * @instance
                 */
                ClusterResourceAttributes.prototype.attributes = $util.emptyObject;
    
                /**
                 * Creates a new ClusterResourceAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ClusterResourceAttributes
                 * @static
                 * @param {nebulaidl.admin.IClusterResourceAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ClusterResourceAttributes} ClusterResourceAttributes instance
                 */
                ClusterResourceAttributes.create = function create(properties) {
                    return new ClusterResourceAttributes(properties);
                };
    
                /**
                 * Encodes the specified ClusterResourceAttributes message. Does not implicitly {@link nebulaidl.admin.ClusterResourceAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ClusterResourceAttributes
                 * @static
                 * @param {nebulaidl.admin.IClusterResourceAttributes} message ClusterResourceAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClusterResourceAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ClusterResourceAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ClusterResourceAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ClusterResourceAttributes} ClusterResourceAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClusterResourceAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ClusterResourceAttributes(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.attributes === $util.emptyObject)
                                message.attributes = {};
                            key = reader.string();
                            reader.pos++;
                            message.attributes[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ClusterResourceAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.ClusterResourceAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClusterResourceAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        if (!$util.isObject(message.attributes))
                            return "attributes: object expected";
                        var key = Object.keys(message.attributes);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.attributes[key[i]]))
                                return "attributes: string{k:string} expected";
                    }
                    return null;
                };
    
                return ClusterResourceAttributes;
            })();
    
            admin.ExecutionQueueAttributes = (function() {
    
                /**
                 * Properties of an ExecutionQueueAttributes.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionQueueAttributes
                 * @property {Array.<string>|null} [tags] ExecutionQueueAttributes tags
                 */
    
                /**
                 * Constructs a new ExecutionQueueAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionQueueAttributes.
                 * @implements IExecutionQueueAttributes
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionQueueAttributes=} [properties] Properties to set
                 */
                function ExecutionQueueAttributes(properties) {
                    this.tags = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionQueueAttributes tags.
                 * @member {Array.<string>} tags
                 * @memberof nebulaidl.admin.ExecutionQueueAttributes
                 * @instance
                 */
                ExecutionQueueAttributes.prototype.tags = $util.emptyArray;
    
                /**
                 * Creates a new ExecutionQueueAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionQueueAttributes
                 * @static
                 * @param {nebulaidl.admin.IExecutionQueueAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionQueueAttributes} ExecutionQueueAttributes instance
                 */
                ExecutionQueueAttributes.create = function create(properties) {
                    return new ExecutionQueueAttributes(properties);
                };
    
                /**
                 * Encodes the specified ExecutionQueueAttributes message. Does not implicitly {@link nebulaidl.admin.ExecutionQueueAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionQueueAttributes
                 * @static
                 * @param {nebulaidl.admin.IExecutionQueueAttributes} message ExecutionQueueAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionQueueAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tags[i]);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionQueueAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionQueueAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionQueueAttributes} ExecutionQueueAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionQueueAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionQueueAttributes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionQueueAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionQueueAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionQueueAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    return null;
                };
    
                return ExecutionQueueAttributes;
            })();
    
            admin.ExecutionClusterLabel = (function() {
    
                /**
                 * Properties of an ExecutionClusterLabel.
                 * @memberof nebulaidl.admin
                 * @interface IExecutionClusterLabel
                 * @property {string|null} [value] ExecutionClusterLabel value
                 */
    
                /**
                 * Constructs a new ExecutionClusterLabel.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an ExecutionClusterLabel.
                 * @implements IExecutionClusterLabel
                 * @constructor
                 * @param {nebulaidl.admin.IExecutionClusterLabel=} [properties] Properties to set
                 */
                function ExecutionClusterLabel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ExecutionClusterLabel value.
                 * @member {string} value
                 * @memberof nebulaidl.admin.ExecutionClusterLabel
                 * @instance
                 */
                ExecutionClusterLabel.prototype.value = "";
    
                /**
                 * Creates a new ExecutionClusterLabel instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ExecutionClusterLabel
                 * @static
                 * @param {nebulaidl.admin.IExecutionClusterLabel=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ExecutionClusterLabel} ExecutionClusterLabel instance
                 */
                ExecutionClusterLabel.create = function create(properties) {
                    return new ExecutionClusterLabel(properties);
                };
    
                /**
                 * Encodes the specified ExecutionClusterLabel message. Does not implicitly {@link nebulaidl.admin.ExecutionClusterLabel.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ExecutionClusterLabel
                 * @static
                 * @param {nebulaidl.admin.IExecutionClusterLabel} message ExecutionClusterLabel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionClusterLabel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    return writer;
                };
    
                /**
                 * Decodes an ExecutionClusterLabel message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ExecutionClusterLabel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ExecutionClusterLabel} ExecutionClusterLabel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionClusterLabel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ExecutionClusterLabel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an ExecutionClusterLabel message.
                 * @function verify
                 * @memberof nebulaidl.admin.ExecutionClusterLabel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionClusterLabel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
    
                return ExecutionClusterLabel;
            })();
    
            admin.PluginOverride = (function() {
    
                /**
                 * Properties of a PluginOverride.
                 * @memberof nebulaidl.admin
                 * @interface IPluginOverride
                 * @property {string|null} [taskType] PluginOverride taskType
                 * @property {Array.<string>|null} [pluginId] PluginOverride pluginId
                 * @property {nebulaidl.admin.PluginOverride.MissingPluginBehavior|null} [missingPluginBehavior] PluginOverride missingPluginBehavior
                 */
    
                /**
                 * Constructs a new PluginOverride.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a PluginOverride.
                 * @implements IPluginOverride
                 * @constructor
                 * @param {nebulaidl.admin.IPluginOverride=} [properties] Properties to set
                 */
                function PluginOverride(properties) {
                    this.pluginId = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PluginOverride taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.admin.PluginOverride
                 * @instance
                 */
                PluginOverride.prototype.taskType = "";
    
                /**
                 * PluginOverride pluginId.
                 * @member {Array.<string>} pluginId
                 * @memberof nebulaidl.admin.PluginOverride
                 * @instance
                 */
                PluginOverride.prototype.pluginId = $util.emptyArray;
    
                /**
                 * PluginOverride missingPluginBehavior.
                 * @member {nebulaidl.admin.PluginOverride.MissingPluginBehavior} missingPluginBehavior
                 * @memberof nebulaidl.admin.PluginOverride
                 * @instance
                 */
                PluginOverride.prototype.missingPluginBehavior = 0;
    
                /**
                 * Creates a new PluginOverride instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.PluginOverride
                 * @static
                 * @param {nebulaidl.admin.IPluginOverride=} [properties] Properties to set
                 * @returns {nebulaidl.admin.PluginOverride} PluginOverride instance
                 */
                PluginOverride.create = function create(properties) {
                    return new PluginOverride(properties);
                };
    
                /**
                 * Encodes the specified PluginOverride message. Does not implicitly {@link nebulaidl.admin.PluginOverride.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.PluginOverride
                 * @static
                 * @param {nebulaidl.admin.IPluginOverride} message PluginOverride message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PluginOverride.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskType);
                    if (message.pluginId != null && message.pluginId.length)
                        for (var i = 0; i < message.pluginId.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.pluginId[i]);
                    if (message.missingPluginBehavior != null && message.hasOwnProperty("missingPluginBehavior"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.missingPluginBehavior);
                    return writer;
                };
    
                /**
                 * Decodes a PluginOverride message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.PluginOverride
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.PluginOverride} PluginOverride
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PluginOverride.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.PluginOverride();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskType = reader.string();
                            break;
                        case 2:
                            if (!(message.pluginId && message.pluginId.length))
                                message.pluginId = [];
                            message.pluginId.push(reader.string());
                            break;
                        case 4:
                            message.missingPluginBehavior = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PluginOverride message.
                 * @function verify
                 * @memberof nebulaidl.admin.PluginOverride
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PluginOverride.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.pluginId != null && message.hasOwnProperty("pluginId")) {
                        if (!Array.isArray(message.pluginId))
                            return "pluginId: array expected";
                        for (var i = 0; i < message.pluginId.length; ++i)
                            if (!$util.isString(message.pluginId[i]))
                                return "pluginId: string[] expected";
                    }
                    if (message.missingPluginBehavior != null && message.hasOwnProperty("missingPluginBehavior"))
                        switch (message.missingPluginBehavior) {
                        default:
                            return "missingPluginBehavior: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * MissingPluginBehavior enum.
                 * @name nebulaidl.admin.PluginOverride.MissingPluginBehavior
                 * @enum {string}
                 * @property {number} FAIL=0 FAIL value
                 * @property {number} USE_DEFAULT=1 USE_DEFAULT value
                 */
                PluginOverride.MissingPluginBehavior = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "FAIL"] = 0;
                    values[valuesById[1] = "USE_DEFAULT"] = 1;
                    return values;
                })();
    
                return PluginOverride;
            })();
    
            admin.PluginOverrides = (function() {
    
                /**
                 * Properties of a PluginOverrides.
                 * @memberof nebulaidl.admin
                 * @interface IPluginOverrides
                 * @property {Array.<nebulaidl.admin.IPluginOverride>|null} [overrides] PluginOverrides overrides
                 */
    
                /**
                 * Constructs a new PluginOverrides.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a PluginOverrides.
                 * @implements IPluginOverrides
                 * @constructor
                 * @param {nebulaidl.admin.IPluginOverrides=} [properties] Properties to set
                 */
                function PluginOverrides(properties) {
                    this.overrides = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PluginOverrides overrides.
                 * @member {Array.<nebulaidl.admin.IPluginOverride>} overrides
                 * @memberof nebulaidl.admin.PluginOverrides
                 * @instance
                 */
                PluginOverrides.prototype.overrides = $util.emptyArray;
    
                /**
                 * Creates a new PluginOverrides instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.PluginOverrides
                 * @static
                 * @param {nebulaidl.admin.IPluginOverrides=} [properties] Properties to set
                 * @returns {nebulaidl.admin.PluginOverrides} PluginOverrides instance
                 */
                PluginOverrides.create = function create(properties) {
                    return new PluginOverrides(properties);
                };
    
                /**
                 * Encodes the specified PluginOverrides message. Does not implicitly {@link nebulaidl.admin.PluginOverrides.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.PluginOverrides
                 * @static
                 * @param {nebulaidl.admin.IPluginOverrides} message PluginOverrides message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PluginOverrides.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.overrides != null && message.overrides.length)
                        for (var i = 0; i < message.overrides.length; ++i)
                            $root.nebulaidl.admin.PluginOverride.encode(message.overrides[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a PluginOverrides message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.PluginOverrides
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.PluginOverrides} PluginOverrides
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PluginOverrides.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.PluginOverrides();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.overrides && message.overrides.length))
                                message.overrides = [];
                            message.overrides.push($root.nebulaidl.admin.PluginOverride.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PluginOverrides message.
                 * @function verify
                 * @memberof nebulaidl.admin.PluginOverrides
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PluginOverrides.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.overrides != null && message.hasOwnProperty("overrides")) {
                        if (!Array.isArray(message.overrides))
                            return "overrides: array expected";
                        for (var i = 0; i < message.overrides.length; ++i) {
                            var error = $root.nebulaidl.admin.PluginOverride.verify(message.overrides[i]);
                            if (error)
                                return "overrides." + error;
                        }
                    }
                    return null;
                };
    
                return PluginOverrides;
            })();
    
            admin.WorkflowExecutionConfig = (function() {
    
                /**
                 * Properties of a WorkflowExecutionConfig.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowExecutionConfig
                 * @property {number|null} [maxParallelism] WorkflowExecutionConfig maxParallelism
                 * @property {nebulaidl.core.ISecurityContext|null} [securityContext] WorkflowExecutionConfig securityContext
                 * @property {nebulaidl.admin.IRawOutputDataConfig|null} [rawOutputDataConfig] WorkflowExecutionConfig rawOutputDataConfig
                 * @property {nebulaidl.admin.ILabels|null} [labels] WorkflowExecutionConfig labels
                 * @property {nebulaidl.admin.IAnnotations|null} [annotations] WorkflowExecutionConfig annotations
                 * @property {google.protobuf.IBoolValue|null} [interruptible] WorkflowExecutionConfig interruptible
                 * @property {boolean|null} [overwriteCache] WorkflowExecutionConfig overwriteCache
                 * @property {nebulaidl.admin.IEnvs|null} [envs] WorkflowExecutionConfig envs
                 */
    
                /**
                 * Constructs a new WorkflowExecutionConfig.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowExecutionConfig.
                 * @implements IWorkflowExecutionConfig
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowExecutionConfig=} [properties] Properties to set
                 */
                function WorkflowExecutionConfig(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowExecutionConfig maxParallelism.
                 * @member {number} maxParallelism
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.maxParallelism = 0;
    
                /**
                 * WorkflowExecutionConfig securityContext.
                 * @member {nebulaidl.core.ISecurityContext|null|undefined} securityContext
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.securityContext = null;
    
                /**
                 * WorkflowExecutionConfig rawOutputDataConfig.
                 * @member {nebulaidl.admin.IRawOutputDataConfig|null|undefined} rawOutputDataConfig
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.rawOutputDataConfig = null;
    
                /**
                 * WorkflowExecutionConfig labels.
                 * @member {nebulaidl.admin.ILabels|null|undefined} labels
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.labels = null;
    
                /**
                 * WorkflowExecutionConfig annotations.
                 * @member {nebulaidl.admin.IAnnotations|null|undefined} annotations
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.annotations = null;
    
                /**
                 * WorkflowExecutionConfig interruptible.
                 * @member {google.protobuf.IBoolValue|null|undefined} interruptible
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.interruptible = null;
    
                /**
                 * WorkflowExecutionConfig overwriteCache.
                 * @member {boolean} overwriteCache
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.overwriteCache = false;
    
                /**
                 * WorkflowExecutionConfig envs.
                 * @member {nebulaidl.admin.IEnvs|null|undefined} envs
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @instance
                 */
                WorkflowExecutionConfig.prototype.envs = null;
    
                /**
                 * Creates a new WorkflowExecutionConfig instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionConfig=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowExecutionConfig} WorkflowExecutionConfig instance
                 */
                WorkflowExecutionConfig.create = function create(properties) {
                    return new WorkflowExecutionConfig(properties);
                };
    
                /**
                 * Encodes the specified WorkflowExecutionConfig message. Does not implicitly {@link nebulaidl.admin.WorkflowExecutionConfig.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @static
                 * @param {nebulaidl.admin.IWorkflowExecutionConfig} message WorkflowExecutionConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowExecutionConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.maxParallelism != null && message.hasOwnProperty("maxParallelism"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.maxParallelism);
                    if (message.securityContext != null && message.hasOwnProperty("securityContext"))
                        $root.nebulaidl.core.SecurityContext.encode(message.securityContext, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rawOutputDataConfig != null && message.hasOwnProperty("rawOutputDataConfig"))
                        $root.nebulaidl.admin.RawOutputDataConfig.encode(message.rawOutputDataConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        $root.nebulaidl.admin.Labels.encode(message.labels, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.annotations != null && message.hasOwnProperty("annotations"))
                        $root.nebulaidl.admin.Annotations.encode(message.annotations, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.interruptible != null && message.hasOwnProperty("interruptible"))
                        $root.google.protobuf.BoolValue.encode(message.interruptible, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.overwriteCache);
                    if (message.envs != null && message.hasOwnProperty("envs"))
                        $root.nebulaidl.admin.Envs.encode(message.envs, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowExecutionConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowExecutionConfig} WorkflowExecutionConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowExecutionConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowExecutionConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.maxParallelism = reader.int32();
                            break;
                        case 2:
                            message.securityContext = $root.nebulaidl.core.SecurityContext.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rawOutputDataConfig = $root.nebulaidl.admin.RawOutputDataConfig.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.labels = $root.nebulaidl.admin.Labels.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.annotations = $root.nebulaidl.admin.Annotations.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.interruptible = $root.google.protobuf.BoolValue.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.overwriteCache = reader.bool();
                            break;
                        case 8:
                            message.envs = $root.nebulaidl.admin.Envs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowExecutionConfig message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowExecutionConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowExecutionConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.maxParallelism != null && message.hasOwnProperty("maxParallelism"))
                        if (!$util.isInteger(message.maxParallelism))
                            return "maxParallelism: integer expected";
                    if (message.securityContext != null && message.hasOwnProperty("securityContext")) {
                        var error = $root.nebulaidl.core.SecurityContext.verify(message.securityContext);
                        if (error)
                            return "securityContext." + error;
                    }
                    if (message.rawOutputDataConfig != null && message.hasOwnProperty("rawOutputDataConfig")) {
                        var error = $root.nebulaidl.admin.RawOutputDataConfig.verify(message.rawOutputDataConfig);
                        if (error)
                            return "rawOutputDataConfig." + error;
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        var error = $root.nebulaidl.admin.Labels.verify(message.labels);
                        if (error)
                            return "labels." + error;
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        var error = $root.nebulaidl.admin.Annotations.verify(message.annotations);
                        if (error)
                            return "annotations." + error;
                    }
                    if (message.interruptible != null && message.hasOwnProperty("interruptible")) {
                        var error = $root.google.protobuf.BoolValue.verify(message.interruptible);
                        if (error)
                            return "interruptible." + error;
                    }
                    if (message.overwriteCache != null && message.hasOwnProperty("overwriteCache"))
                        if (typeof message.overwriteCache !== "boolean")
                            return "overwriteCache: boolean expected";
                    if (message.envs != null && message.hasOwnProperty("envs")) {
                        var error = $root.nebulaidl.admin.Envs.verify(message.envs);
                        if (error)
                            return "envs." + error;
                    }
                    return null;
                };
    
                return WorkflowExecutionConfig;
            })();
    
            admin.MatchingAttributes = (function() {
    
                /**
                 * Properties of a MatchingAttributes.
                 * @memberof nebulaidl.admin
                 * @interface IMatchingAttributes
                 * @property {nebulaidl.admin.ITaskResourceAttributes|null} [taskResourceAttributes] MatchingAttributes taskResourceAttributes
                 * @property {nebulaidl.admin.IClusterResourceAttributes|null} [clusterResourceAttributes] MatchingAttributes clusterResourceAttributes
                 * @property {nebulaidl.admin.IExecutionQueueAttributes|null} [executionQueueAttributes] MatchingAttributes executionQueueAttributes
                 * @property {nebulaidl.admin.IExecutionClusterLabel|null} [executionClusterLabel] MatchingAttributes executionClusterLabel
                 * @property {nebulaidl.core.IQualityOfService|null} [qualityOfService] MatchingAttributes qualityOfService
                 * @property {nebulaidl.admin.IPluginOverrides|null} [pluginOverrides] MatchingAttributes pluginOverrides
                 * @property {nebulaidl.admin.IWorkflowExecutionConfig|null} [workflowExecutionConfig] MatchingAttributes workflowExecutionConfig
                 * @property {nebulaidl.admin.IClusterAssignment|null} [clusterAssignment] MatchingAttributes clusterAssignment
                 */
    
                /**
                 * Constructs a new MatchingAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a MatchingAttributes.
                 * @implements IMatchingAttributes
                 * @constructor
                 * @param {nebulaidl.admin.IMatchingAttributes=} [properties] Properties to set
                 */
                function MatchingAttributes(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MatchingAttributes taskResourceAttributes.
                 * @member {nebulaidl.admin.ITaskResourceAttributes|null|undefined} taskResourceAttributes
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.taskResourceAttributes = null;
    
                /**
                 * MatchingAttributes clusterResourceAttributes.
                 * @member {nebulaidl.admin.IClusterResourceAttributes|null|undefined} clusterResourceAttributes
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.clusterResourceAttributes = null;
    
                /**
                 * MatchingAttributes executionQueueAttributes.
                 * @member {nebulaidl.admin.IExecutionQueueAttributes|null|undefined} executionQueueAttributes
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.executionQueueAttributes = null;
    
                /**
                 * MatchingAttributes executionClusterLabel.
                 * @member {nebulaidl.admin.IExecutionClusterLabel|null|undefined} executionClusterLabel
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.executionClusterLabel = null;
    
                /**
                 * MatchingAttributes qualityOfService.
                 * @member {nebulaidl.core.IQualityOfService|null|undefined} qualityOfService
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.qualityOfService = null;
    
                /**
                 * MatchingAttributes pluginOverrides.
                 * @member {nebulaidl.admin.IPluginOverrides|null|undefined} pluginOverrides
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.pluginOverrides = null;
    
                /**
                 * MatchingAttributes workflowExecutionConfig.
                 * @member {nebulaidl.admin.IWorkflowExecutionConfig|null|undefined} workflowExecutionConfig
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.workflowExecutionConfig = null;
    
                /**
                 * MatchingAttributes clusterAssignment.
                 * @member {nebulaidl.admin.IClusterAssignment|null|undefined} clusterAssignment
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                MatchingAttributes.prototype.clusterAssignment = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * MatchingAttributes target.
                 * @member {"taskResourceAttributes"|"clusterResourceAttributes"|"executionQueueAttributes"|"executionClusterLabel"|"qualityOfService"|"pluginOverrides"|"workflowExecutionConfig"|"clusterAssignment"|undefined} target
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @instance
                 */
                Object.defineProperty(MatchingAttributes.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["taskResourceAttributes", "clusterResourceAttributes", "executionQueueAttributes", "executionClusterLabel", "qualityOfService", "pluginOverrides", "workflowExecutionConfig", "clusterAssignment"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new MatchingAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @static
                 * @param {nebulaidl.admin.IMatchingAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.MatchingAttributes} MatchingAttributes instance
                 */
                MatchingAttributes.create = function create(properties) {
                    return new MatchingAttributes(properties);
                };
    
                /**
                 * Encodes the specified MatchingAttributes message. Does not implicitly {@link nebulaidl.admin.MatchingAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @static
                 * @param {nebulaidl.admin.IMatchingAttributes} message MatchingAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MatchingAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskResourceAttributes != null && message.hasOwnProperty("taskResourceAttributes"))
                        $root.nebulaidl.admin.TaskResourceAttributes.encode(message.taskResourceAttributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.clusterResourceAttributes != null && message.hasOwnProperty("clusterResourceAttributes"))
                        $root.nebulaidl.admin.ClusterResourceAttributes.encode(message.clusterResourceAttributes, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.executionQueueAttributes != null && message.hasOwnProperty("executionQueueAttributes"))
                        $root.nebulaidl.admin.ExecutionQueueAttributes.encode(message.executionQueueAttributes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.executionClusterLabel != null && message.hasOwnProperty("executionClusterLabel"))
                        $root.nebulaidl.admin.ExecutionClusterLabel.encode(message.executionClusterLabel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService"))
                        $root.nebulaidl.core.QualityOfService.encode(message.qualityOfService, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.pluginOverrides != null && message.hasOwnProperty("pluginOverrides"))
                        $root.nebulaidl.admin.PluginOverrides.encode(message.pluginOverrides, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.workflowExecutionConfig != null && message.hasOwnProperty("workflowExecutionConfig"))
                        $root.nebulaidl.admin.WorkflowExecutionConfig.encode(message.workflowExecutionConfig, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.clusterAssignment != null && message.hasOwnProperty("clusterAssignment"))
                        $root.nebulaidl.admin.ClusterAssignment.encode(message.clusterAssignment, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a MatchingAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.MatchingAttributes} MatchingAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MatchingAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.MatchingAttributes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskResourceAttributes = $root.nebulaidl.admin.TaskResourceAttributes.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.clusterResourceAttributes = $root.nebulaidl.admin.ClusterResourceAttributes.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.executionQueueAttributes = $root.nebulaidl.admin.ExecutionQueueAttributes.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.executionClusterLabel = $root.nebulaidl.admin.ExecutionClusterLabel.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.qualityOfService = $root.nebulaidl.core.QualityOfService.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.pluginOverrides = $root.nebulaidl.admin.PluginOverrides.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.workflowExecutionConfig = $root.nebulaidl.admin.WorkflowExecutionConfig.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.clusterAssignment = $root.nebulaidl.admin.ClusterAssignment.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a MatchingAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.MatchingAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MatchingAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.taskResourceAttributes != null && message.hasOwnProperty("taskResourceAttributes")) {
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.TaskResourceAttributes.verify(message.taskResourceAttributes);
                            if (error)
                                return "taskResourceAttributes." + error;
                        }
                    }
                    if (message.clusterResourceAttributes != null && message.hasOwnProperty("clusterResourceAttributes")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.ClusterResourceAttributes.verify(message.clusterResourceAttributes);
                            if (error)
                                return "clusterResourceAttributes." + error;
                        }
                    }
                    if (message.executionQueueAttributes != null && message.hasOwnProperty("executionQueueAttributes")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.ExecutionQueueAttributes.verify(message.executionQueueAttributes);
                            if (error)
                                return "executionQueueAttributes." + error;
                        }
                    }
                    if (message.executionClusterLabel != null && message.hasOwnProperty("executionClusterLabel")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.ExecutionClusterLabel.verify(message.executionClusterLabel);
                            if (error)
                                return "executionClusterLabel." + error;
                        }
                    }
                    if (message.qualityOfService != null && message.hasOwnProperty("qualityOfService")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.core.QualityOfService.verify(message.qualityOfService);
                            if (error)
                                return "qualityOfService." + error;
                        }
                    }
                    if (message.pluginOverrides != null && message.hasOwnProperty("pluginOverrides")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.PluginOverrides.verify(message.pluginOverrides);
                            if (error)
                                return "pluginOverrides." + error;
                        }
                    }
                    if (message.workflowExecutionConfig != null && message.hasOwnProperty("workflowExecutionConfig")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.WorkflowExecutionConfig.verify(message.workflowExecutionConfig);
                            if (error)
                                return "workflowExecutionConfig." + error;
                        }
                    }
                    if (message.clusterAssignment != null && message.hasOwnProperty("clusterAssignment")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.nebulaidl.admin.ClusterAssignment.verify(message.clusterAssignment);
                            if (error)
                                return "clusterAssignment." + error;
                        }
                    }
                    return null;
                };
    
                return MatchingAttributes;
            })();
    
            admin.MatchableAttributesConfiguration = (function() {
    
                /**
                 * Properties of a MatchableAttributesConfiguration.
                 * @memberof nebulaidl.admin
                 * @interface IMatchableAttributesConfiguration
                 * @property {nebulaidl.admin.IMatchingAttributes|null} [attributes] MatchableAttributesConfiguration attributes
                 * @property {string|null} [domain] MatchableAttributesConfiguration domain
                 * @property {string|null} [project] MatchableAttributesConfiguration project
                 * @property {string|null} [workflow] MatchableAttributesConfiguration workflow
                 * @property {string|null} [launchPlan] MatchableAttributesConfiguration launchPlan
                 */
    
                /**
                 * Constructs a new MatchableAttributesConfiguration.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a MatchableAttributesConfiguration.
                 * @implements IMatchableAttributesConfiguration
                 * @constructor
                 * @param {nebulaidl.admin.IMatchableAttributesConfiguration=} [properties] Properties to set
                 */
                function MatchableAttributesConfiguration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MatchableAttributesConfiguration attributes.
                 * @member {nebulaidl.admin.IMatchingAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @instance
                 */
                MatchableAttributesConfiguration.prototype.attributes = null;
    
                /**
                 * MatchableAttributesConfiguration domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @instance
                 */
                MatchableAttributesConfiguration.prototype.domain = "";
    
                /**
                 * MatchableAttributesConfiguration project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @instance
                 */
                MatchableAttributesConfiguration.prototype.project = "";
    
                /**
                 * MatchableAttributesConfiguration workflow.
                 * @member {string} workflow
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @instance
                 */
                MatchableAttributesConfiguration.prototype.workflow = "";
    
                /**
                 * MatchableAttributesConfiguration launchPlan.
                 * @member {string} launchPlan
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @instance
                 */
                MatchableAttributesConfiguration.prototype.launchPlan = "";
    
                /**
                 * Creates a new MatchableAttributesConfiguration instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @static
                 * @param {nebulaidl.admin.IMatchableAttributesConfiguration=} [properties] Properties to set
                 * @returns {nebulaidl.admin.MatchableAttributesConfiguration} MatchableAttributesConfiguration instance
                 */
                MatchableAttributesConfiguration.create = function create(properties) {
                    return new MatchableAttributesConfiguration(properties);
                };
    
                /**
                 * Encodes the specified MatchableAttributesConfiguration message. Does not implicitly {@link nebulaidl.admin.MatchableAttributesConfiguration.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @static
                 * @param {nebulaidl.admin.IMatchableAttributesConfiguration} message MatchableAttributesConfiguration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MatchableAttributesConfiguration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.MatchingAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.workflow);
                    if (message.launchPlan != null && message.hasOwnProperty("launchPlan"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.launchPlan);
                    return writer;
                };
    
                /**
                 * Decodes a MatchableAttributesConfiguration message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.MatchableAttributesConfiguration} MatchableAttributesConfiguration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MatchableAttributesConfiguration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.MatchableAttributesConfiguration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.project = reader.string();
                            break;
                        case 4:
                            message.workflow = reader.string();
                            break;
                        case 5:
                            message.launchPlan = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a MatchableAttributesConfiguration message.
                 * @function verify
                 * @memberof nebulaidl.admin.MatchableAttributesConfiguration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MatchableAttributesConfiguration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.MatchingAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        if (!$util.isString(message.workflow))
                            return "workflow: string expected";
                    if (message.launchPlan != null && message.hasOwnProperty("launchPlan"))
                        if (!$util.isString(message.launchPlan))
                            return "launchPlan: string expected";
                    return null;
                };
    
                return MatchableAttributesConfiguration;
            })();
    
            admin.ListMatchableAttributesRequest = (function() {
    
                /**
                 * Properties of a ListMatchableAttributesRequest.
                 * @memberof nebulaidl.admin
                 * @interface IListMatchableAttributesRequest
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] ListMatchableAttributesRequest resourceType
                 */
    
                /**
                 * Constructs a new ListMatchableAttributesRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ListMatchableAttributesRequest.
                 * @implements IListMatchableAttributesRequest
                 * @constructor
                 * @param {nebulaidl.admin.IListMatchableAttributesRequest=} [properties] Properties to set
                 */
                function ListMatchableAttributesRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ListMatchableAttributesRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.ListMatchableAttributesRequest
                 * @instance
                 */
                ListMatchableAttributesRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new ListMatchableAttributesRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ListMatchableAttributesRequest
                 * @static
                 * @param {nebulaidl.admin.IListMatchableAttributesRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ListMatchableAttributesRequest} ListMatchableAttributesRequest instance
                 */
                ListMatchableAttributesRequest.create = function create(properties) {
                    return new ListMatchableAttributesRequest(properties);
                };
    
                /**
                 * Encodes the specified ListMatchableAttributesRequest message. Does not implicitly {@link nebulaidl.admin.ListMatchableAttributesRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ListMatchableAttributesRequest
                 * @static
                 * @param {nebulaidl.admin.IListMatchableAttributesRequest} message ListMatchableAttributesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListMatchableAttributesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a ListMatchableAttributesRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ListMatchableAttributesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ListMatchableAttributesRequest} ListMatchableAttributesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListMatchableAttributesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ListMatchableAttributesRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ListMatchableAttributesRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ListMatchableAttributesRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListMatchableAttributesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return ListMatchableAttributesRequest;
            })();
    
            admin.ListMatchableAttributesResponse = (function() {
    
                /**
                 * Properties of a ListMatchableAttributesResponse.
                 * @memberof nebulaidl.admin
                 * @interface IListMatchableAttributesResponse
                 * @property {Array.<nebulaidl.admin.IMatchableAttributesConfiguration>|null} [configurations] ListMatchableAttributesResponse configurations
                 */
    
                /**
                 * Constructs a new ListMatchableAttributesResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ListMatchableAttributesResponse.
                 * @implements IListMatchableAttributesResponse
                 * @constructor
                 * @param {nebulaidl.admin.IListMatchableAttributesResponse=} [properties] Properties to set
                 */
                function ListMatchableAttributesResponse(properties) {
                    this.configurations = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ListMatchableAttributesResponse configurations.
                 * @member {Array.<nebulaidl.admin.IMatchableAttributesConfiguration>} configurations
                 * @memberof nebulaidl.admin.ListMatchableAttributesResponse
                 * @instance
                 */
                ListMatchableAttributesResponse.prototype.configurations = $util.emptyArray;
    
                /**
                 * Creates a new ListMatchableAttributesResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ListMatchableAttributesResponse
                 * @static
                 * @param {nebulaidl.admin.IListMatchableAttributesResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ListMatchableAttributesResponse} ListMatchableAttributesResponse instance
                 */
                ListMatchableAttributesResponse.create = function create(properties) {
                    return new ListMatchableAttributesResponse(properties);
                };
    
                /**
                 * Encodes the specified ListMatchableAttributesResponse message. Does not implicitly {@link nebulaidl.admin.ListMatchableAttributesResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ListMatchableAttributesResponse
                 * @static
                 * @param {nebulaidl.admin.IListMatchableAttributesResponse} message ListMatchableAttributesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListMatchableAttributesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.configurations != null && message.configurations.length)
                        for (var i = 0; i < message.configurations.length; ++i)
                            $root.nebulaidl.admin.MatchableAttributesConfiguration.encode(message.configurations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ListMatchableAttributesResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ListMatchableAttributesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ListMatchableAttributesResponse} ListMatchableAttributesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListMatchableAttributesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ListMatchableAttributesResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.configurations && message.configurations.length))
                                message.configurations = [];
                            message.configurations.push($root.nebulaidl.admin.MatchableAttributesConfiguration.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ListMatchableAttributesResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ListMatchableAttributesResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListMatchableAttributesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.configurations != null && message.hasOwnProperty("configurations")) {
                        if (!Array.isArray(message.configurations))
                            return "configurations: array expected";
                        for (var i = 0; i < message.configurations.length; ++i) {
                            var error = $root.nebulaidl.admin.MatchableAttributesConfiguration.verify(message.configurations[i]);
                            if (error)
                                return "configurations." + error;
                        }
                    }
                    return null;
                };
    
                return ListMatchableAttributesResponse;
            })();
    
            admin.NodeExecutionGetRequest = (function() {
    
                /**
                 * Properties of a NodeExecutionGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionGetRequest
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [id] NodeExecutionGetRequest id
                 */
    
                /**
                 * Constructs a new NodeExecutionGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionGetRequest.
                 * @implements INodeExecutionGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionGetRequest=} [properties] Properties to set
                 */
                function NodeExecutionGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionGetRequest id.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.NodeExecutionGetRequest
                 * @instance
                 */
                NodeExecutionGetRequest.prototype.id = null;
    
                /**
                 * Creates a new NodeExecutionGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionGetRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionGetRequest} NodeExecutionGetRequest instance
                 */
                NodeExecutionGetRequest.create = function create(properties) {
                    return new NodeExecutionGetRequest(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionGetRequest message. Does not implicitly {@link nebulaidl.admin.NodeExecutionGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionGetRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionGetRequest} message NodeExecutionGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionGetRequest} NodeExecutionGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return NodeExecutionGetRequest;
            })();
    
            admin.NodeExecutionListRequest = (function() {
    
                /**
                 * Properties of a NodeExecutionListRequest.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionListRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [workflowExecutionId] NodeExecutionListRequest workflowExecutionId
                 * @property {number|null} [limit] NodeExecutionListRequest limit
                 * @property {string|null} [token] NodeExecutionListRequest token
                 * @property {string|null} [filters] NodeExecutionListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] NodeExecutionListRequest sortBy
                 * @property {string|null} [uniqueParentId] NodeExecutionListRequest uniqueParentId
                 */
    
                /**
                 * Constructs a new NodeExecutionListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionListRequest.
                 * @implements INodeExecutionListRequest
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionListRequest=} [properties] Properties to set
                 */
                function NodeExecutionListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionListRequest workflowExecutionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} workflowExecutionId
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @instance
                 */
                NodeExecutionListRequest.prototype.workflowExecutionId = null;
    
                /**
                 * NodeExecutionListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @instance
                 */
                NodeExecutionListRequest.prototype.limit = 0;
    
                /**
                 * NodeExecutionListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @instance
                 */
                NodeExecutionListRequest.prototype.token = "";
    
                /**
                 * NodeExecutionListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @instance
                 */
                NodeExecutionListRequest.prototype.filters = "";
    
                /**
                 * NodeExecutionListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @instance
                 */
                NodeExecutionListRequest.prototype.sortBy = null;
    
                /**
                 * NodeExecutionListRequest uniqueParentId.
                 * @member {string} uniqueParentId
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @instance
                 */
                NodeExecutionListRequest.prototype.uniqueParentId = "";
    
                /**
                 * Creates a new NodeExecutionListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionListRequest} NodeExecutionListRequest instance
                 */
                NodeExecutionListRequest.create = function create(properties) {
                    return new NodeExecutionListRequest(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionListRequest message. Does not implicitly {@link nebulaidl.admin.NodeExecutionListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionListRequest} message NodeExecutionListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.workflowExecutionId != null && message.hasOwnProperty("workflowExecutionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.workflowExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.uniqueParentId != null && message.hasOwnProperty("uniqueParentId"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.uniqueParentId);
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionListRequest} NodeExecutionListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.workflowExecutionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.limit = reader.uint32();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.filters = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.uniqueParentId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.workflowExecutionId != null && message.hasOwnProperty("workflowExecutionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.workflowExecutionId);
                        if (error)
                            return "workflowExecutionId." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    if (message.uniqueParentId != null && message.hasOwnProperty("uniqueParentId"))
                        if (!$util.isString(message.uniqueParentId))
                            return "uniqueParentId: string expected";
                    return null;
                };
    
                return NodeExecutionListRequest;
            })();
    
            admin.NodeExecutionForTaskListRequest = (function() {
    
                /**
                 * Properties of a NodeExecutionForTaskListRequest.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionForTaskListRequest
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [taskExecutionId] NodeExecutionForTaskListRequest taskExecutionId
                 * @property {number|null} [limit] NodeExecutionForTaskListRequest limit
                 * @property {string|null} [token] NodeExecutionForTaskListRequest token
                 * @property {string|null} [filters] NodeExecutionForTaskListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] NodeExecutionForTaskListRequest sortBy
                 */
    
                /**
                 * Constructs a new NodeExecutionForTaskListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionForTaskListRequest.
                 * @implements INodeExecutionForTaskListRequest
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionForTaskListRequest=} [properties] Properties to set
                 */
                function NodeExecutionForTaskListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionForTaskListRequest taskExecutionId.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} taskExecutionId
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @instance
                 */
                NodeExecutionForTaskListRequest.prototype.taskExecutionId = null;
    
                /**
                 * NodeExecutionForTaskListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @instance
                 */
                NodeExecutionForTaskListRequest.prototype.limit = 0;
    
                /**
                 * NodeExecutionForTaskListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @instance
                 */
                NodeExecutionForTaskListRequest.prototype.token = "";
    
                /**
                 * NodeExecutionForTaskListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @instance
                 */
                NodeExecutionForTaskListRequest.prototype.filters = "";
    
                /**
                 * NodeExecutionForTaskListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @instance
                 */
                NodeExecutionForTaskListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new NodeExecutionForTaskListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionForTaskListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionForTaskListRequest} NodeExecutionForTaskListRequest instance
                 */
                NodeExecutionForTaskListRequest.create = function create(properties) {
                    return new NodeExecutionForTaskListRequest(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionForTaskListRequest message. Does not implicitly {@link nebulaidl.admin.NodeExecutionForTaskListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionForTaskListRequest} message NodeExecutionForTaskListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionForTaskListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.taskExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionForTaskListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionForTaskListRequest} NodeExecutionForTaskListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionForTaskListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionForTaskListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskExecutionId = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.limit = reader.uint32();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.filters = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionForTaskListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionForTaskListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionForTaskListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId")) {
                        var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.taskExecutionId);
                        if (error)
                            return "taskExecutionId." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return NodeExecutionForTaskListRequest;
            })();
    
            admin.NodeExecution = (function() {
    
                /**
                 * Properties of a NodeExecution.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecution
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [id] NodeExecution id
                 * @property {string|null} [inputUri] NodeExecution inputUri
                 * @property {nebulaidl.admin.INodeExecutionClosure|null} [closure] NodeExecution closure
                 * @property {nebulaidl.admin.INodeExecutionMetaData|null} [metadata] NodeExecution metadata
                 */
    
                /**
                 * Constructs a new NodeExecution.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecution.
                 * @implements INodeExecution
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecution=} [properties] Properties to set
                 */
                function NodeExecution(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecution id.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.NodeExecution
                 * @instance
                 */
                NodeExecution.prototype.id = null;
    
                /**
                 * NodeExecution inputUri.
                 * @member {string} inputUri
                 * @memberof nebulaidl.admin.NodeExecution
                 * @instance
                 */
                NodeExecution.prototype.inputUri = "";
    
                /**
                 * NodeExecution closure.
                 * @member {nebulaidl.admin.INodeExecutionClosure|null|undefined} closure
                 * @memberof nebulaidl.admin.NodeExecution
                 * @instance
                 */
                NodeExecution.prototype.closure = null;
    
                /**
                 * NodeExecution metadata.
                 * @member {nebulaidl.admin.INodeExecutionMetaData|null|undefined} metadata
                 * @memberof nebulaidl.admin.NodeExecution
                 * @instance
                 */
                NodeExecution.prototype.metadata = null;
    
                /**
                 * Creates a new NodeExecution instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecution
                 * @static
                 * @param {nebulaidl.admin.INodeExecution=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecution} NodeExecution instance
                 */
                NodeExecution.create = function create(properties) {
                    return new NodeExecution(properties);
                };
    
                /**
                 * Encodes the specified NodeExecution message. Does not implicitly {@link nebulaidl.admin.NodeExecution.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecution
                 * @static
                 * @param {nebulaidl.admin.INodeExecution} message NodeExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputUri);
                    if (message.closure != null && message.hasOwnProperty("closure"))
                        $root.nebulaidl.admin.NodeExecutionClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.admin.NodeExecutionMetaData.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecution} NodeExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecution.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecution();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.inputUri = reader.string();
                            break;
                        case 3:
                            message.closure = $root.nebulaidl.admin.NodeExecutionClosure.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.metadata = $root.nebulaidl.admin.NodeExecutionMetaData.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecution message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                        if (!$util.isString(message.inputUri))
                            return "inputUri: string expected";
                    if (message.closure != null && message.hasOwnProperty("closure")) {
                        var error = $root.nebulaidl.admin.NodeExecutionClosure.verify(message.closure);
                        if (error)
                            return "closure." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.admin.NodeExecutionMetaData.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                return NodeExecution;
            })();
    
            admin.NodeExecutionMetaData = (function() {
    
                /**
                 * Properties of a NodeExecutionMetaData.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionMetaData
                 * @property {string|null} [retryGroup] NodeExecutionMetaData retryGroup
                 * @property {boolean|null} [isParentNode] NodeExecutionMetaData isParentNode
                 * @property {string|null} [specNodeId] NodeExecutionMetaData specNodeId
                 * @property {boolean|null} [isDynamic] NodeExecutionMetaData isDynamic
                 */
    
                /**
                 * Constructs a new NodeExecutionMetaData.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionMetaData.
                 * @implements INodeExecutionMetaData
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionMetaData=} [properties] Properties to set
                 */
                function NodeExecutionMetaData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionMetaData retryGroup.
                 * @member {string} retryGroup
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @instance
                 */
                NodeExecutionMetaData.prototype.retryGroup = "";
    
                /**
                 * NodeExecutionMetaData isParentNode.
                 * @member {boolean} isParentNode
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @instance
                 */
                NodeExecutionMetaData.prototype.isParentNode = false;
    
                /**
                 * NodeExecutionMetaData specNodeId.
                 * @member {string} specNodeId
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @instance
                 */
                NodeExecutionMetaData.prototype.specNodeId = "";
    
                /**
                 * NodeExecutionMetaData isDynamic.
                 * @member {boolean} isDynamic
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @instance
                 */
                NodeExecutionMetaData.prototype.isDynamic = false;
    
                /**
                 * Creates a new NodeExecutionMetaData instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionMetaData=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionMetaData} NodeExecutionMetaData instance
                 */
                NodeExecutionMetaData.create = function create(properties) {
                    return new NodeExecutionMetaData(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionMetaData message. Does not implicitly {@link nebulaidl.admin.NodeExecutionMetaData.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionMetaData} message NodeExecutionMetaData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionMetaData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.retryGroup != null && message.hasOwnProperty("retryGroup"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.retryGroup);
                    if (message.isParentNode != null && message.hasOwnProperty("isParentNode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isParentNode);
                    if (message.specNodeId != null && message.hasOwnProperty("specNodeId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.specNodeId);
                    if (message.isDynamic != null && message.hasOwnProperty("isDynamic"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isDynamic);
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionMetaData message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionMetaData} NodeExecutionMetaData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionMetaData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionMetaData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.retryGroup = reader.string();
                            break;
                        case 2:
                            message.isParentNode = reader.bool();
                            break;
                        case 3:
                            message.specNodeId = reader.string();
                            break;
                        case 4:
                            message.isDynamic = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionMetaData message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionMetaData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionMetaData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.retryGroup != null && message.hasOwnProperty("retryGroup"))
                        if (!$util.isString(message.retryGroup))
                            return "retryGroup: string expected";
                    if (message.isParentNode != null && message.hasOwnProperty("isParentNode"))
                        if (typeof message.isParentNode !== "boolean")
                            return "isParentNode: boolean expected";
                    if (message.specNodeId != null && message.hasOwnProperty("specNodeId"))
                        if (!$util.isString(message.specNodeId))
                            return "specNodeId: string expected";
                    if (message.isDynamic != null && message.hasOwnProperty("isDynamic"))
                        if (typeof message.isDynamic !== "boolean")
                            return "isDynamic: boolean expected";
                    return null;
                };
    
                return NodeExecutionMetaData;
            })();
    
            admin.NodeExecutionList = (function() {
    
                /**
                 * Properties of a NodeExecutionList.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionList
                 * @property {Array.<nebulaidl.admin.INodeExecution>|null} [nodeExecutions] NodeExecutionList nodeExecutions
                 * @property {string|null} [token] NodeExecutionList token
                 */
    
                /**
                 * Constructs a new NodeExecutionList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionList.
                 * @implements INodeExecutionList
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionList=} [properties] Properties to set
                 */
                function NodeExecutionList(properties) {
                    this.nodeExecutions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionList nodeExecutions.
                 * @member {Array.<nebulaidl.admin.INodeExecution>} nodeExecutions
                 * @memberof nebulaidl.admin.NodeExecutionList
                 * @instance
                 */
                NodeExecutionList.prototype.nodeExecutions = $util.emptyArray;
    
                /**
                 * NodeExecutionList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.NodeExecutionList
                 * @instance
                 */
                NodeExecutionList.prototype.token = "";
    
                /**
                 * Creates a new NodeExecutionList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionList
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionList} NodeExecutionList instance
                 */
                NodeExecutionList.create = function create(properties) {
                    return new NodeExecutionList(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionList message. Does not implicitly {@link nebulaidl.admin.NodeExecutionList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionList
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionList} message NodeExecutionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeExecutions != null && message.nodeExecutions.length)
                        for (var i = 0; i < message.nodeExecutions.length; ++i)
                            $root.nebulaidl.admin.NodeExecution.encode(message.nodeExecutions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionList} NodeExecutionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodeExecutions && message.nodeExecutions.length))
                                message.nodeExecutions = [];
                            message.nodeExecutions.push($root.nebulaidl.admin.NodeExecution.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionList message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodeExecutions != null && message.hasOwnProperty("nodeExecutions")) {
                        if (!Array.isArray(message.nodeExecutions))
                            return "nodeExecutions: array expected";
                        for (var i = 0; i < message.nodeExecutions.length; ++i) {
                            var error = $root.nebulaidl.admin.NodeExecution.verify(message.nodeExecutions[i]);
                            if (error)
                                return "nodeExecutions." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return NodeExecutionList;
            })();
    
            admin.NodeExecutionClosure = (function() {
    
                /**
                 * Properties of a NodeExecutionClosure.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionClosure
                 * @property {string|null} [outputUri] NodeExecutionClosure outputUri
                 * @property {nebulaidl.core.IExecutionError|null} [error] NodeExecutionClosure error
                 * @property {nebulaidl.core.ILiteralMap|null} [outputData] NodeExecutionClosure outputData
                 * @property {nebulaidl.core.NodeExecution.Phase|null} [phase] NodeExecutionClosure phase
                 * @property {google.protobuf.ITimestamp|null} [startedAt] NodeExecutionClosure startedAt
                 * @property {google.protobuf.IDuration|null} [duration] NodeExecutionClosure duration
                 * @property {google.protobuf.ITimestamp|null} [createdAt] NodeExecutionClosure createdAt
                 * @property {google.protobuf.ITimestamp|null} [updatedAt] NodeExecutionClosure updatedAt
                 * @property {nebulaidl.admin.IWorkflowNodeMetadata|null} [workflowNodeMetadata] NodeExecutionClosure workflowNodeMetadata
                 * @property {nebulaidl.admin.ITaskNodeMetadata|null} [taskNodeMetadata] NodeExecutionClosure taskNodeMetadata
                 * @property {string|null} [deckUri] NodeExecutionClosure deckUri
                 * @property {string|null} [dynamicJobSpecUri] NodeExecutionClosure dynamicJobSpecUri
                 */
    
                /**
                 * Constructs a new NodeExecutionClosure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionClosure.
                 * @implements INodeExecutionClosure
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionClosure=} [properties] Properties to set
                 */
                function NodeExecutionClosure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionClosure outputUri.
                 * @member {string} outputUri
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.outputUri = "";
    
                /**
                 * NodeExecutionClosure error.
                 * @member {nebulaidl.core.IExecutionError|null|undefined} error
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.error = null;
    
                /**
                 * NodeExecutionClosure outputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputData
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.outputData = null;
    
                /**
                 * NodeExecutionClosure phase.
                 * @member {nebulaidl.core.NodeExecution.Phase} phase
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.phase = 0;
    
                /**
                 * NodeExecutionClosure startedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} startedAt
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.startedAt = null;
    
                /**
                 * NodeExecutionClosure duration.
                 * @member {google.protobuf.IDuration|null|undefined} duration
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.duration = null;
    
                /**
                 * NodeExecutionClosure createdAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} createdAt
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.createdAt = null;
    
                /**
                 * NodeExecutionClosure updatedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.updatedAt = null;
    
                /**
                 * NodeExecutionClosure workflowNodeMetadata.
                 * @member {nebulaidl.admin.IWorkflowNodeMetadata|null|undefined} workflowNodeMetadata
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.workflowNodeMetadata = null;
    
                /**
                 * NodeExecutionClosure taskNodeMetadata.
                 * @member {nebulaidl.admin.ITaskNodeMetadata|null|undefined} taskNodeMetadata
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.taskNodeMetadata = null;
    
                /**
                 * NodeExecutionClosure deckUri.
                 * @member {string} deckUri
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.deckUri = "";
    
                /**
                 * NodeExecutionClosure dynamicJobSpecUri.
                 * @member {string} dynamicJobSpecUri
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                NodeExecutionClosure.prototype.dynamicJobSpecUri = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * NodeExecutionClosure outputResult.
                 * @member {"outputUri"|"error"|"outputData"|undefined} outputResult
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                Object.defineProperty(NodeExecutionClosure.prototype, "outputResult", {
                    get: $util.oneOfGetter($oneOfFields = ["outputUri", "error", "outputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * NodeExecutionClosure targetMetadata.
                 * @member {"workflowNodeMetadata"|"taskNodeMetadata"|undefined} targetMetadata
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @instance
                 */
                Object.defineProperty(NodeExecutionClosure.prototype, "targetMetadata", {
                    get: $util.oneOfGetter($oneOfFields = ["workflowNodeMetadata", "taskNodeMetadata"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NodeExecutionClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionClosure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionClosure} NodeExecutionClosure instance
                 */
                NodeExecutionClosure.create = function create(properties) {
                    return new NodeExecutionClosure(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionClosure message. Does not implicitly {@link nebulaidl.admin.NodeExecutionClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionClosure} message NodeExecutionClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputUri);
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                    if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                        $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                        $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata"))
                        $root.nebulaidl.admin.WorkflowNodeMetadata.encode(message.workflowNodeMetadata, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.taskNodeMetadata != null && message.hasOwnProperty("taskNodeMetadata"))
                        $root.nebulaidl.admin.TaskNodeMetadata.encode(message.taskNodeMetadata, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.outputData != null && message.hasOwnProperty("outputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputData, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.deckUri != null && message.hasOwnProperty("deckUri"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.deckUri);
                    if (message.dynamicJobSpecUri != null && message.hasOwnProperty("dynamicJobSpecUri"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.dynamicJobSpecUri);
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionClosure} NodeExecutionClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputUri = reader.string();
                            break;
                        case 2:
                            message.error = $root.nebulaidl.core.ExecutionError.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.outputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.phase = reader.int32();
                            break;
                        case 4:
                            message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.workflowNodeMetadata = $root.nebulaidl.admin.WorkflowNodeMetadata.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.taskNodeMetadata = $root.nebulaidl.admin.TaskNodeMetadata.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.deckUri = reader.string();
                            break;
                        case 12:
                            message.dynamicJobSpecUri = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionClosure message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                        properties.outputResult = 1;
                        if (!$util.isString(message.outputUri))
                            return "outputUri: string expected";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.ExecutionError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.outputData != null && message.hasOwnProperty("outputData")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.outputData);
                            if (error)
                                return "outputData." + error;
                        }
                    }
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                        if (error)
                            return "startedAt." + error;
                    }
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                        if (error)
                            return "updatedAt." + error;
                    }
                    if (message.workflowNodeMetadata != null && message.hasOwnProperty("workflowNodeMetadata")) {
                        properties.targetMetadata = 1;
                        {
                            var error = $root.nebulaidl.admin.WorkflowNodeMetadata.verify(message.workflowNodeMetadata);
                            if (error)
                                return "workflowNodeMetadata." + error;
                        }
                    }
                    if (message.taskNodeMetadata != null && message.hasOwnProperty("taskNodeMetadata")) {
                        if (properties.targetMetadata === 1)
                            return "targetMetadata: multiple values";
                        properties.targetMetadata = 1;
                        {
                            var error = $root.nebulaidl.admin.TaskNodeMetadata.verify(message.taskNodeMetadata);
                            if (error)
                                return "taskNodeMetadata." + error;
                        }
                    }
                    if (message.deckUri != null && message.hasOwnProperty("deckUri"))
                        if (!$util.isString(message.deckUri))
                            return "deckUri: string expected";
                    if (message.dynamicJobSpecUri != null && message.hasOwnProperty("dynamicJobSpecUri"))
                        if (!$util.isString(message.dynamicJobSpecUri))
                            return "dynamicJobSpecUri: string expected";
                    return null;
                };
    
                return NodeExecutionClosure;
            })();
    
            admin.WorkflowNodeMetadata = (function() {
    
                /**
                 * Properties of a WorkflowNodeMetadata.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowNodeMetadata
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [executionId] WorkflowNodeMetadata executionId
                 */
    
                /**
                 * Constructs a new WorkflowNodeMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowNodeMetadata.
                 * @implements IWorkflowNodeMetadata
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowNodeMetadata=} [properties] Properties to set
                 */
                function WorkflowNodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowNodeMetadata executionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} executionId
                 * @memberof nebulaidl.admin.WorkflowNodeMetadata
                 * @instance
                 */
                WorkflowNodeMetadata.prototype.executionId = null;
    
                /**
                 * Creates a new WorkflowNodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.admin.IWorkflowNodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowNodeMetadata} WorkflowNodeMetadata instance
                 */
                WorkflowNodeMetadata.create = function create(properties) {
                    return new WorkflowNodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified WorkflowNodeMetadata message. Does not implicitly {@link nebulaidl.admin.WorkflowNodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.admin.IWorkflowNodeMetadata} message WorkflowNodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowNodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.executionId != null && message.hasOwnProperty("executionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.executionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowNodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowNodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowNodeMetadata} WorkflowNodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowNodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowNodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowNodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowNodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowNodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.executionId != null && message.hasOwnProperty("executionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.executionId);
                        if (error)
                            return "executionId." + error;
                    }
                    return null;
                };
    
                return WorkflowNodeMetadata;
            })();
    
            admin.TaskNodeMetadata = (function() {
    
                /**
                 * Properties of a TaskNodeMetadata.
                 * @memberof nebulaidl.admin
                 * @interface ITaskNodeMetadata
                 * @property {nebulaidl.core.CatalogCacheStatus|null} [cacheStatus] TaskNodeMetadata cacheStatus
                 * @property {nebulaidl.core.ICatalogMetadata|null} [catalogKey] TaskNodeMetadata catalogKey
                 * @property {string|null} [checkpointUri] TaskNodeMetadata checkpointUri
                 */
    
                /**
                 * Constructs a new TaskNodeMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskNodeMetadata.
                 * @implements ITaskNodeMetadata
                 * @constructor
                 * @param {nebulaidl.admin.ITaskNodeMetadata=} [properties] Properties to set
                 */
                function TaskNodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskNodeMetadata cacheStatus.
                 * @member {nebulaidl.core.CatalogCacheStatus} cacheStatus
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.cacheStatus = 0;
    
                /**
                 * TaskNodeMetadata catalogKey.
                 * @member {nebulaidl.core.ICatalogMetadata|null|undefined} catalogKey
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.catalogKey = null;
    
                /**
                 * TaskNodeMetadata checkpointUri.
                 * @member {string} checkpointUri
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @instance
                 */
                TaskNodeMetadata.prototype.checkpointUri = "";
    
                /**
                 * Creates a new TaskNodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @static
                 * @param {nebulaidl.admin.ITaskNodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskNodeMetadata} TaskNodeMetadata instance
                 */
                TaskNodeMetadata.create = function create(properties) {
                    return new TaskNodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified TaskNodeMetadata message. Does not implicitly {@link nebulaidl.admin.TaskNodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @static
                 * @param {nebulaidl.admin.ITaskNodeMetadata} message TaskNodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskNodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cacheStatus);
                    if (message.catalogKey != null && message.hasOwnProperty("catalogKey"))
                        $root.nebulaidl.core.CatalogMetadata.encode(message.catalogKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.checkpointUri != null && message.hasOwnProperty("checkpointUri"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.checkpointUri);
                    return writer;
                };
    
                /**
                 * Decodes a TaskNodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskNodeMetadata} TaskNodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskNodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskNodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cacheStatus = reader.int32();
                            break;
                        case 2:
                            message.catalogKey = $root.nebulaidl.core.CatalogMetadata.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.checkpointUri = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskNodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskNodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskNodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
                        switch (message.cacheStatus) {
                        default:
                            return "cacheStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.catalogKey != null && message.hasOwnProperty("catalogKey")) {
                        var error = $root.nebulaidl.core.CatalogMetadata.verify(message.catalogKey);
                        if (error)
                            return "catalogKey." + error;
                    }
                    if (message.checkpointUri != null && message.hasOwnProperty("checkpointUri"))
                        if (!$util.isString(message.checkpointUri))
                            return "checkpointUri: string expected";
                    return null;
                };
    
                return TaskNodeMetadata;
            })();
    
            admin.DynamicWorkflowNodeMetadata = (function() {
    
                /**
                 * Properties of a DynamicWorkflowNodeMetadata.
                 * @memberof nebulaidl.admin
                 * @interface IDynamicWorkflowNodeMetadata
                 * @property {nebulaidl.core.IIdentifier|null} [id] DynamicWorkflowNodeMetadata id
                 * @property {nebulaidl.core.ICompiledWorkflowClosure|null} [compiledWorkflow] DynamicWorkflowNodeMetadata compiledWorkflow
                 * @property {string|null} [dynamicJobSpecUri] DynamicWorkflowNodeMetadata dynamicJobSpecUri
                 */
    
                /**
                 * Constructs a new DynamicWorkflowNodeMetadata.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a DynamicWorkflowNodeMetadata.
                 * @implements IDynamicWorkflowNodeMetadata
                 * @constructor
                 * @param {nebulaidl.admin.IDynamicWorkflowNodeMetadata=} [properties] Properties to set
                 */
                function DynamicWorkflowNodeMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DynamicWorkflowNodeMetadata id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @instance
                 */
                DynamicWorkflowNodeMetadata.prototype.id = null;
    
                /**
                 * DynamicWorkflowNodeMetadata compiledWorkflow.
                 * @member {nebulaidl.core.ICompiledWorkflowClosure|null|undefined} compiledWorkflow
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @instance
                 */
                DynamicWorkflowNodeMetadata.prototype.compiledWorkflow = null;
    
                /**
                 * DynamicWorkflowNodeMetadata dynamicJobSpecUri.
                 * @member {string} dynamicJobSpecUri
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @instance
                 */
                DynamicWorkflowNodeMetadata.prototype.dynamicJobSpecUri = "";
    
                /**
                 * Creates a new DynamicWorkflowNodeMetadata instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.admin.IDynamicWorkflowNodeMetadata=} [properties] Properties to set
                 * @returns {nebulaidl.admin.DynamicWorkflowNodeMetadata} DynamicWorkflowNodeMetadata instance
                 */
                DynamicWorkflowNodeMetadata.create = function create(properties) {
                    return new DynamicWorkflowNodeMetadata(properties);
                };
    
                /**
                 * Encodes the specified DynamicWorkflowNodeMetadata message. Does not implicitly {@link nebulaidl.admin.DynamicWorkflowNodeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {nebulaidl.admin.IDynamicWorkflowNodeMetadata} message DynamicWorkflowNodeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DynamicWorkflowNodeMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow"))
                        $root.nebulaidl.core.CompiledWorkflowClosure.encode(message.compiledWorkflow, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.dynamicJobSpecUri != null && message.hasOwnProperty("dynamicJobSpecUri"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dynamicJobSpecUri);
                    return writer;
                };
    
                /**
                 * Decodes a DynamicWorkflowNodeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.DynamicWorkflowNodeMetadata} DynamicWorkflowNodeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DynamicWorkflowNodeMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.DynamicWorkflowNodeMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.compiledWorkflow = $root.nebulaidl.core.CompiledWorkflowClosure.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.dynamicJobSpecUri = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DynamicWorkflowNodeMetadata message.
                 * @function verify
                 * @memberof nebulaidl.admin.DynamicWorkflowNodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DynamicWorkflowNodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow")) {
                        var error = $root.nebulaidl.core.CompiledWorkflowClosure.verify(message.compiledWorkflow);
                        if (error)
                            return "compiledWorkflow." + error;
                    }
                    if (message.dynamicJobSpecUri != null && message.hasOwnProperty("dynamicJobSpecUri"))
                        if (!$util.isString(message.dynamicJobSpecUri))
                            return "dynamicJobSpecUri: string expected";
                    return null;
                };
    
                return DynamicWorkflowNodeMetadata;
            })();
    
            admin.NodeExecutionGetDataRequest = (function() {
    
                /**
                 * Properties of a NodeExecutionGetDataRequest.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionGetDataRequest
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [id] NodeExecutionGetDataRequest id
                 */
    
                /**
                 * Constructs a new NodeExecutionGetDataRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionGetDataRequest.
                 * @implements INodeExecutionGetDataRequest
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionGetDataRequest=} [properties] Properties to set
                 */
                function NodeExecutionGetDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionGetDataRequest id.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.NodeExecutionGetDataRequest
                 * @instance
                 */
                NodeExecutionGetDataRequest.prototype.id = null;
    
                /**
                 * Creates a new NodeExecutionGetDataRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionGetDataRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionGetDataRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionGetDataRequest} NodeExecutionGetDataRequest instance
                 */
                NodeExecutionGetDataRequest.create = function create(properties) {
                    return new NodeExecutionGetDataRequest(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionGetDataRequest message. Does not implicitly {@link nebulaidl.admin.NodeExecutionGetDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionGetDataRequest
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionGetDataRequest} message NodeExecutionGetDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionGetDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionGetDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionGetDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionGetDataRequest} NodeExecutionGetDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionGetDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionGetDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionGetDataRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionGetDataRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionGetDataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return NodeExecutionGetDataRequest;
            })();
    
            admin.NodeExecutionGetDataResponse = (function() {
    
                /**
                 * Properties of a NodeExecutionGetDataResponse.
                 * @memberof nebulaidl.admin
                 * @interface INodeExecutionGetDataResponse
                 * @property {nebulaidl.admin.IUrlBlob|null} [inputs] NodeExecutionGetDataResponse inputs
                 * @property {nebulaidl.admin.IUrlBlob|null} [outputs] NodeExecutionGetDataResponse outputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fullInputs] NodeExecutionGetDataResponse fullInputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fullOutputs] NodeExecutionGetDataResponse fullOutputs
                 * @property {nebulaidl.admin.IDynamicWorkflowNodeMetadata|null} [dynamicWorkflow] NodeExecutionGetDataResponse dynamicWorkflow
                 * @property {nebulaidl.admin.INebulaURLs|null} [nebulaUrls] NodeExecutionGetDataResponse nebulaUrls
                 */
    
                /**
                 * Constructs a new NodeExecutionGetDataResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a NodeExecutionGetDataResponse.
                 * @implements INodeExecutionGetDataResponse
                 * @constructor
                 * @param {nebulaidl.admin.INodeExecutionGetDataResponse=} [properties] Properties to set
                 */
                function NodeExecutionGetDataResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NodeExecutionGetDataResponse inputs.
                 * @member {nebulaidl.admin.IUrlBlob|null|undefined} inputs
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @instance
                 */
                NodeExecutionGetDataResponse.prototype.inputs = null;
    
                /**
                 * NodeExecutionGetDataResponse outputs.
                 * @member {nebulaidl.admin.IUrlBlob|null|undefined} outputs
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @instance
                 */
                NodeExecutionGetDataResponse.prototype.outputs = null;
    
                /**
                 * NodeExecutionGetDataResponse fullInputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fullInputs
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @instance
                 */
                NodeExecutionGetDataResponse.prototype.fullInputs = null;
    
                /**
                 * NodeExecutionGetDataResponse fullOutputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fullOutputs
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @instance
                 */
                NodeExecutionGetDataResponse.prototype.fullOutputs = null;
    
                /**
                 * NodeExecutionGetDataResponse dynamicWorkflow.
                 * @member {nebulaidl.admin.IDynamicWorkflowNodeMetadata|null|undefined} dynamicWorkflow
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @instance
                 */
                NodeExecutionGetDataResponse.prototype.dynamicWorkflow = null;
    
                /**
                 * NodeExecutionGetDataResponse nebulaUrls.
                 * @member {nebulaidl.admin.INebulaURLs|null|undefined} nebulaUrls
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @instance
                 */
                NodeExecutionGetDataResponse.prototype.nebulaUrls = null;
    
                /**
                 * Creates a new NodeExecutionGetDataResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionGetDataResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.NodeExecutionGetDataResponse} NodeExecutionGetDataResponse instance
                 */
                NodeExecutionGetDataResponse.create = function create(properties) {
                    return new NodeExecutionGetDataResponse(properties);
                };
    
                /**
                 * Encodes the specified NodeExecutionGetDataResponse message. Does not implicitly {@link nebulaidl.admin.NodeExecutionGetDataResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @static
                 * @param {nebulaidl.admin.INodeExecutionGetDataResponse} message NodeExecutionGetDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeExecutionGetDataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.admin.UrlBlob.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.admin.UrlBlob.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.fullInputs != null && message.hasOwnProperty("fullInputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fullInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fullOutputs != null && message.hasOwnProperty("fullOutputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fullOutputs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.dynamicWorkflow != null && message.hasOwnProperty("dynamicWorkflow"))
                        $root.nebulaidl.admin.DynamicWorkflowNodeMetadata.encode(message.dynamicWorkflow, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.nebulaUrls != null && message.hasOwnProperty("nebulaUrls"))
                        $root.nebulaidl.admin.NebulaURLs.encode(message.nebulaUrls, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NodeExecutionGetDataResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.NodeExecutionGetDataResponse} NodeExecutionGetDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeExecutionGetDataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.NodeExecutionGetDataResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputs = $root.nebulaidl.admin.UrlBlob.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.outputs = $root.nebulaidl.admin.UrlBlob.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.fullInputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.fullOutputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.dynamicWorkflow = $root.nebulaidl.admin.DynamicWorkflowNodeMetadata.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.nebulaUrls = $root.nebulaidl.admin.NebulaURLs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a NodeExecutionGetDataResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.NodeExecutionGetDataResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeExecutionGetDataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.admin.UrlBlob.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        var error = $root.nebulaidl.admin.UrlBlob.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                    if (message.fullInputs != null && message.hasOwnProperty("fullInputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fullInputs);
                        if (error)
                            return "fullInputs." + error;
                    }
                    if (message.fullOutputs != null && message.hasOwnProperty("fullOutputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fullOutputs);
                        if (error)
                            return "fullOutputs." + error;
                    }
                    if (message.dynamicWorkflow != null && message.hasOwnProperty("dynamicWorkflow")) {
                        var error = $root.nebulaidl.admin.DynamicWorkflowNodeMetadata.verify(message.dynamicWorkflow);
                        if (error)
                            return "dynamicWorkflow." + error;
                    }
                    if (message.nebulaUrls != null && message.hasOwnProperty("nebulaUrls")) {
                        var error = $root.nebulaidl.admin.NebulaURLs.verify(message.nebulaUrls);
                        if (error)
                            return "nebulaUrls." + error;
                    }
                    return null;
                };
    
                return NodeExecutionGetDataResponse;
            })();
    
            admin.EmailMessage = (function() {
    
                /**
                 * Properties of an EmailMessage.
                 * @memberof nebulaidl.admin
                 * @interface IEmailMessage
                 * @property {Array.<string>|null} [recipientsEmail] EmailMessage recipientsEmail
                 * @property {string|null} [senderEmail] EmailMessage senderEmail
                 * @property {string|null} [subjectLine] EmailMessage subjectLine
                 * @property {string|null} [body] EmailMessage body
                 */
    
                /**
                 * Constructs a new EmailMessage.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents an EmailMessage.
                 * @implements IEmailMessage
                 * @constructor
                 * @param {nebulaidl.admin.IEmailMessage=} [properties] Properties to set
                 */
                function EmailMessage(properties) {
                    this.recipientsEmail = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EmailMessage recipientsEmail.
                 * @member {Array.<string>} recipientsEmail
                 * @memberof nebulaidl.admin.EmailMessage
                 * @instance
                 */
                EmailMessage.prototype.recipientsEmail = $util.emptyArray;
    
                /**
                 * EmailMessage senderEmail.
                 * @member {string} senderEmail
                 * @memberof nebulaidl.admin.EmailMessage
                 * @instance
                 */
                EmailMessage.prototype.senderEmail = "";
    
                /**
                 * EmailMessage subjectLine.
                 * @member {string} subjectLine
                 * @memberof nebulaidl.admin.EmailMessage
                 * @instance
                 */
                EmailMessage.prototype.subjectLine = "";
    
                /**
                 * EmailMessage body.
                 * @member {string} body
                 * @memberof nebulaidl.admin.EmailMessage
                 * @instance
                 */
                EmailMessage.prototype.body = "";
    
                /**
                 * Creates a new EmailMessage instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.EmailMessage
                 * @static
                 * @param {nebulaidl.admin.IEmailMessage=} [properties] Properties to set
                 * @returns {nebulaidl.admin.EmailMessage} EmailMessage instance
                 */
                EmailMessage.create = function create(properties) {
                    return new EmailMessage(properties);
                };
    
                /**
                 * Encodes the specified EmailMessage message. Does not implicitly {@link nebulaidl.admin.EmailMessage.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.EmailMessage
                 * @static
                 * @param {nebulaidl.admin.IEmailMessage} message EmailMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmailMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.recipientsEmail != null && message.recipientsEmail.length)
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientsEmail[i]);
                    if (message.senderEmail != null && message.hasOwnProperty("senderEmail"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.senderEmail);
                    if (message.subjectLine != null && message.hasOwnProperty("subjectLine"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.subjectLine);
                    if (message.body != null && message.hasOwnProperty("body"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.body);
                    return writer;
                };
    
                /**
                 * Decodes an EmailMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.EmailMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.EmailMessage} EmailMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmailMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.EmailMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.recipientsEmail && message.recipientsEmail.length))
                                message.recipientsEmail = [];
                            message.recipientsEmail.push(reader.string());
                            break;
                        case 2:
                            message.senderEmail = reader.string();
                            break;
                        case 3:
                            message.subjectLine = reader.string();
                            break;
                        case 4:
                            message.body = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EmailMessage message.
                 * @function verify
                 * @memberof nebulaidl.admin.EmailMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EmailMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.recipientsEmail != null && message.hasOwnProperty("recipientsEmail")) {
                        if (!Array.isArray(message.recipientsEmail))
                            return "recipientsEmail: array expected";
                        for (var i = 0; i < message.recipientsEmail.length; ++i)
                            if (!$util.isString(message.recipientsEmail[i]))
                                return "recipientsEmail: string[] expected";
                    }
                    if (message.senderEmail != null && message.hasOwnProperty("senderEmail"))
                        if (!$util.isString(message.senderEmail))
                            return "senderEmail: string expected";
                    if (message.subjectLine != null && message.hasOwnProperty("subjectLine"))
                        if (!$util.isString(message.subjectLine))
                            return "subjectLine: string expected";
                    if (message.body != null && message.hasOwnProperty("body"))
                        if (!$util.isString(message.body))
                            return "body: string expected";
                    return null;
                };
    
                return EmailMessage;
            })();
    
            admin.Domain = (function() {
    
                /**
                 * Properties of a Domain.
                 * @memberof nebulaidl.admin
                 * @interface IDomain
                 * @property {string|null} [id] Domain id
                 * @property {string|null} [name] Domain name
                 */
    
                /**
                 * Constructs a new Domain.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Domain.
                 * @implements IDomain
                 * @constructor
                 * @param {nebulaidl.admin.IDomain=} [properties] Properties to set
                 */
                function Domain(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Domain id.
                 * @member {string} id
                 * @memberof nebulaidl.admin.Domain
                 * @instance
                 */
                Domain.prototype.id = "";
    
                /**
                 * Domain name.
                 * @member {string} name
                 * @memberof nebulaidl.admin.Domain
                 * @instance
                 */
                Domain.prototype.name = "";
    
                /**
                 * Creates a new Domain instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Domain
                 * @static
                 * @param {nebulaidl.admin.IDomain=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Domain} Domain instance
                 */
                Domain.create = function create(properties) {
                    return new Domain(properties);
                };
    
                /**
                 * Encodes the specified Domain message. Does not implicitly {@link nebulaidl.admin.Domain.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Domain
                 * @static
                 * @param {nebulaidl.admin.IDomain} message Domain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Domain.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    return writer;
                };
    
                /**
                 * Decodes a Domain message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Domain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Domain} Domain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Domain.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Domain();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Domain message.
                 * @function verify
                 * @memberof nebulaidl.admin.Domain
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Domain.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };
    
                return Domain;
            })();
    
            admin.Project = (function() {
    
                /**
                 * Properties of a Project.
                 * @memberof nebulaidl.admin
                 * @interface IProject
                 * @property {string|null} [id] Project id
                 * @property {string|null} [name] Project name
                 * @property {Array.<nebulaidl.admin.IDomain>|null} [domains] Project domains
                 * @property {string|null} [description] Project description
                 * @property {nebulaidl.admin.ILabels|null} [labels] Project labels
                 * @property {nebulaidl.admin.Project.ProjectState|null} [state] Project state
                 */
    
                /**
                 * Constructs a new Project.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Project.
                 * @implements IProject
                 * @constructor
                 * @param {nebulaidl.admin.IProject=} [properties] Properties to set
                 */
                function Project(properties) {
                    this.domains = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Project id.
                 * @member {string} id
                 * @memberof nebulaidl.admin.Project
                 * @instance
                 */
                Project.prototype.id = "";
    
                /**
                 * Project name.
                 * @member {string} name
                 * @memberof nebulaidl.admin.Project
                 * @instance
                 */
                Project.prototype.name = "";
    
                /**
                 * Project domains.
                 * @member {Array.<nebulaidl.admin.IDomain>} domains
                 * @memberof nebulaidl.admin.Project
                 * @instance
                 */
                Project.prototype.domains = $util.emptyArray;
    
                /**
                 * Project description.
                 * @member {string} description
                 * @memberof nebulaidl.admin.Project
                 * @instance
                 */
                Project.prototype.description = "";
    
                /**
                 * Project labels.
                 * @member {nebulaidl.admin.ILabels|null|undefined} labels
                 * @memberof nebulaidl.admin.Project
                 * @instance
                 */
                Project.prototype.labels = null;
    
                /**
                 * Project state.
                 * @member {nebulaidl.admin.Project.ProjectState} state
                 * @memberof nebulaidl.admin.Project
                 * @instance
                 */
                Project.prototype.state = 0;
    
                /**
                 * Creates a new Project instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Project
                 * @static
                 * @param {nebulaidl.admin.IProject=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Project} Project instance
                 */
                Project.create = function create(properties) {
                    return new Project(properties);
                };
    
                /**
                 * Encodes the specified Project message. Does not implicitly {@link nebulaidl.admin.Project.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Project
                 * @static
                 * @param {nebulaidl.admin.IProject} message Project message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Project.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.domains != null && message.domains.length)
                        for (var i = 0; i < message.domains.length; ++i)
                            $root.nebulaidl.admin.Domain.encode(message.domains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        $root.nebulaidl.admin.Labels.encode(message.labels, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
                    return writer;
                };
    
                /**
                 * Decodes a Project message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Project
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Project} Project
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Project.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Project();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            if (!(message.domains && message.domains.length))
                                message.domains = [];
                            message.domains.push($root.nebulaidl.admin.Domain.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.description = reader.string();
                            break;
                        case 5:
                            message.labels = $root.nebulaidl.admin.Labels.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.state = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Project message.
                 * @function verify
                 * @memberof nebulaidl.admin.Project
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Project.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.domains != null && message.hasOwnProperty("domains")) {
                        if (!Array.isArray(message.domains))
                            return "domains: array expected";
                        for (var i = 0; i < message.domains.length; ++i) {
                            var error = $root.nebulaidl.admin.Domain.verify(message.domains[i]);
                            if (error)
                                return "domains." + error;
                        }
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        var error = $root.nebulaidl.admin.Labels.verify(message.labels);
                        if (error)
                            return "labels." + error;
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * ProjectState enum.
                 * @name nebulaidl.admin.Project.ProjectState
                 * @enum {string}
                 * @property {number} ACTIVE=0 ACTIVE value
                 * @property {number} ARCHIVED=1 ARCHIVED value
                 * @property {number} SYSTEM_GENERATED=2 SYSTEM_GENERATED value
                 */
                Project.ProjectState = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ACTIVE"] = 0;
                    values[valuesById[1] = "ARCHIVED"] = 1;
                    values[valuesById[2] = "SYSTEM_GENERATED"] = 2;
                    return values;
                })();
    
                return Project;
            })();
    
            admin.Projects = (function() {
    
                /**
                 * Properties of a Projects.
                 * @memberof nebulaidl.admin
                 * @interface IProjects
                 * @property {Array.<nebulaidl.admin.IProject>|null} [projects] Projects projects
                 * @property {string|null} [token] Projects token
                 */
    
                /**
                 * Constructs a new Projects.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Projects.
                 * @implements IProjects
                 * @constructor
                 * @param {nebulaidl.admin.IProjects=} [properties] Properties to set
                 */
                function Projects(properties) {
                    this.projects = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Projects projects.
                 * @member {Array.<nebulaidl.admin.IProject>} projects
                 * @memberof nebulaidl.admin.Projects
                 * @instance
                 */
                Projects.prototype.projects = $util.emptyArray;
    
                /**
                 * Projects token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.Projects
                 * @instance
                 */
                Projects.prototype.token = "";
    
                /**
                 * Creates a new Projects instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Projects
                 * @static
                 * @param {nebulaidl.admin.IProjects=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Projects} Projects instance
                 */
                Projects.create = function create(properties) {
                    return new Projects(properties);
                };
    
                /**
                 * Encodes the specified Projects message. Does not implicitly {@link nebulaidl.admin.Projects.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Projects
                 * @static
                 * @param {nebulaidl.admin.IProjects} message Projects message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Projects.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.projects != null && message.projects.length)
                        for (var i = 0; i < message.projects.length; ++i)
                            $root.nebulaidl.admin.Project.encode(message.projects[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a Projects message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Projects
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Projects} Projects
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Projects.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Projects();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.projects && message.projects.length))
                                message.projects = [];
                            message.projects.push($root.nebulaidl.admin.Project.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Projects message.
                 * @function verify
                 * @memberof nebulaidl.admin.Projects
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Projects.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.projects != null && message.hasOwnProperty("projects")) {
                        if (!Array.isArray(message.projects))
                            return "projects: array expected";
                        for (var i = 0; i < message.projects.length; ++i) {
                            var error = $root.nebulaidl.admin.Project.verify(message.projects[i]);
                            if (error)
                                return "projects." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return Projects;
            })();
    
            admin.ProjectListRequest = (function() {
    
                /**
                 * Properties of a ProjectListRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectListRequest
                 * @property {number|null} [limit] ProjectListRequest limit
                 * @property {string|null} [token] ProjectListRequest token
                 * @property {string|null} [filters] ProjectListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] ProjectListRequest sortBy
                 */
    
                /**
                 * Constructs a new ProjectListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectListRequest.
                 * @implements IProjectListRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectListRequest=} [properties] Properties to set
                 */
                function ProjectListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @instance
                 */
                ProjectListRequest.prototype.limit = 0;
    
                /**
                 * ProjectListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @instance
                 */
                ProjectListRequest.prototype.token = "";
    
                /**
                 * ProjectListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @instance
                 */
                ProjectListRequest.prototype.filters = "";
    
                /**
                 * ProjectListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @instance
                 */
                ProjectListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new ProjectListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectListRequest} ProjectListRequest instance
                 */
                ProjectListRequest.create = function create(properties) {
                    return new ProjectListRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectListRequest message. Does not implicitly {@link nebulaidl.admin.ProjectListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectListRequest} message ProjectListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectListRequest} ProjectListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.limit = reader.uint32();
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        case 3:
                            message.filters = reader.string();
                            break;
                        case 4:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return ProjectListRequest;
            })();
    
            admin.ProjectRegisterRequest = (function() {
    
                /**
                 * Properties of a ProjectRegisterRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectRegisterRequest
                 * @property {nebulaidl.admin.IProject|null} [project] ProjectRegisterRequest project
                 */
    
                /**
                 * Constructs a new ProjectRegisterRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectRegisterRequest.
                 * @implements IProjectRegisterRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectRegisterRequest=} [properties] Properties to set
                 */
                function ProjectRegisterRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectRegisterRequest project.
                 * @member {nebulaidl.admin.IProject|null|undefined} project
                 * @memberof nebulaidl.admin.ProjectRegisterRequest
                 * @instance
                 */
                ProjectRegisterRequest.prototype.project = null;
    
                /**
                 * Creates a new ProjectRegisterRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectRegisterRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectRegisterRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectRegisterRequest} ProjectRegisterRequest instance
                 */
                ProjectRegisterRequest.create = function create(properties) {
                    return new ProjectRegisterRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectRegisterRequest message. Does not implicitly {@link nebulaidl.admin.ProjectRegisterRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectRegisterRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectRegisterRequest} message ProjectRegisterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectRegisterRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        $root.nebulaidl.admin.Project.encode(message.project, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectRegisterRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectRegisterRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectRegisterRequest} ProjectRegisterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectRegisterRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectRegisterRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = $root.nebulaidl.admin.Project.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectRegisterRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectRegisterRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectRegisterRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project")) {
                        var error = $root.nebulaidl.admin.Project.verify(message.project);
                        if (error)
                            return "project." + error;
                    }
                    return null;
                };
    
                return ProjectRegisterRequest;
            })();
    
            admin.ProjectRegisterResponse = (function() {
    
                /**
                 * Properties of a ProjectRegisterResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectRegisterResponse
                 */
    
                /**
                 * Constructs a new ProjectRegisterResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectRegisterResponse.
                 * @implements IProjectRegisterResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectRegisterResponse=} [properties] Properties to set
                 */
                function ProjectRegisterResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ProjectRegisterResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectRegisterResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectRegisterResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectRegisterResponse} ProjectRegisterResponse instance
                 */
                ProjectRegisterResponse.create = function create(properties) {
                    return new ProjectRegisterResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectRegisterResponse message. Does not implicitly {@link nebulaidl.admin.ProjectRegisterResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectRegisterResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectRegisterResponse} message ProjectRegisterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectRegisterResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectRegisterResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectRegisterResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectRegisterResponse} ProjectRegisterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectRegisterResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectRegisterResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectRegisterResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectRegisterResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectRegisterResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ProjectRegisterResponse;
            })();
    
            admin.ProjectUpdateResponse = (function() {
    
                /**
                 * Properties of a ProjectUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectUpdateResponse
                 */
    
                /**
                 * Constructs a new ProjectUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectUpdateResponse.
                 * @implements IProjectUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectUpdateResponse=} [properties] Properties to set
                 */
                function ProjectUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ProjectUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectUpdateResponse} ProjectUpdateResponse instance
                 */
                ProjectUpdateResponse.create = function create(properties) {
                    return new ProjectUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectUpdateResponse message. Does not implicitly {@link nebulaidl.admin.ProjectUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectUpdateResponse} message ProjectUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectUpdateResponse} ProjectUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ProjectUpdateResponse;
            })();
    
            admin.ProjectAttributes = (function() {
    
                /**
                 * Properties of a ProjectAttributes.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributes
                 * @property {string|null} [project] ProjectAttributes project
                 * @property {nebulaidl.admin.IMatchingAttributes|null} [matchingAttributes] ProjectAttributes matchingAttributes
                 */
    
                /**
                 * Constructs a new ProjectAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributes.
                 * @implements IProjectAttributes
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributes=} [properties] Properties to set
                 */
                function ProjectAttributes(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectAttributes project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ProjectAttributes
                 * @instance
                 */
                ProjectAttributes.prototype.project = "";
    
                /**
                 * ProjectAttributes matchingAttributes.
                 * @member {nebulaidl.admin.IMatchingAttributes|null|undefined} matchingAttributes
                 * @memberof nebulaidl.admin.ProjectAttributes
                 * @instance
                 */
                ProjectAttributes.prototype.matchingAttributes = null;
    
                /**
                 * Creates a new ProjectAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributes
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributes} ProjectAttributes instance
                 */
                ProjectAttributes.create = function create(properties) {
                    return new ProjectAttributes(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributes message. Does not implicitly {@link nebulaidl.admin.ProjectAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributes
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributes} message ProjectAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes"))
                        $root.nebulaidl.admin.MatchingAttributes.encode(message.matchingAttributes, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributes} ProjectAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.matchingAttributes = $root.nebulaidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes")) {
                        var error = $root.nebulaidl.admin.MatchingAttributes.verify(message.matchingAttributes);
                        if (error)
                            return "matchingAttributes." + error;
                    }
                    return null;
                };
    
                return ProjectAttributes;
            })();
    
            admin.ProjectAttributesUpdateRequest = (function() {
    
                /**
                 * Properties of a ProjectAttributesUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributesUpdateRequest
                 * @property {nebulaidl.admin.IProjectAttributes|null} [attributes] ProjectAttributesUpdateRequest attributes
                 */
    
                /**
                 * Constructs a new ProjectAttributesUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributesUpdateRequest.
                 * @implements IProjectAttributesUpdateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributesUpdateRequest=} [properties] Properties to set
                 */
                function ProjectAttributesUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectAttributesUpdateRequest attributes.
                 * @member {nebulaidl.admin.IProjectAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateRequest
                 * @instance
                 */
                ProjectAttributesUpdateRequest.prototype.attributes = null;
    
                /**
                 * Creates a new ProjectAttributesUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesUpdateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributesUpdateRequest} ProjectAttributesUpdateRequest instance
                 */
                ProjectAttributesUpdateRequest.create = function create(properties) {
                    return new ProjectAttributesUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributesUpdateRequest message. Does not implicitly {@link nebulaidl.admin.ProjectAttributesUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesUpdateRequest} message ProjectAttributesUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributesUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.ProjectAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributesUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributesUpdateRequest} ProjectAttributesUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributesUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributesUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.ProjectAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributesUpdateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributesUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.ProjectAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };
    
                return ProjectAttributesUpdateRequest;
            })();
    
            admin.ProjectAttributesUpdateResponse = (function() {
    
                /**
                 * Properties of a ProjectAttributesUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributesUpdateResponse
                 */
    
                /**
                 * Constructs a new ProjectAttributesUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributesUpdateResponse.
                 * @implements IProjectAttributesUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributesUpdateResponse=} [properties] Properties to set
                 */
                function ProjectAttributesUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ProjectAttributesUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributesUpdateResponse} ProjectAttributesUpdateResponse instance
                 */
                ProjectAttributesUpdateResponse.create = function create(properties) {
                    return new ProjectAttributesUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributesUpdateResponse message. Does not implicitly {@link nebulaidl.admin.ProjectAttributesUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesUpdateResponse} message ProjectAttributesUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributesUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributesUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributesUpdateResponse} ProjectAttributesUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributesUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributesUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributesUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributesUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributesUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ProjectAttributesUpdateResponse;
            })();
    
            admin.ProjectAttributesGetRequest = (function() {
    
                /**
                 * Properties of a ProjectAttributesGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributesGetRequest
                 * @property {string|null} [project] ProjectAttributesGetRequest project
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] ProjectAttributesGetRequest resourceType
                 */
    
                /**
                 * Constructs a new ProjectAttributesGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributesGetRequest.
                 * @implements IProjectAttributesGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributesGetRequest=} [properties] Properties to set
                 */
                function ProjectAttributesGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectAttributesGetRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ProjectAttributesGetRequest
                 * @instance
                 */
                ProjectAttributesGetRequest.prototype.project = "";
    
                /**
                 * ProjectAttributesGetRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.ProjectAttributesGetRequest
                 * @instance
                 */
                ProjectAttributesGetRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new ProjectAttributesGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributesGetRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributesGetRequest} ProjectAttributesGetRequest instance
                 */
                ProjectAttributesGetRequest.create = function create(properties) {
                    return new ProjectAttributesGetRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributesGetRequest message. Does not implicitly {@link nebulaidl.admin.ProjectAttributesGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributesGetRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesGetRequest} message ProjectAttributesGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributesGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributesGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributesGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributesGetRequest} ProjectAttributesGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributesGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributesGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributesGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributesGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributesGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return ProjectAttributesGetRequest;
            })();
    
            admin.ProjectAttributesGetResponse = (function() {
    
                /**
                 * Properties of a ProjectAttributesGetResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributesGetResponse
                 * @property {nebulaidl.admin.IProjectAttributes|null} [attributes] ProjectAttributesGetResponse attributes
                 */
    
                /**
                 * Constructs a new ProjectAttributesGetResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributesGetResponse.
                 * @implements IProjectAttributesGetResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributesGetResponse=} [properties] Properties to set
                 */
                function ProjectAttributesGetResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectAttributesGetResponse attributes.
                 * @member {nebulaidl.admin.IProjectAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.ProjectAttributesGetResponse
                 * @instance
                 */
                ProjectAttributesGetResponse.prototype.attributes = null;
    
                /**
                 * Creates a new ProjectAttributesGetResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributesGetResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesGetResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributesGetResponse} ProjectAttributesGetResponse instance
                 */
                ProjectAttributesGetResponse.create = function create(properties) {
                    return new ProjectAttributesGetResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributesGetResponse message. Does not implicitly {@link nebulaidl.admin.ProjectAttributesGetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributesGetResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesGetResponse} message ProjectAttributesGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributesGetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.ProjectAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributesGetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributesGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributesGetResponse} ProjectAttributesGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributesGetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributesGetResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.ProjectAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributesGetResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributesGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributesGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.ProjectAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };
    
                return ProjectAttributesGetResponse;
            })();
    
            admin.ProjectAttributesDeleteRequest = (function() {
    
                /**
                 * Properties of a ProjectAttributesDeleteRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributesDeleteRequest
                 * @property {string|null} [project] ProjectAttributesDeleteRequest project
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] ProjectAttributesDeleteRequest resourceType
                 */
    
                /**
                 * Constructs a new ProjectAttributesDeleteRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributesDeleteRequest.
                 * @implements IProjectAttributesDeleteRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributesDeleteRequest=} [properties] Properties to set
                 */
                function ProjectAttributesDeleteRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectAttributesDeleteRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteRequest
                 * @instance
                 */
                ProjectAttributesDeleteRequest.prototype.project = "";
    
                /**
                 * ProjectAttributesDeleteRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteRequest
                 * @instance
                 */
                ProjectAttributesDeleteRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new ProjectAttributesDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesDeleteRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributesDeleteRequest} ProjectAttributesDeleteRequest instance
                 */
                ProjectAttributesDeleteRequest.create = function create(properties) {
                    return new ProjectAttributesDeleteRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributesDeleteRequest message. Does not implicitly {@link nebulaidl.admin.ProjectAttributesDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesDeleteRequest} message ProjectAttributesDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributesDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributesDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributesDeleteRequest} ProjectAttributesDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributesDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributesDeleteRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributesDeleteRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributesDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return ProjectAttributesDeleteRequest;
            })();
    
            admin.ProjectAttributesDeleteResponse = (function() {
    
                /**
                 * Properties of a ProjectAttributesDeleteResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectAttributesDeleteResponse
                 */
    
                /**
                 * Constructs a new ProjectAttributesDeleteResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectAttributesDeleteResponse.
                 * @implements IProjectAttributesDeleteResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectAttributesDeleteResponse=} [properties] Properties to set
                 */
                function ProjectAttributesDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ProjectAttributesDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesDeleteResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectAttributesDeleteResponse} ProjectAttributesDeleteResponse instance
                 */
                ProjectAttributesDeleteResponse.create = function create(properties) {
                    return new ProjectAttributesDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectAttributesDeleteResponse message. Does not implicitly {@link nebulaidl.admin.ProjectAttributesDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectAttributesDeleteResponse} message ProjectAttributesDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectAttributesDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectAttributesDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectAttributesDeleteResponse} ProjectAttributesDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectAttributesDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectAttributesDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectAttributesDeleteResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectAttributesDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectAttributesDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ProjectAttributesDeleteResponse;
            })();
    
            admin.ProjectDomainAttributes = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributes.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributes
                 * @property {string|null} [project] ProjectDomainAttributes project
                 * @property {string|null} [domain] ProjectDomainAttributes domain
                 * @property {nebulaidl.admin.IMatchingAttributes|null} [matchingAttributes] ProjectDomainAttributes matchingAttributes
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributes.
                 * @implements IProjectDomainAttributes
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributes=} [properties] Properties to set
                 */
                function ProjectDomainAttributes(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectDomainAttributes project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @instance
                 */
                ProjectDomainAttributes.prototype.project = "";
    
                /**
                 * ProjectDomainAttributes domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @instance
                 */
                ProjectDomainAttributes.prototype.domain = "";
    
                /**
                 * ProjectDomainAttributes matchingAttributes.
                 * @member {nebulaidl.admin.IMatchingAttributes|null|undefined} matchingAttributes
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @instance
                 */
                ProjectDomainAttributes.prototype.matchingAttributes = null;
    
                /**
                 * Creates a new ProjectDomainAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributes} ProjectDomainAttributes instance
                 */
                ProjectDomainAttributes.create = function create(properties) {
                    return new ProjectDomainAttributes(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributes message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributes} message ProjectDomainAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes"))
                        $root.nebulaidl.admin.MatchingAttributes.encode(message.matchingAttributes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributes} ProjectDomainAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.matchingAttributes = $root.nebulaidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes")) {
                        var error = $root.nebulaidl.admin.MatchingAttributes.verify(message.matchingAttributes);
                        if (error)
                            return "matchingAttributes." + error;
                    }
                    return null;
                };
    
                return ProjectDomainAttributes;
            })();
    
            admin.ProjectDomainAttributesUpdateRequest = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributesUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributesUpdateRequest
                 * @property {nebulaidl.admin.IProjectDomainAttributes|null} [attributes] ProjectDomainAttributesUpdateRequest attributes
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributesUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributesUpdateRequest.
                 * @implements IProjectDomainAttributesUpdateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateRequest=} [properties] Properties to set
                 */
                function ProjectDomainAttributesUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectDomainAttributesUpdateRequest attributes.
                 * @member {nebulaidl.admin.IProjectDomainAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateRequest
                 * @instance
                 */
                ProjectDomainAttributesUpdateRequest.prototype.attributes = null;
    
                /**
                 * Creates a new ProjectDomainAttributesUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributesUpdateRequest} ProjectDomainAttributesUpdateRequest instance
                 */
                ProjectDomainAttributesUpdateRequest.create = function create(properties) {
                    return new ProjectDomainAttributesUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributesUpdateRequest message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributesUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateRequest} message ProjectDomainAttributesUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributesUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.ProjectDomainAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributesUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributesUpdateRequest} ProjectDomainAttributesUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributesUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributesUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.ProjectDomainAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributesUpdateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributesUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.ProjectDomainAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };
    
                return ProjectDomainAttributesUpdateRequest;
            })();
    
            admin.ProjectDomainAttributesUpdateResponse = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributesUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributesUpdateResponse
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributesUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributesUpdateResponse.
                 * @implements IProjectDomainAttributesUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateResponse=} [properties] Properties to set
                 */
                function ProjectDomainAttributesUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ProjectDomainAttributesUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributesUpdateResponse} ProjectDomainAttributesUpdateResponse instance
                 */
                ProjectDomainAttributesUpdateResponse.create = function create(properties) {
                    return new ProjectDomainAttributesUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributesUpdateResponse message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributesUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateResponse} message ProjectDomainAttributesUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributesUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributesUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributesUpdateResponse} ProjectDomainAttributesUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributesUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributesUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributesUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributesUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributesUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ProjectDomainAttributesUpdateResponse;
            })();
    
            admin.ProjectDomainAttributesGetRequest = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributesGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributesGetRequest
                 * @property {string|null} [project] ProjectDomainAttributesGetRequest project
                 * @property {string|null} [domain] ProjectDomainAttributesGetRequest domain
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] ProjectDomainAttributesGetRequest resourceType
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributesGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributesGetRequest.
                 * @implements IProjectDomainAttributesGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetRequest=} [properties] Properties to set
                 */
                function ProjectDomainAttributesGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectDomainAttributesGetRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @instance
                 */
                ProjectDomainAttributesGetRequest.prototype.project = "";
    
                /**
                 * ProjectDomainAttributesGetRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @instance
                 */
                ProjectDomainAttributesGetRequest.prototype.domain = "";
    
                /**
                 * ProjectDomainAttributesGetRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @instance
                 */
                ProjectDomainAttributesGetRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new ProjectDomainAttributesGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributesGetRequest} ProjectDomainAttributesGetRequest instance
                 */
                ProjectDomainAttributesGetRequest.create = function create(properties) {
                    return new ProjectDomainAttributesGetRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributesGetRequest message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributesGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetRequest} message ProjectDomainAttributesGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributesGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributesGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributesGetRequest} ProjectDomainAttributesGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributesGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributesGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributesGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributesGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return ProjectDomainAttributesGetRequest;
            })();
    
            admin.ProjectDomainAttributesGetResponse = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributesGetResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributesGetResponse
                 * @property {nebulaidl.admin.IProjectDomainAttributes|null} [attributes] ProjectDomainAttributesGetResponse attributes
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributesGetResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributesGetResponse.
                 * @implements IProjectDomainAttributesGetResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetResponse=} [properties] Properties to set
                 */
                function ProjectDomainAttributesGetResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectDomainAttributesGetResponse attributes.
                 * @member {nebulaidl.admin.IProjectDomainAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetResponse
                 * @instance
                 */
                ProjectDomainAttributesGetResponse.prototype.attributes = null;
    
                /**
                 * Creates a new ProjectDomainAttributesGetResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributesGetResponse} ProjectDomainAttributesGetResponse instance
                 */
                ProjectDomainAttributesGetResponse.create = function create(properties) {
                    return new ProjectDomainAttributesGetResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributesGetResponse message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributesGetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetResponse} message ProjectDomainAttributesGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributesGetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.ProjectDomainAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributesGetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributesGetResponse} ProjectDomainAttributesGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributesGetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributesGetResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.ProjectDomainAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributesGetResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributesGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributesGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.ProjectDomainAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };
    
                return ProjectDomainAttributesGetResponse;
            })();
    
            admin.ProjectDomainAttributesDeleteRequest = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributesDeleteRequest.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributesDeleteRequest
                 * @property {string|null} [project] ProjectDomainAttributesDeleteRequest project
                 * @property {string|null} [domain] ProjectDomainAttributesDeleteRequest domain
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] ProjectDomainAttributesDeleteRequest resourceType
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributesDeleteRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributesDeleteRequest.
                 * @implements IProjectDomainAttributesDeleteRequest
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteRequest=} [properties] Properties to set
                 */
                function ProjectDomainAttributesDeleteRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProjectDomainAttributesDeleteRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @instance
                 */
                ProjectDomainAttributesDeleteRequest.prototype.project = "";
    
                /**
                 * ProjectDomainAttributesDeleteRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @instance
                 */
                ProjectDomainAttributesDeleteRequest.prototype.domain = "";
    
                /**
                 * ProjectDomainAttributesDeleteRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @instance
                 */
                ProjectDomainAttributesDeleteRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new ProjectDomainAttributesDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributesDeleteRequest} ProjectDomainAttributesDeleteRequest instance
                 */
                ProjectDomainAttributesDeleteRequest.create = function create(properties) {
                    return new ProjectDomainAttributesDeleteRequest(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributesDeleteRequest message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributesDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteRequest} message ProjectDomainAttributesDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributesDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributesDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributesDeleteRequest} ProjectDomainAttributesDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributesDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributesDeleteRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributesDeleteRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributesDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return ProjectDomainAttributesDeleteRequest;
            })();
    
            admin.ProjectDomainAttributesDeleteResponse = (function() {
    
                /**
                 * Properties of a ProjectDomainAttributesDeleteResponse.
                 * @memberof nebulaidl.admin
                 * @interface IProjectDomainAttributesDeleteResponse
                 */
    
                /**
                 * Constructs a new ProjectDomainAttributesDeleteResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a ProjectDomainAttributesDeleteResponse.
                 * @implements IProjectDomainAttributesDeleteResponse
                 * @constructor
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteResponse=} [properties] Properties to set
                 */
                function ProjectDomainAttributesDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ProjectDomainAttributesDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.ProjectDomainAttributesDeleteResponse} ProjectDomainAttributesDeleteResponse instance
                 */
                ProjectDomainAttributesDeleteResponse.create = function create(properties) {
                    return new ProjectDomainAttributesDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified ProjectDomainAttributesDeleteResponse message. Does not implicitly {@link nebulaidl.admin.ProjectDomainAttributesDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteResponse
                 * @static
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteResponse} message ProjectDomainAttributesDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProjectDomainAttributesDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ProjectDomainAttributesDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.ProjectDomainAttributesDeleteResponse} ProjectDomainAttributesDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProjectDomainAttributesDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.ProjectDomainAttributesDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ProjectDomainAttributesDeleteResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.ProjectDomainAttributesDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectDomainAttributesDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return ProjectDomainAttributesDeleteResponse;
            })();
    
            admin.SignalGetOrCreateRequest = (function() {
    
                /**
                 * Properties of a SignalGetOrCreateRequest.
                 * @memberof nebulaidl.admin
                 * @interface ISignalGetOrCreateRequest
                 * @property {nebulaidl.core.ISignalIdentifier|null} [id] SignalGetOrCreateRequest id
                 * @property {nebulaidl.core.ILiteralType|null} [type] SignalGetOrCreateRequest type
                 */
    
                /**
                 * Constructs a new SignalGetOrCreateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SignalGetOrCreateRequest.
                 * @implements ISignalGetOrCreateRequest
                 * @constructor
                 * @param {nebulaidl.admin.ISignalGetOrCreateRequest=} [properties] Properties to set
                 */
                function SignalGetOrCreateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SignalGetOrCreateRequest id.
                 * @member {nebulaidl.core.ISignalIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.SignalGetOrCreateRequest
                 * @instance
                 */
                SignalGetOrCreateRequest.prototype.id = null;
    
                /**
                 * SignalGetOrCreateRequest type.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} type
                 * @memberof nebulaidl.admin.SignalGetOrCreateRequest
                 * @instance
                 */
                SignalGetOrCreateRequest.prototype.type = null;
    
                /**
                 * Creates a new SignalGetOrCreateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SignalGetOrCreateRequest
                 * @static
                 * @param {nebulaidl.admin.ISignalGetOrCreateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SignalGetOrCreateRequest} SignalGetOrCreateRequest instance
                 */
                SignalGetOrCreateRequest.create = function create(properties) {
                    return new SignalGetOrCreateRequest(properties);
                };
    
                /**
                 * Encodes the specified SignalGetOrCreateRequest message. Does not implicitly {@link nebulaidl.admin.SignalGetOrCreateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SignalGetOrCreateRequest
                 * @static
                 * @param {nebulaidl.admin.ISignalGetOrCreateRequest} message SignalGetOrCreateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalGetOrCreateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.SignalIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.LiteralType.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SignalGetOrCreateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SignalGetOrCreateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SignalGetOrCreateRequest} SignalGetOrCreateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalGetOrCreateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SignalGetOrCreateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.SignalIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.type = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalGetOrCreateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.SignalGetOrCreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalGetOrCreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.SignalIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.LiteralType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    return null;
                };
    
                return SignalGetOrCreateRequest;
            })();
    
            admin.SignalListRequest = (function() {
    
                /**
                 * Properties of a SignalListRequest.
                 * @memberof nebulaidl.admin
                 * @interface ISignalListRequest
                 * @property {nebulaidl.core.IWorkflowExecutionIdentifier|null} [workflowExecutionId] SignalListRequest workflowExecutionId
                 * @property {number|null} [limit] SignalListRequest limit
                 * @property {string|null} [token] SignalListRequest token
                 * @property {string|null} [filters] SignalListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] SignalListRequest sortBy
                 */
    
                /**
                 * Constructs a new SignalListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SignalListRequest.
                 * @implements ISignalListRequest
                 * @constructor
                 * @param {nebulaidl.admin.ISignalListRequest=} [properties] Properties to set
                 */
                function SignalListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SignalListRequest workflowExecutionId.
                 * @member {nebulaidl.core.IWorkflowExecutionIdentifier|null|undefined} workflowExecutionId
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @instance
                 */
                SignalListRequest.prototype.workflowExecutionId = null;
    
                /**
                 * SignalListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @instance
                 */
                SignalListRequest.prototype.limit = 0;
    
                /**
                 * SignalListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @instance
                 */
                SignalListRequest.prototype.token = "";
    
                /**
                 * SignalListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @instance
                 */
                SignalListRequest.prototype.filters = "";
    
                /**
                 * SignalListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @instance
                 */
                SignalListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new SignalListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @static
                 * @param {nebulaidl.admin.ISignalListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SignalListRequest} SignalListRequest instance
                 */
                SignalListRequest.create = function create(properties) {
                    return new SignalListRequest(properties);
                };
    
                /**
                 * Encodes the specified SignalListRequest message. Does not implicitly {@link nebulaidl.admin.SignalListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @static
                 * @param {nebulaidl.admin.ISignalListRequest} message SignalListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.workflowExecutionId != null && message.hasOwnProperty("workflowExecutionId"))
                        $root.nebulaidl.core.WorkflowExecutionIdentifier.encode(message.workflowExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SignalListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SignalListRequest} SignalListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SignalListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.workflowExecutionId = $root.nebulaidl.core.WorkflowExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.limit = reader.uint32();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.filters = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.SignalListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.workflowExecutionId != null && message.hasOwnProperty("workflowExecutionId")) {
                        var error = $root.nebulaidl.core.WorkflowExecutionIdentifier.verify(message.workflowExecutionId);
                        if (error)
                            return "workflowExecutionId." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return SignalListRequest;
            })();
    
            admin.SignalList = (function() {
    
                /**
                 * Properties of a SignalList.
                 * @memberof nebulaidl.admin
                 * @interface ISignalList
                 * @property {Array.<nebulaidl.admin.ISignal>|null} [signals] SignalList signals
                 * @property {string|null} [token] SignalList token
                 */
    
                /**
                 * Constructs a new SignalList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SignalList.
                 * @implements ISignalList
                 * @constructor
                 * @param {nebulaidl.admin.ISignalList=} [properties] Properties to set
                 */
                function SignalList(properties) {
                    this.signals = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SignalList signals.
                 * @member {Array.<nebulaidl.admin.ISignal>} signals
                 * @memberof nebulaidl.admin.SignalList
                 * @instance
                 */
                SignalList.prototype.signals = $util.emptyArray;
    
                /**
                 * SignalList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.SignalList
                 * @instance
                 */
                SignalList.prototype.token = "";
    
                /**
                 * Creates a new SignalList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SignalList
                 * @static
                 * @param {nebulaidl.admin.ISignalList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SignalList} SignalList instance
                 */
                SignalList.create = function create(properties) {
                    return new SignalList(properties);
                };
    
                /**
                 * Encodes the specified SignalList message. Does not implicitly {@link nebulaidl.admin.SignalList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SignalList
                 * @static
                 * @param {nebulaidl.admin.ISignalList} message SignalList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signals != null && message.signals.length)
                        for (var i = 0; i < message.signals.length; ++i)
                            $root.nebulaidl.admin.Signal.encode(message.signals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a SignalList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SignalList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SignalList} SignalList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SignalList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.signals && message.signals.length))
                                message.signals = [];
                            message.signals.push($root.nebulaidl.admin.Signal.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalList message.
                 * @function verify
                 * @memberof nebulaidl.admin.SignalList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signals != null && message.hasOwnProperty("signals")) {
                        if (!Array.isArray(message.signals))
                            return "signals: array expected";
                        for (var i = 0; i < message.signals.length; ++i) {
                            var error = $root.nebulaidl.admin.Signal.verify(message.signals[i]);
                            if (error)
                                return "signals." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return SignalList;
            })();
    
            admin.SignalSetRequest = (function() {
    
                /**
                 * Properties of a SignalSetRequest.
                 * @memberof nebulaidl.admin
                 * @interface ISignalSetRequest
                 * @property {nebulaidl.core.ISignalIdentifier|null} [id] SignalSetRequest id
                 * @property {nebulaidl.core.ILiteral|null} [value] SignalSetRequest value
                 */
    
                /**
                 * Constructs a new SignalSetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SignalSetRequest.
                 * @implements ISignalSetRequest
                 * @constructor
                 * @param {nebulaidl.admin.ISignalSetRequest=} [properties] Properties to set
                 */
                function SignalSetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SignalSetRequest id.
                 * @member {nebulaidl.core.ISignalIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.SignalSetRequest
                 * @instance
                 */
                SignalSetRequest.prototype.id = null;
    
                /**
                 * SignalSetRequest value.
                 * @member {nebulaidl.core.ILiteral|null|undefined} value
                 * @memberof nebulaidl.admin.SignalSetRequest
                 * @instance
                 */
                SignalSetRequest.prototype.value = null;
    
                /**
                 * Creates a new SignalSetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SignalSetRequest
                 * @static
                 * @param {nebulaidl.admin.ISignalSetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SignalSetRequest} SignalSetRequest instance
                 */
                SignalSetRequest.create = function create(properties) {
                    return new SignalSetRequest(properties);
                };
    
                /**
                 * Encodes the specified SignalSetRequest message. Does not implicitly {@link nebulaidl.admin.SignalSetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SignalSetRequest
                 * @static
                 * @param {nebulaidl.admin.ISignalSetRequest} message SignalSetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalSetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.SignalIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.value != null && message.hasOwnProperty("value"))
                        $root.nebulaidl.core.Literal.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SignalSetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SignalSetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SignalSetRequest} SignalSetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalSetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SignalSetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.SignalIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.value = $root.nebulaidl.core.Literal.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalSetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.SignalSetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalSetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.SignalIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.nebulaidl.core.Literal.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                return SignalSetRequest;
            })();
    
            admin.SignalSetResponse = (function() {
    
                /**
                 * Properties of a SignalSetResponse.
                 * @memberof nebulaidl.admin
                 * @interface ISignalSetResponse
                 */
    
                /**
                 * Constructs a new SignalSetResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a SignalSetResponse.
                 * @implements ISignalSetResponse
                 * @constructor
                 * @param {nebulaidl.admin.ISignalSetResponse=} [properties] Properties to set
                 */
                function SignalSetResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SignalSetResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.SignalSetResponse
                 * @static
                 * @param {nebulaidl.admin.ISignalSetResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.SignalSetResponse} SignalSetResponse instance
                 */
                SignalSetResponse.create = function create(properties) {
                    return new SignalSetResponse(properties);
                };
    
                /**
                 * Encodes the specified SignalSetResponse message. Does not implicitly {@link nebulaidl.admin.SignalSetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.SignalSetResponse
                 * @static
                 * @param {nebulaidl.admin.ISignalSetResponse} message SignalSetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignalSetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SignalSetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.SignalSetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.SignalSetResponse} SignalSetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignalSetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.SignalSetResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SignalSetResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.SignalSetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SignalSetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return SignalSetResponse;
            })();
    
            admin.Signal = (function() {
    
                /**
                 * Properties of a Signal.
                 * @memberof nebulaidl.admin
                 * @interface ISignal
                 * @property {nebulaidl.core.ISignalIdentifier|null} [id] Signal id
                 * @property {nebulaidl.core.ILiteralType|null} [type] Signal type
                 * @property {nebulaidl.core.ILiteral|null} [value] Signal value
                 */
    
                /**
                 * Constructs a new Signal.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Signal.
                 * @implements ISignal
                 * @constructor
                 * @param {nebulaidl.admin.ISignal=} [properties] Properties to set
                 */
                function Signal(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Signal id.
                 * @member {nebulaidl.core.ISignalIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.Signal
                 * @instance
                 */
                Signal.prototype.id = null;
    
                /**
                 * Signal type.
                 * @member {nebulaidl.core.ILiteralType|null|undefined} type
                 * @memberof nebulaidl.admin.Signal
                 * @instance
                 */
                Signal.prototype.type = null;
    
                /**
                 * Signal value.
                 * @member {nebulaidl.core.ILiteral|null|undefined} value
                 * @memberof nebulaidl.admin.Signal
                 * @instance
                 */
                Signal.prototype.value = null;
    
                /**
                 * Creates a new Signal instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Signal
                 * @static
                 * @param {nebulaidl.admin.ISignal=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Signal} Signal instance
                 */
                Signal.create = function create(properties) {
                    return new Signal(properties);
                };
    
                /**
                 * Encodes the specified Signal message. Does not implicitly {@link nebulaidl.admin.Signal.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Signal
                 * @static
                 * @param {nebulaidl.admin.ISignal} message Signal message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Signal.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.SignalIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.nebulaidl.core.LiteralType.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.value != null && message.hasOwnProperty("value"))
                        $root.nebulaidl.core.Literal.encode(message.value, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Signal message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Signal
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Signal} Signal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Signal.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Signal();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.SignalIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.type = $root.nebulaidl.core.LiteralType.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.value = $root.nebulaidl.core.Literal.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Signal message.
                 * @function verify
                 * @memberof nebulaidl.admin.Signal
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Signal.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.SignalIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.nebulaidl.core.LiteralType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.nebulaidl.core.Literal.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                return Signal;
            })();
    
            admin.TaskCreateRequest = (function() {
    
                /**
                 * Properties of a TaskCreateRequest.
                 * @memberof nebulaidl.admin
                 * @interface ITaskCreateRequest
                 * @property {nebulaidl.core.IIdentifier|null} [id] TaskCreateRequest id
                 * @property {nebulaidl.admin.ITaskSpec|null} [spec] TaskCreateRequest spec
                 */
    
                /**
                 * Constructs a new TaskCreateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskCreateRequest.
                 * @implements ITaskCreateRequest
                 * @constructor
                 * @param {nebulaidl.admin.ITaskCreateRequest=} [properties] Properties to set
                 */
                function TaskCreateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskCreateRequest id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.TaskCreateRequest
                 * @instance
                 */
                TaskCreateRequest.prototype.id = null;
    
                /**
                 * TaskCreateRequest spec.
                 * @member {nebulaidl.admin.ITaskSpec|null|undefined} spec
                 * @memberof nebulaidl.admin.TaskCreateRequest
                 * @instance
                 */
                TaskCreateRequest.prototype.spec = null;
    
                /**
                 * Creates a new TaskCreateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskCreateRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskCreateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskCreateRequest} TaskCreateRequest instance
                 */
                TaskCreateRequest.create = function create(properties) {
                    return new TaskCreateRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskCreateRequest message. Does not implicitly {@link nebulaidl.admin.TaskCreateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskCreateRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskCreateRequest} message TaskCreateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskCreateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.admin.TaskSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskCreateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskCreateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskCreateRequest} TaskCreateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskCreateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskCreateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.spec = $root.nebulaidl.admin.TaskSpec.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskCreateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskCreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskCreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.nebulaidl.admin.TaskSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    return null;
                };
    
                return TaskCreateRequest;
            })();
    
            admin.TaskCreateResponse = (function() {
    
                /**
                 * Properties of a TaskCreateResponse.
                 * @memberof nebulaidl.admin
                 * @interface ITaskCreateResponse
                 */
    
                /**
                 * Constructs a new TaskCreateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskCreateResponse.
                 * @implements ITaskCreateResponse
                 * @constructor
                 * @param {nebulaidl.admin.ITaskCreateResponse=} [properties] Properties to set
                 */
                function TaskCreateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new TaskCreateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskCreateResponse
                 * @static
                 * @param {nebulaidl.admin.ITaskCreateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskCreateResponse} TaskCreateResponse instance
                 */
                TaskCreateResponse.create = function create(properties) {
                    return new TaskCreateResponse(properties);
                };
    
                /**
                 * Encodes the specified TaskCreateResponse message. Does not implicitly {@link nebulaidl.admin.TaskCreateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskCreateResponse
                 * @static
                 * @param {nebulaidl.admin.ITaskCreateResponse} message TaskCreateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskCreateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a TaskCreateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskCreateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskCreateResponse} TaskCreateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskCreateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskCreateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskCreateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskCreateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskCreateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return TaskCreateResponse;
            })();
    
            admin.Task = (function() {
    
                /**
                 * Properties of a Task.
                 * @memberof nebulaidl.admin
                 * @interface ITask
                 * @property {nebulaidl.core.IIdentifier|null} [id] Task id
                 * @property {nebulaidl.admin.ITaskClosure|null} [closure] Task closure
                 * @property {string|null} [shortDescription] Task shortDescription
                 */
    
                /**
                 * Constructs a new Task.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Task.
                 * @implements ITask
                 * @constructor
                 * @param {nebulaidl.admin.ITask=} [properties] Properties to set
                 */
                function Task(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Task id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.Task
                 * @instance
                 */
                Task.prototype.id = null;
    
                /**
                 * Task closure.
                 * @member {nebulaidl.admin.ITaskClosure|null|undefined} closure
                 * @memberof nebulaidl.admin.Task
                 * @instance
                 */
                Task.prototype.closure = null;
    
                /**
                 * Task shortDescription.
                 * @member {string} shortDescription
                 * @memberof nebulaidl.admin.Task
                 * @instance
                 */
                Task.prototype.shortDescription = "";
    
                /**
                 * Creates a new Task instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Task
                 * @static
                 * @param {nebulaidl.admin.ITask=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Task} Task instance
                 */
                Task.create = function create(properties) {
                    return new Task(properties);
                };
    
                /**
                 * Encodes the specified Task message. Does not implicitly {@link nebulaidl.admin.Task.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Task
                 * @static
                 * @param {nebulaidl.admin.ITask} message Task message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Task.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.closure != null && message.hasOwnProperty("closure"))
                        $root.nebulaidl.admin.TaskClosure.encode(message.closure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.shortDescription);
                    return writer;
                };
    
                /**
                 * Decodes a Task message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Task
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Task} Task
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Task.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Task();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.closure = $root.nebulaidl.admin.TaskClosure.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.shortDescription = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Task message.
                 * @function verify
                 * @memberof nebulaidl.admin.Task
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Task.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.closure != null && message.hasOwnProperty("closure")) {
                        var error = $root.nebulaidl.admin.TaskClosure.verify(message.closure);
                        if (error)
                            return "closure." + error;
                    }
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    return null;
                };
    
                return Task;
            })();
    
            admin.TaskList = (function() {
    
                /**
                 * Properties of a TaskList.
                 * @memberof nebulaidl.admin
                 * @interface ITaskList
                 * @property {Array.<nebulaidl.admin.ITask>|null} [tasks] TaskList tasks
                 * @property {string|null} [token] TaskList token
                 */
    
                /**
                 * Constructs a new TaskList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskList.
                 * @implements ITaskList
                 * @constructor
                 * @param {nebulaidl.admin.ITaskList=} [properties] Properties to set
                 */
                function TaskList(properties) {
                    this.tasks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskList tasks.
                 * @member {Array.<nebulaidl.admin.ITask>} tasks
                 * @memberof nebulaidl.admin.TaskList
                 * @instance
                 */
                TaskList.prototype.tasks = $util.emptyArray;
    
                /**
                 * TaskList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.TaskList
                 * @instance
                 */
                TaskList.prototype.token = "";
    
                /**
                 * Creates a new TaskList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskList
                 * @static
                 * @param {nebulaidl.admin.ITaskList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskList} TaskList instance
                 */
                TaskList.create = function create(properties) {
                    return new TaskList(properties);
                };
    
                /**
                 * Encodes the specified TaskList message. Does not implicitly {@link nebulaidl.admin.TaskList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskList
                 * @static
                 * @param {nebulaidl.admin.ITaskList} message TaskList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tasks != null && message.tasks.length)
                        for (var i = 0; i < message.tasks.length; ++i)
                            $root.nebulaidl.admin.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a TaskList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskList} TaskList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.nebulaidl.admin.Task.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskList message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (var i = 0; i < message.tasks.length; ++i) {
                            var error = $root.nebulaidl.admin.Task.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return TaskList;
            })();
    
            admin.TaskSpec = (function() {
    
                /**
                 * Properties of a TaskSpec.
                 * @memberof nebulaidl.admin
                 * @interface ITaskSpec
                 * @property {nebulaidl.core.ITaskTemplate|null} [template] TaskSpec template
                 * @property {nebulaidl.admin.IDescriptionEntity|null} [description] TaskSpec description
                 */
    
                /**
                 * Constructs a new TaskSpec.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskSpec.
                 * @implements ITaskSpec
                 * @constructor
                 * @param {nebulaidl.admin.ITaskSpec=} [properties] Properties to set
                 */
                function TaskSpec(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskSpec template.
                 * @member {nebulaidl.core.ITaskTemplate|null|undefined} template
                 * @memberof nebulaidl.admin.TaskSpec
                 * @instance
                 */
                TaskSpec.prototype.template = null;
    
                /**
                 * TaskSpec description.
                 * @member {nebulaidl.admin.IDescriptionEntity|null|undefined} description
                 * @memberof nebulaidl.admin.TaskSpec
                 * @instance
                 */
                TaskSpec.prototype.description = null;
    
                /**
                 * Creates a new TaskSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskSpec
                 * @static
                 * @param {nebulaidl.admin.ITaskSpec=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskSpec} TaskSpec instance
                 */
                TaskSpec.create = function create(properties) {
                    return new TaskSpec(properties);
                };
    
                /**
                 * Encodes the specified TaskSpec message. Does not implicitly {@link nebulaidl.admin.TaskSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskSpec
                 * @static
                 * @param {nebulaidl.admin.ITaskSpec} message TaskSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.template != null && message.hasOwnProperty("template"))
                        $root.nebulaidl.core.TaskTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.description != null && message.hasOwnProperty("description"))
                        $root.nebulaidl.admin.DescriptionEntity.encode(message.description, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskSpec} TaskSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.template = $root.nebulaidl.core.TaskTemplate.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.description = $root.nebulaidl.admin.DescriptionEntity.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskSpec message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.template != null && message.hasOwnProperty("template")) {
                        var error = $root.nebulaidl.core.TaskTemplate.verify(message.template);
                        if (error)
                            return "template." + error;
                    }
                    if (message.description != null && message.hasOwnProperty("description")) {
                        var error = $root.nebulaidl.admin.DescriptionEntity.verify(message.description);
                        if (error)
                            return "description." + error;
                    }
                    return null;
                };
    
                return TaskSpec;
            })();
    
            admin.TaskClosure = (function() {
    
                /**
                 * Properties of a TaskClosure.
                 * @memberof nebulaidl.admin
                 * @interface ITaskClosure
                 * @property {nebulaidl.core.ICompiledTask|null} [compiledTask] TaskClosure compiledTask
                 * @property {google.protobuf.ITimestamp|null} [createdAt] TaskClosure createdAt
                 */
    
                /**
                 * Constructs a new TaskClosure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskClosure.
                 * @implements ITaskClosure
                 * @constructor
                 * @param {nebulaidl.admin.ITaskClosure=} [properties] Properties to set
                 */
                function TaskClosure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskClosure compiledTask.
                 * @member {nebulaidl.core.ICompiledTask|null|undefined} compiledTask
                 * @memberof nebulaidl.admin.TaskClosure
                 * @instance
                 */
                TaskClosure.prototype.compiledTask = null;
    
                /**
                 * TaskClosure createdAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} createdAt
                 * @memberof nebulaidl.admin.TaskClosure
                 * @instance
                 */
                TaskClosure.prototype.createdAt = null;
    
                /**
                 * Creates a new TaskClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskClosure
                 * @static
                 * @param {nebulaidl.admin.ITaskClosure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskClosure} TaskClosure instance
                 */
                TaskClosure.create = function create(properties) {
                    return new TaskClosure(properties);
                };
    
                /**
                 * Encodes the specified TaskClosure message. Does not implicitly {@link nebulaidl.admin.TaskClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskClosure
                 * @static
                 * @param {nebulaidl.admin.ITaskClosure} message TaskClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.compiledTask != null && message.hasOwnProperty("compiledTask"))
                        $root.nebulaidl.core.CompiledTask.encode(message.compiledTask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskClosure} TaskClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.compiledTask = $root.nebulaidl.core.CompiledTask.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskClosure message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.compiledTask != null && message.hasOwnProperty("compiledTask")) {
                        var error = $root.nebulaidl.core.CompiledTask.verify(message.compiledTask);
                        if (error)
                            return "compiledTask." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    return null;
                };
    
                return TaskClosure;
            })();
    
            admin.TaskExecutionGetRequest = (function() {
    
                /**
                 * Properties of a TaskExecutionGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionGetRequest
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [id] TaskExecutionGetRequest id
                 */
    
                /**
                 * Constructs a new TaskExecutionGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionGetRequest.
                 * @implements ITaskExecutionGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionGetRequest=} [properties] Properties to set
                 */
                function TaskExecutionGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionGetRequest id.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.TaskExecutionGetRequest
                 * @instance
                 */
                TaskExecutionGetRequest.prototype.id = null;
    
                /**
                 * Creates a new TaskExecutionGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionGetRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionGetRequest} TaskExecutionGetRequest instance
                 */
                TaskExecutionGetRequest.create = function create(properties) {
                    return new TaskExecutionGetRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionGetRequest message. Does not implicitly {@link nebulaidl.admin.TaskExecutionGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionGetRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionGetRequest} message TaskExecutionGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionGetRequest} TaskExecutionGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return TaskExecutionGetRequest;
            })();
    
            admin.TaskExecutionListRequest = (function() {
    
                /**
                 * Properties of a TaskExecutionListRequest.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionListRequest
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [nodeExecutionId] TaskExecutionListRequest nodeExecutionId
                 * @property {number|null} [limit] TaskExecutionListRequest limit
                 * @property {string|null} [token] TaskExecutionListRequest token
                 * @property {string|null} [filters] TaskExecutionListRequest filters
                 * @property {nebulaidl.admin.ISort|null} [sortBy] TaskExecutionListRequest sortBy
                 */
    
                /**
                 * Constructs a new TaskExecutionListRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionListRequest.
                 * @implements ITaskExecutionListRequest
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionListRequest=} [properties] Properties to set
                 */
                function TaskExecutionListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionListRequest nodeExecutionId.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} nodeExecutionId
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @instance
                 */
                TaskExecutionListRequest.prototype.nodeExecutionId = null;
    
                /**
                 * TaskExecutionListRequest limit.
                 * @member {number} limit
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @instance
                 */
                TaskExecutionListRequest.prototype.limit = 0;
    
                /**
                 * TaskExecutionListRequest token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @instance
                 */
                TaskExecutionListRequest.prototype.token = "";
    
                /**
                 * TaskExecutionListRequest filters.
                 * @member {string} filters
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @instance
                 */
                TaskExecutionListRequest.prototype.filters = "";
    
                /**
                 * TaskExecutionListRequest sortBy.
                 * @member {nebulaidl.admin.ISort|null|undefined} sortBy
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @instance
                 */
                TaskExecutionListRequest.prototype.sortBy = null;
    
                /**
                 * Creates a new TaskExecutionListRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionListRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionListRequest} TaskExecutionListRequest instance
                 */
                TaskExecutionListRequest.create = function create(properties) {
                    return new TaskExecutionListRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionListRequest message. Does not implicitly {@link nebulaidl.admin.TaskExecutionListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionListRequest} message TaskExecutionListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.nodeExecutionId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.filters);
                    if (message.sortBy != null && message.hasOwnProperty("sortBy"))
                        $root.nebulaidl.admin.Sort.encode(message.sortBy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionListRequest} TaskExecutionListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nodeExecutionId = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.limit = reader.uint32();
                            break;
                        case 3:
                            message.token = reader.string();
                            break;
                        case 4:
                            message.filters = reader.string();
                            break;
                        case 5:
                            message.sortBy = $root.nebulaidl.admin.Sort.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionListRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionListRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId")) {
                        var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.nodeExecutionId);
                        if (error)
                            return "nodeExecutionId." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        if (!$util.isString(message.filters))
                            return "filters: string expected";
                    if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
                        var error = $root.nebulaidl.admin.Sort.verify(message.sortBy);
                        if (error)
                            return "sortBy." + error;
                    }
                    return null;
                };
    
                return TaskExecutionListRequest;
            })();
    
            admin.TaskExecution = (function() {
    
                /**
                 * Properties of a TaskExecution.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecution
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [id] TaskExecution id
                 * @property {string|null} [inputUri] TaskExecution inputUri
                 * @property {nebulaidl.admin.ITaskExecutionClosure|null} [closure] TaskExecution closure
                 * @property {boolean|null} [isParent] TaskExecution isParent
                 */
    
                /**
                 * Constructs a new TaskExecution.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecution.
                 * @implements ITaskExecution
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecution=} [properties] Properties to set
                 */
                function TaskExecution(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecution id.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.id = null;
    
                /**
                 * TaskExecution inputUri.
                 * @member {string} inputUri
                 * @memberof nebulaidl.admin.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.inputUri = "";
    
                /**
                 * TaskExecution closure.
                 * @member {nebulaidl.admin.ITaskExecutionClosure|null|undefined} closure
                 * @memberof nebulaidl.admin.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.closure = null;
    
                /**
                 * TaskExecution isParent.
                 * @member {boolean} isParent
                 * @memberof nebulaidl.admin.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.isParent = false;
    
                /**
                 * Creates a new TaskExecution instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecution
                 * @static
                 * @param {nebulaidl.admin.ITaskExecution=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecution} TaskExecution instance
                 */
                TaskExecution.create = function create(properties) {
                    return new TaskExecution(properties);
                };
    
                /**
                 * Encodes the specified TaskExecution message. Does not implicitly {@link nebulaidl.admin.TaskExecution.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecution
                 * @static
                 * @param {nebulaidl.admin.ITaskExecution} message TaskExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputUri);
                    if (message.closure != null && message.hasOwnProperty("closure"))
                        $root.nebulaidl.admin.TaskExecutionClosure.encode(message.closure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.isParent != null && message.hasOwnProperty("isParent"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isParent);
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecution} TaskExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecution.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecution();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.inputUri = reader.string();
                            break;
                        case 3:
                            message.closure = $root.nebulaidl.admin.TaskExecutionClosure.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.isParent = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecution message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.inputUri != null && message.hasOwnProperty("inputUri"))
                        if (!$util.isString(message.inputUri))
                            return "inputUri: string expected";
                    if (message.closure != null && message.hasOwnProperty("closure")) {
                        var error = $root.nebulaidl.admin.TaskExecutionClosure.verify(message.closure);
                        if (error)
                            return "closure." + error;
                    }
                    if (message.isParent != null && message.hasOwnProperty("isParent"))
                        if (typeof message.isParent !== "boolean")
                            return "isParent: boolean expected";
                    return null;
                };
    
                return TaskExecution;
            })();
    
            admin.TaskExecutionList = (function() {
    
                /**
                 * Properties of a TaskExecutionList.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionList
                 * @property {Array.<nebulaidl.admin.ITaskExecution>|null} [taskExecutions] TaskExecutionList taskExecutions
                 * @property {string|null} [token] TaskExecutionList token
                 */
    
                /**
                 * Constructs a new TaskExecutionList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionList.
                 * @implements ITaskExecutionList
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionList=} [properties] Properties to set
                 */
                function TaskExecutionList(properties) {
                    this.taskExecutions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionList taskExecutions.
                 * @member {Array.<nebulaidl.admin.ITaskExecution>} taskExecutions
                 * @memberof nebulaidl.admin.TaskExecutionList
                 * @instance
                 */
                TaskExecutionList.prototype.taskExecutions = $util.emptyArray;
    
                /**
                 * TaskExecutionList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.TaskExecutionList
                 * @instance
                 */
                TaskExecutionList.prototype.token = "";
    
                /**
                 * Creates a new TaskExecutionList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionList
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionList} TaskExecutionList instance
                 */
                TaskExecutionList.create = function create(properties) {
                    return new TaskExecutionList(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionList message. Does not implicitly {@link nebulaidl.admin.TaskExecutionList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionList
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionList} message TaskExecutionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskExecutions != null && message.taskExecutions.length)
                        for (var i = 0; i < message.taskExecutions.length; ++i)
                            $root.nebulaidl.admin.TaskExecution.encode(message.taskExecutions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionList} TaskExecutionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.taskExecutions && message.taskExecutions.length))
                                message.taskExecutions = [];
                            message.taskExecutions.push($root.nebulaidl.admin.TaskExecution.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionList message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskExecutions != null && message.hasOwnProperty("taskExecutions")) {
                        if (!Array.isArray(message.taskExecutions))
                            return "taskExecutions: array expected";
                        for (var i = 0; i < message.taskExecutions.length; ++i) {
                            var error = $root.nebulaidl.admin.TaskExecution.verify(message.taskExecutions[i]);
                            if (error)
                                return "taskExecutions." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return TaskExecutionList;
            })();
    
            admin.TaskExecutionClosure = (function() {
    
                /**
                 * Properties of a TaskExecutionClosure.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionClosure
                 * @property {string|null} [outputUri] TaskExecutionClosure outputUri
                 * @property {nebulaidl.core.IExecutionError|null} [error] TaskExecutionClosure error
                 * @property {nebulaidl.core.ILiteralMap|null} [outputData] TaskExecutionClosure outputData
                 * @property {nebulaidl.core.TaskExecution.Phase|null} [phase] TaskExecutionClosure phase
                 * @property {Array.<nebulaidl.core.ITaskLog>|null} [logs] TaskExecutionClosure logs
                 * @property {google.protobuf.ITimestamp|null} [startedAt] TaskExecutionClosure startedAt
                 * @property {google.protobuf.IDuration|null} [duration] TaskExecutionClosure duration
                 * @property {google.protobuf.ITimestamp|null} [createdAt] TaskExecutionClosure createdAt
                 * @property {google.protobuf.ITimestamp|null} [updatedAt] TaskExecutionClosure updatedAt
                 * @property {google.protobuf.IStruct|null} [customInfo] TaskExecutionClosure customInfo
                 * @property {string|null} [reason] TaskExecutionClosure reason
                 * @property {string|null} [taskType] TaskExecutionClosure taskType
                 * @property {nebulaidl.event.ITaskExecutionMetadata|null} [metadata] TaskExecutionClosure metadata
                 * @property {number|null} [eventVersion] TaskExecutionClosure eventVersion
                 * @property {Array.<nebulaidl.admin.IReason>|null} [reasons] TaskExecutionClosure reasons
                 */
    
                /**
                 * Constructs a new TaskExecutionClosure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionClosure.
                 * @implements ITaskExecutionClosure
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionClosure=} [properties] Properties to set
                 */
                function TaskExecutionClosure(properties) {
                    this.logs = [];
                    this.reasons = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionClosure outputUri.
                 * @member {string} outputUri
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.outputUri = "";
    
                /**
                 * TaskExecutionClosure error.
                 * @member {nebulaidl.core.IExecutionError|null|undefined} error
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.error = null;
    
                /**
                 * TaskExecutionClosure outputData.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputData
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.outputData = null;
    
                /**
                 * TaskExecutionClosure phase.
                 * @member {nebulaidl.core.TaskExecution.Phase} phase
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.phase = 0;
    
                /**
                 * TaskExecutionClosure logs.
                 * @member {Array.<nebulaidl.core.ITaskLog>} logs
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.logs = $util.emptyArray;
    
                /**
                 * TaskExecutionClosure startedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} startedAt
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.startedAt = null;
    
                /**
                 * TaskExecutionClosure duration.
                 * @member {google.protobuf.IDuration|null|undefined} duration
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.duration = null;
    
                /**
                 * TaskExecutionClosure createdAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} createdAt
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.createdAt = null;
    
                /**
                 * TaskExecutionClosure updatedAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} updatedAt
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.updatedAt = null;
    
                /**
                 * TaskExecutionClosure customInfo.
                 * @member {google.protobuf.IStruct|null|undefined} customInfo
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.customInfo = null;
    
                /**
                 * TaskExecutionClosure reason.
                 * @member {string} reason
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.reason = "";
    
                /**
                 * TaskExecutionClosure taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.taskType = "";
    
                /**
                 * TaskExecutionClosure metadata.
                 * @member {nebulaidl.event.ITaskExecutionMetadata|null|undefined} metadata
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.metadata = null;
    
                /**
                 * TaskExecutionClosure eventVersion.
                 * @member {number} eventVersion
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.eventVersion = 0;
    
                /**
                 * TaskExecutionClosure reasons.
                 * @member {Array.<nebulaidl.admin.IReason>} reasons
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                TaskExecutionClosure.prototype.reasons = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * TaskExecutionClosure outputResult.
                 * @member {"outputUri"|"error"|"outputData"|undefined} outputResult
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @instance
                 */
                Object.defineProperty(TaskExecutionClosure.prototype, "outputResult", {
                    get: $util.oneOfGetter($oneOfFields = ["outputUri", "error", "outputData"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new TaskExecutionClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionClosure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionClosure} TaskExecutionClosure instance
                 */
                TaskExecutionClosure.create = function create(properties) {
                    return new TaskExecutionClosure(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionClosure message. Does not implicitly {@link nebulaidl.admin.TaskExecutionClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionClosure} message TaskExecutionClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.outputUri != null && message.hasOwnProperty("outputUri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputUri);
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.nebulaidl.core.ExecutionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.phase);
                    if (message.logs != null && message.logs.length)
                        for (var i = 0; i < message.logs.length; ++i)
                            $root.nebulaidl.core.TaskLog.encode(message.logs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                        $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt"))
                        $root.google.protobuf.Timestamp.encode(message.updatedAt, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.customInfo != null && message.hasOwnProperty("customInfo"))
                        $root.google.protobuf.Struct.encode(message.customInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reason);
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.taskType);
                    if (message.outputData != null && message.hasOwnProperty("outputData"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputData, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.nebulaidl.event.TaskExecutionMetadata.encode(message.metadata, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.eventVersion);
                    if (message.reasons != null && message.reasons.length)
                        for (var i = 0; i < message.reasons.length; ++i)
                            $root.nebulaidl.admin.Reason.encode(message.reasons[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionClosure} TaskExecutionClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputUri = reader.string();
                            break;
                        case 2:
                            message.error = $root.nebulaidl.core.ExecutionError.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.outputData = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.phase = reader.int32();
                            break;
                        case 4:
                            if (!(message.logs && message.logs.length))
                                message.logs = [];
                            message.logs.push($root.nebulaidl.core.TaskLog.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.updatedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.customInfo = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.reason = reader.string();
                            break;
                        case 11:
                            message.taskType = reader.string();
                            break;
                        case 16:
                            message.metadata = $root.nebulaidl.event.TaskExecutionMetadata.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.eventVersion = reader.int32();
                            break;
                        case 18:
                            if (!(message.reasons && message.reasons.length))
                                message.reasons = [];
                            message.reasons.push($root.nebulaidl.admin.Reason.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionClosure message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.outputUri != null && message.hasOwnProperty("outputUri")) {
                        properties.outputResult = 1;
                        if (!$util.isString(message.outputUri))
                            return "outputUri: string expected";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.ExecutionError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.outputData != null && message.hasOwnProperty("outputData")) {
                        if (properties.outputResult === 1)
                            return "outputResult: multiple values";
                        properties.outputResult = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.outputData);
                            if (error)
                                return "outputData." + error;
                        }
                    }
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.logs != null && message.hasOwnProperty("logs")) {
                        if (!Array.isArray(message.logs))
                            return "logs: array expected";
                        for (var i = 0; i < message.logs.length; ++i) {
                            var error = $root.nebulaidl.core.TaskLog.verify(message.logs[i]);
                            if (error)
                                return "logs." + error;
                        }
                    }
                    if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                        if (error)
                            return "startedAt." + error;
                    }
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    if (message.updatedAt != null && message.hasOwnProperty("updatedAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.updatedAt);
                        if (error)
                            return "updatedAt." + error;
                    }
                    if (message.customInfo != null && message.hasOwnProperty("customInfo")) {
                        var error = $root.google.protobuf.Struct.verify(message.customInfo);
                        if (error)
                            return "customInfo." + error;
                    }
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.nebulaidl.event.TaskExecutionMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
                        if (!$util.isInteger(message.eventVersion))
                            return "eventVersion: integer expected";
                    if (message.reasons != null && message.hasOwnProperty("reasons")) {
                        if (!Array.isArray(message.reasons))
                            return "reasons: array expected";
                        for (var i = 0; i < message.reasons.length; ++i) {
                            var error = $root.nebulaidl.admin.Reason.verify(message.reasons[i]);
                            if (error)
                                return "reasons." + error;
                        }
                    }
                    return null;
                };
    
                return TaskExecutionClosure;
            })();
    
            admin.Reason = (function() {
    
                /**
                 * Properties of a Reason.
                 * @memberof nebulaidl.admin
                 * @interface IReason
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] Reason occurredAt
                 * @property {string|null} [message] Reason message
                 */
    
                /**
                 * Constructs a new Reason.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Reason.
                 * @implements IReason
                 * @constructor
                 * @param {nebulaidl.admin.IReason=} [properties] Properties to set
                 */
                function Reason(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Reason occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof nebulaidl.admin.Reason
                 * @instance
                 */
                Reason.prototype.occurredAt = null;
    
                /**
                 * Reason message.
                 * @member {string} message
                 * @memberof nebulaidl.admin.Reason
                 * @instance
                 */
                Reason.prototype.message = "";
    
                /**
                 * Creates a new Reason instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Reason
                 * @static
                 * @param {nebulaidl.admin.IReason=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Reason} Reason instance
                 */
                Reason.create = function create(properties) {
                    return new Reason(properties);
                };
    
                /**
                 * Encodes the specified Reason message. Does not implicitly {@link nebulaidl.admin.Reason.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Reason
                 * @static
                 * @param {nebulaidl.admin.IReason} message Reason message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reason.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        $root.google.protobuf.Timestamp.encode(message.occurredAt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    return writer;
                };
    
                /**
                 * Decodes a Reason message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Reason
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Reason} Reason
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reason.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Reason();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.occurredAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Reason message.
                 * @function verify
                 * @memberof nebulaidl.admin.Reason
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reason.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };
    
                return Reason;
            })();
    
            admin.TaskExecutionGetDataRequest = (function() {
    
                /**
                 * Properties of a TaskExecutionGetDataRequest.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionGetDataRequest
                 * @property {nebulaidl.core.ITaskExecutionIdentifier|null} [id] TaskExecutionGetDataRequest id
                 */
    
                /**
                 * Constructs a new TaskExecutionGetDataRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionGetDataRequest.
                 * @implements ITaskExecutionGetDataRequest
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionGetDataRequest=} [properties] Properties to set
                 */
                function TaskExecutionGetDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionGetDataRequest id.
                 * @member {nebulaidl.core.ITaskExecutionIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.TaskExecutionGetDataRequest
                 * @instance
                 */
                TaskExecutionGetDataRequest.prototype.id = null;
    
                /**
                 * Creates a new TaskExecutionGetDataRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionGetDataRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionGetDataRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionGetDataRequest} TaskExecutionGetDataRequest instance
                 */
                TaskExecutionGetDataRequest.create = function create(properties) {
                    return new TaskExecutionGetDataRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionGetDataRequest message. Does not implicitly {@link nebulaidl.admin.TaskExecutionGetDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionGetDataRequest
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionGetDataRequest} message TaskExecutionGetDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionGetDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.TaskExecutionIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionGetDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionGetDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionGetDataRequest} TaskExecutionGetDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionGetDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionGetDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.TaskExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionGetDataRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionGetDataRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionGetDataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.TaskExecutionIdentifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return TaskExecutionGetDataRequest;
            })();
    
            admin.TaskExecutionGetDataResponse = (function() {
    
                /**
                 * Properties of a TaskExecutionGetDataResponse.
                 * @memberof nebulaidl.admin
                 * @interface ITaskExecutionGetDataResponse
                 * @property {nebulaidl.admin.IUrlBlob|null} [inputs] TaskExecutionGetDataResponse inputs
                 * @property {nebulaidl.admin.IUrlBlob|null} [outputs] TaskExecutionGetDataResponse outputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fullInputs] TaskExecutionGetDataResponse fullInputs
                 * @property {nebulaidl.core.ILiteralMap|null} [fullOutputs] TaskExecutionGetDataResponse fullOutputs
                 * @property {nebulaidl.admin.INebulaURLs|null} [nebulaUrls] TaskExecutionGetDataResponse nebulaUrls
                 */
    
                /**
                 * Constructs a new TaskExecutionGetDataResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a TaskExecutionGetDataResponse.
                 * @implements ITaskExecutionGetDataResponse
                 * @constructor
                 * @param {nebulaidl.admin.ITaskExecutionGetDataResponse=} [properties] Properties to set
                 */
                function TaskExecutionGetDataResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskExecutionGetDataResponse inputs.
                 * @member {nebulaidl.admin.IUrlBlob|null|undefined} inputs
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @instance
                 */
                TaskExecutionGetDataResponse.prototype.inputs = null;
    
                /**
                 * TaskExecutionGetDataResponse outputs.
                 * @member {nebulaidl.admin.IUrlBlob|null|undefined} outputs
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @instance
                 */
                TaskExecutionGetDataResponse.prototype.outputs = null;
    
                /**
                 * TaskExecutionGetDataResponse fullInputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fullInputs
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @instance
                 */
                TaskExecutionGetDataResponse.prototype.fullInputs = null;
    
                /**
                 * TaskExecutionGetDataResponse fullOutputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} fullOutputs
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @instance
                 */
                TaskExecutionGetDataResponse.prototype.fullOutputs = null;
    
                /**
                 * TaskExecutionGetDataResponse nebulaUrls.
                 * @member {nebulaidl.admin.INebulaURLs|null|undefined} nebulaUrls
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @instance
                 */
                TaskExecutionGetDataResponse.prototype.nebulaUrls = null;
    
                /**
                 * Creates a new TaskExecutionGetDataResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionGetDataResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.TaskExecutionGetDataResponse} TaskExecutionGetDataResponse instance
                 */
                TaskExecutionGetDataResponse.create = function create(properties) {
                    return new TaskExecutionGetDataResponse(properties);
                };
    
                /**
                 * Encodes the specified TaskExecutionGetDataResponse message. Does not implicitly {@link nebulaidl.admin.TaskExecutionGetDataResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @static
                 * @param {nebulaidl.admin.ITaskExecutionGetDataResponse} message TaskExecutionGetDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionGetDataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.admin.UrlBlob.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.admin.UrlBlob.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.fullInputs != null && message.hasOwnProperty("fullInputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fullInputs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fullOutputs != null && message.hasOwnProperty("fullOutputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.fullOutputs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.nebulaUrls != null && message.hasOwnProperty("nebulaUrls"))
                        $root.nebulaidl.admin.NebulaURLs.encode(message.nebulaUrls, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskExecutionGetDataResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.TaskExecutionGetDataResponse} TaskExecutionGetDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionGetDataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.TaskExecutionGetDataResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputs = $root.nebulaidl.admin.UrlBlob.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.outputs = $root.nebulaidl.admin.UrlBlob.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.fullInputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.fullOutputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.nebulaUrls = $root.nebulaidl.admin.NebulaURLs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskExecutionGetDataResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.TaskExecutionGetDataResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionGetDataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.admin.UrlBlob.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        var error = $root.nebulaidl.admin.UrlBlob.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                    if (message.fullInputs != null && message.hasOwnProperty("fullInputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fullInputs);
                        if (error)
                            return "fullInputs." + error;
                    }
                    if (message.fullOutputs != null && message.hasOwnProperty("fullOutputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.fullOutputs);
                        if (error)
                            return "fullOutputs." + error;
                    }
                    if (message.nebulaUrls != null && message.hasOwnProperty("nebulaUrls")) {
                        var error = $root.nebulaidl.admin.NebulaURLs.verify(message.nebulaUrls);
                        if (error)
                            return "nebulaUrls." + error;
                    }
                    return null;
                };
    
                return TaskExecutionGetDataResponse;
            })();
    
            admin.GetVersionResponse = (function() {
    
                /**
                 * Properties of a GetVersionResponse.
                 * @memberof nebulaidl.admin
                 * @interface IGetVersionResponse
                 * @property {nebulaidl.admin.IVersion|null} [controlPlaneVersion] GetVersionResponse controlPlaneVersion
                 */
    
                /**
                 * Constructs a new GetVersionResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a GetVersionResponse.
                 * @implements IGetVersionResponse
                 * @constructor
                 * @param {nebulaidl.admin.IGetVersionResponse=} [properties] Properties to set
                 */
                function GetVersionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetVersionResponse controlPlaneVersion.
                 * @member {nebulaidl.admin.IVersion|null|undefined} controlPlaneVersion
                 * @memberof nebulaidl.admin.GetVersionResponse
                 * @instance
                 */
                GetVersionResponse.prototype.controlPlaneVersion = null;
    
                /**
                 * Creates a new GetVersionResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.GetVersionResponse
                 * @static
                 * @param {nebulaidl.admin.IGetVersionResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.GetVersionResponse} GetVersionResponse instance
                 */
                GetVersionResponse.create = function create(properties) {
                    return new GetVersionResponse(properties);
                };
    
                /**
                 * Encodes the specified GetVersionResponse message. Does not implicitly {@link nebulaidl.admin.GetVersionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.GetVersionResponse
                 * @static
                 * @param {nebulaidl.admin.IGetVersionResponse} message GetVersionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetVersionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.controlPlaneVersion != null && message.hasOwnProperty("controlPlaneVersion"))
                        $root.nebulaidl.admin.Version.encode(message.controlPlaneVersion, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetVersionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.GetVersionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.GetVersionResponse} GetVersionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetVersionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.GetVersionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.controlPlaneVersion = $root.nebulaidl.admin.Version.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GetVersionResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.GetVersionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetVersionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.controlPlaneVersion != null && message.hasOwnProperty("controlPlaneVersion")) {
                        var error = $root.nebulaidl.admin.Version.verify(message.controlPlaneVersion);
                        if (error)
                            return "controlPlaneVersion." + error;
                    }
                    return null;
                };
    
                return GetVersionResponse;
            })();
    
            admin.Version = (function() {
    
                /**
                 * Properties of a Version.
                 * @memberof nebulaidl.admin
                 * @interface IVersion
                 * @property {string|null} [Build] Version Build
                 * @property {string|null} [Version] Version Version
                 * @property {string|null} [BuildTime] Version BuildTime
                 */
    
                /**
                 * Constructs a new Version.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Version.
                 * @implements IVersion
                 * @constructor
                 * @param {nebulaidl.admin.IVersion=} [properties] Properties to set
                 */
                function Version(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Version Build.
                 * @member {string} Build
                 * @memberof nebulaidl.admin.Version
                 * @instance
                 */
                Version.prototype.Build = "";
    
                /**
                 * Version Version.
                 * @member {string} Version
                 * @memberof nebulaidl.admin.Version
                 * @instance
                 */
                Version.prototype.Version = "";
    
                /**
                 * Version BuildTime.
                 * @member {string} BuildTime
                 * @memberof nebulaidl.admin.Version
                 * @instance
                 */
                Version.prototype.BuildTime = "";
    
                /**
                 * Creates a new Version instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Version
                 * @static
                 * @param {nebulaidl.admin.IVersion=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Version} Version instance
                 */
                Version.create = function create(properties) {
                    return new Version(properties);
                };
    
                /**
                 * Encodes the specified Version message. Does not implicitly {@link nebulaidl.admin.Version.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Version
                 * @static
                 * @param {nebulaidl.admin.IVersion} message Version message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Version.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Build != null && message.hasOwnProperty("Build"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.Build);
                    if (message.Version != null && message.hasOwnProperty("Version"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Version);
                    if (message.BuildTime != null && message.hasOwnProperty("BuildTime"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.BuildTime);
                    return writer;
                };
    
                /**
                 * Decodes a Version message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Version
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Version} Version
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Version.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Version();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Build = reader.string();
                            break;
                        case 2:
                            message.Version = reader.string();
                            break;
                        case 3:
                            message.BuildTime = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Version message.
                 * @function verify
                 * @memberof nebulaidl.admin.Version
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Version.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Build != null && message.hasOwnProperty("Build"))
                        if (!$util.isString(message.Build))
                            return "Build: string expected";
                    if (message.Version != null && message.hasOwnProperty("Version"))
                        if (!$util.isString(message.Version))
                            return "Version: string expected";
                    if (message.BuildTime != null && message.hasOwnProperty("BuildTime"))
                        if (!$util.isString(message.BuildTime))
                            return "BuildTime: string expected";
                    return null;
                };
    
                return Version;
            })();
    
            admin.GetVersionRequest = (function() {
    
                /**
                 * Properties of a GetVersionRequest.
                 * @memberof nebulaidl.admin
                 * @interface IGetVersionRequest
                 */
    
                /**
                 * Constructs a new GetVersionRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a GetVersionRequest.
                 * @implements IGetVersionRequest
                 * @constructor
                 * @param {nebulaidl.admin.IGetVersionRequest=} [properties] Properties to set
                 */
                function GetVersionRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetVersionRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.GetVersionRequest
                 * @static
                 * @param {nebulaidl.admin.IGetVersionRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.GetVersionRequest} GetVersionRequest instance
                 */
                GetVersionRequest.create = function create(properties) {
                    return new GetVersionRequest(properties);
                };
    
                /**
                 * Encodes the specified GetVersionRequest message. Does not implicitly {@link nebulaidl.admin.GetVersionRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.GetVersionRequest
                 * @static
                 * @param {nebulaidl.admin.IGetVersionRequest} message GetVersionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetVersionRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetVersionRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.GetVersionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.GetVersionRequest} GetVersionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetVersionRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.GetVersionRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GetVersionRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.GetVersionRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetVersionRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return GetVersionRequest;
            })();
    
            admin.WorkflowCreateRequest = (function() {
    
                /**
                 * Properties of a WorkflowCreateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowCreateRequest
                 * @property {nebulaidl.core.IIdentifier|null} [id] WorkflowCreateRequest id
                 * @property {nebulaidl.admin.IWorkflowSpec|null} [spec] WorkflowCreateRequest spec
                 */
    
                /**
                 * Constructs a new WorkflowCreateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowCreateRequest.
                 * @implements IWorkflowCreateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowCreateRequest=} [properties] Properties to set
                 */
                function WorkflowCreateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowCreateRequest id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.WorkflowCreateRequest
                 * @instance
                 */
                WorkflowCreateRequest.prototype.id = null;
    
                /**
                 * WorkflowCreateRequest spec.
                 * @member {nebulaidl.admin.IWorkflowSpec|null|undefined} spec
                 * @memberof nebulaidl.admin.WorkflowCreateRequest
                 * @instance
                 */
                WorkflowCreateRequest.prototype.spec = null;
    
                /**
                 * Creates a new WorkflowCreateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowCreateRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowCreateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowCreateRequest} WorkflowCreateRequest instance
                 */
                WorkflowCreateRequest.create = function create(properties) {
                    return new WorkflowCreateRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowCreateRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowCreateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowCreateRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowCreateRequest} message WorkflowCreateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowCreateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        $root.nebulaidl.admin.WorkflowSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowCreateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowCreateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowCreateRequest} WorkflowCreateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowCreateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowCreateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.spec = $root.nebulaidl.admin.WorkflowSpec.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowCreateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowCreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowCreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        var error = $root.nebulaidl.admin.WorkflowSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    return null;
                };
    
                return WorkflowCreateRequest;
            })();
    
            admin.WorkflowCreateResponse = (function() {
    
                /**
                 * Properties of a WorkflowCreateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowCreateResponse
                 */
    
                /**
                 * Constructs a new WorkflowCreateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowCreateResponse.
                 * @implements IWorkflowCreateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowCreateResponse=} [properties] Properties to set
                 */
                function WorkflowCreateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WorkflowCreateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowCreateResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowCreateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowCreateResponse} WorkflowCreateResponse instance
                 */
                WorkflowCreateResponse.create = function create(properties) {
                    return new WorkflowCreateResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowCreateResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowCreateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowCreateResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowCreateResponse} message WorkflowCreateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowCreateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowCreateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowCreateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowCreateResponse} WorkflowCreateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowCreateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowCreateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowCreateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowCreateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowCreateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return WorkflowCreateResponse;
            })();
    
            admin.Workflow = (function() {
    
                /**
                 * Properties of a Workflow.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflow
                 * @property {nebulaidl.core.IIdentifier|null} [id] Workflow id
                 * @property {nebulaidl.admin.IWorkflowClosure|null} [closure] Workflow closure
                 * @property {string|null} [shortDescription] Workflow shortDescription
                 */
    
                /**
                 * Constructs a new Workflow.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a Workflow.
                 * @implements IWorkflow
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflow=} [properties] Properties to set
                 */
                function Workflow(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Workflow id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.Workflow
                 * @instance
                 */
                Workflow.prototype.id = null;
    
                /**
                 * Workflow closure.
                 * @member {nebulaidl.admin.IWorkflowClosure|null|undefined} closure
                 * @memberof nebulaidl.admin.Workflow
                 * @instance
                 */
                Workflow.prototype.closure = null;
    
                /**
                 * Workflow shortDescription.
                 * @member {string} shortDescription
                 * @memberof nebulaidl.admin.Workflow
                 * @instance
                 */
                Workflow.prototype.shortDescription = "";
    
                /**
                 * Creates a new Workflow instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.Workflow
                 * @static
                 * @param {nebulaidl.admin.IWorkflow=} [properties] Properties to set
                 * @returns {nebulaidl.admin.Workflow} Workflow instance
                 */
                Workflow.create = function create(properties) {
                    return new Workflow(properties);
                };
    
                /**
                 * Encodes the specified Workflow message. Does not implicitly {@link nebulaidl.admin.Workflow.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.Workflow
                 * @static
                 * @param {nebulaidl.admin.IWorkflow} message Workflow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Workflow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.closure != null && message.hasOwnProperty("closure"))
                        $root.nebulaidl.admin.WorkflowClosure.encode(message.closure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.shortDescription);
                    return writer;
                };
    
                /**
                 * Decodes a Workflow message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.Workflow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.Workflow} Workflow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Workflow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.Workflow();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.closure = $root.nebulaidl.admin.WorkflowClosure.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.shortDescription = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Workflow message.
                 * @function verify
                 * @memberof nebulaidl.admin.Workflow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Workflow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.closure != null && message.hasOwnProperty("closure")) {
                        var error = $root.nebulaidl.admin.WorkflowClosure.verify(message.closure);
                        if (error)
                            return "closure." + error;
                    }
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    return null;
                };
    
                return Workflow;
            })();
    
            admin.WorkflowList = (function() {
    
                /**
                 * Properties of a WorkflowList.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowList
                 * @property {Array.<nebulaidl.admin.IWorkflow>|null} [workflows] WorkflowList workflows
                 * @property {string|null} [token] WorkflowList token
                 */
    
                /**
                 * Constructs a new WorkflowList.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowList.
                 * @implements IWorkflowList
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowList=} [properties] Properties to set
                 */
                function WorkflowList(properties) {
                    this.workflows = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowList workflows.
                 * @member {Array.<nebulaidl.admin.IWorkflow>} workflows
                 * @memberof nebulaidl.admin.WorkflowList
                 * @instance
                 */
                WorkflowList.prototype.workflows = $util.emptyArray;
    
                /**
                 * WorkflowList token.
                 * @member {string} token
                 * @memberof nebulaidl.admin.WorkflowList
                 * @instance
                 */
                WorkflowList.prototype.token = "";
    
                /**
                 * Creates a new WorkflowList instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowList
                 * @static
                 * @param {nebulaidl.admin.IWorkflowList=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowList} WorkflowList instance
                 */
                WorkflowList.create = function create(properties) {
                    return new WorkflowList(properties);
                };
    
                /**
                 * Encodes the specified WorkflowList message. Does not implicitly {@link nebulaidl.admin.WorkflowList.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowList
                 * @static
                 * @param {nebulaidl.admin.IWorkflowList} message WorkflowList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.workflows != null && message.workflows.length)
                        for (var i = 0; i < message.workflows.length; ++i)
                            $root.nebulaidl.admin.Workflow.encode(message.workflows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.token != null && message.hasOwnProperty("token"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowList message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowList} WorkflowList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.workflows && message.workflows.length))
                                message.workflows = [];
                            message.workflows.push($root.nebulaidl.admin.Workflow.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.token = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowList message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.workflows != null && message.hasOwnProperty("workflows")) {
                        if (!Array.isArray(message.workflows))
                            return "workflows: array expected";
                        for (var i = 0; i < message.workflows.length; ++i) {
                            var error = $root.nebulaidl.admin.Workflow.verify(message.workflows[i]);
                            if (error)
                                return "workflows." + error;
                        }
                    }
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };
    
                return WorkflowList;
            })();
    
            admin.WorkflowSpec = (function() {
    
                /**
                 * Properties of a WorkflowSpec.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowSpec
                 * @property {nebulaidl.core.IWorkflowTemplate|null} [template] WorkflowSpec template
                 * @property {Array.<nebulaidl.core.IWorkflowTemplate>|null} [subWorkflows] WorkflowSpec subWorkflows
                 * @property {nebulaidl.admin.IDescriptionEntity|null} [description] WorkflowSpec description
                 */
    
                /**
                 * Constructs a new WorkflowSpec.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowSpec.
                 * @implements IWorkflowSpec
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowSpec=} [properties] Properties to set
                 */
                function WorkflowSpec(properties) {
                    this.subWorkflows = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowSpec template.
                 * @member {nebulaidl.core.IWorkflowTemplate|null|undefined} template
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @instance
                 */
                WorkflowSpec.prototype.template = null;
    
                /**
                 * WorkflowSpec subWorkflows.
                 * @member {Array.<nebulaidl.core.IWorkflowTemplate>} subWorkflows
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @instance
                 */
                WorkflowSpec.prototype.subWorkflows = $util.emptyArray;
    
                /**
                 * WorkflowSpec description.
                 * @member {nebulaidl.admin.IDescriptionEntity|null|undefined} description
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @instance
                 */
                WorkflowSpec.prototype.description = null;
    
                /**
                 * Creates a new WorkflowSpec instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @static
                 * @param {nebulaidl.admin.IWorkflowSpec=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowSpec} WorkflowSpec instance
                 */
                WorkflowSpec.create = function create(properties) {
                    return new WorkflowSpec(properties);
                };
    
                /**
                 * Encodes the specified WorkflowSpec message. Does not implicitly {@link nebulaidl.admin.WorkflowSpec.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @static
                 * @param {nebulaidl.admin.IWorkflowSpec} message WorkflowSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.template != null && message.hasOwnProperty("template"))
                        $root.nebulaidl.core.WorkflowTemplate.encode(message.template, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.subWorkflows != null && message.subWorkflows.length)
                        for (var i = 0; i < message.subWorkflows.length; ++i)
                            $root.nebulaidl.core.WorkflowTemplate.encode(message.subWorkflows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.description != null && message.hasOwnProperty("description"))
                        $root.nebulaidl.admin.DescriptionEntity.encode(message.description, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowSpec} WorkflowSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowSpec.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowSpec();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.template = $root.nebulaidl.core.WorkflowTemplate.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.subWorkflows && message.subWorkflows.length))
                                message.subWorkflows = [];
                            message.subWorkflows.push($root.nebulaidl.core.WorkflowTemplate.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.description = $root.nebulaidl.admin.DescriptionEntity.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowSpec message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.template != null && message.hasOwnProperty("template")) {
                        var error = $root.nebulaidl.core.WorkflowTemplate.verify(message.template);
                        if (error)
                            return "template." + error;
                    }
                    if (message.subWorkflows != null && message.hasOwnProperty("subWorkflows")) {
                        if (!Array.isArray(message.subWorkflows))
                            return "subWorkflows: array expected";
                        for (var i = 0; i < message.subWorkflows.length; ++i) {
                            var error = $root.nebulaidl.core.WorkflowTemplate.verify(message.subWorkflows[i]);
                            if (error)
                                return "subWorkflows." + error;
                        }
                    }
                    if (message.description != null && message.hasOwnProperty("description")) {
                        var error = $root.nebulaidl.admin.DescriptionEntity.verify(message.description);
                        if (error)
                            return "description." + error;
                    }
                    return null;
                };
    
                return WorkflowSpec;
            })();
    
            admin.WorkflowClosure = (function() {
    
                /**
                 * Properties of a WorkflowClosure.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowClosure
                 * @property {nebulaidl.core.ICompiledWorkflowClosure|null} [compiledWorkflow] WorkflowClosure compiledWorkflow
                 * @property {google.protobuf.ITimestamp|null} [createdAt] WorkflowClosure createdAt
                 */
    
                /**
                 * Constructs a new WorkflowClosure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowClosure.
                 * @implements IWorkflowClosure
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowClosure=} [properties] Properties to set
                 */
                function WorkflowClosure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowClosure compiledWorkflow.
                 * @member {nebulaidl.core.ICompiledWorkflowClosure|null|undefined} compiledWorkflow
                 * @memberof nebulaidl.admin.WorkflowClosure
                 * @instance
                 */
                WorkflowClosure.prototype.compiledWorkflow = null;
    
                /**
                 * WorkflowClosure createdAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} createdAt
                 * @memberof nebulaidl.admin.WorkflowClosure
                 * @instance
                 */
                WorkflowClosure.prototype.createdAt = null;
    
                /**
                 * Creates a new WorkflowClosure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowClosure
                 * @static
                 * @param {nebulaidl.admin.IWorkflowClosure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowClosure} WorkflowClosure instance
                 */
                WorkflowClosure.create = function create(properties) {
                    return new WorkflowClosure(properties);
                };
    
                /**
                 * Encodes the specified WorkflowClosure message. Does not implicitly {@link nebulaidl.admin.WorkflowClosure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowClosure
                 * @static
                 * @param {nebulaidl.admin.IWorkflowClosure} message WorkflowClosure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowClosure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow"))
                        $root.nebulaidl.core.CompiledWorkflowClosure.encode(message.compiledWorkflow, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowClosure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowClosure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowClosure} WorkflowClosure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowClosure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowClosure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.compiledWorkflow = $root.nebulaidl.core.CompiledWorkflowClosure.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowClosure message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowClosure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowClosure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.compiledWorkflow != null && message.hasOwnProperty("compiledWorkflow")) {
                        var error = $root.nebulaidl.core.CompiledWorkflowClosure.verify(message.compiledWorkflow);
                        if (error)
                            return "compiledWorkflow." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    return null;
                };
    
                return WorkflowClosure;
            })();
    
            admin.WorkflowErrorExistsDifferentStructure = (function() {
    
                /**
                 * Properties of a WorkflowErrorExistsDifferentStructure.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowErrorExistsDifferentStructure
                 * @property {nebulaidl.core.IIdentifier|null} [id] WorkflowErrorExistsDifferentStructure id
                 */
    
                /**
                 * Constructs a new WorkflowErrorExistsDifferentStructure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowErrorExistsDifferentStructure.
                 * @implements IWorkflowErrorExistsDifferentStructure
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowErrorExistsDifferentStructure=} [properties] Properties to set
                 */
                function WorkflowErrorExistsDifferentStructure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowErrorExistsDifferentStructure id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.WorkflowErrorExistsDifferentStructure
                 * @instance
                 */
                WorkflowErrorExistsDifferentStructure.prototype.id = null;
    
                /**
                 * Creates a new WorkflowErrorExistsDifferentStructure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowErrorExistsDifferentStructure
                 * @static
                 * @param {nebulaidl.admin.IWorkflowErrorExistsDifferentStructure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowErrorExistsDifferentStructure} WorkflowErrorExistsDifferentStructure instance
                 */
                WorkflowErrorExistsDifferentStructure.create = function create(properties) {
                    return new WorkflowErrorExistsDifferentStructure(properties);
                };
    
                /**
                 * Encodes the specified WorkflowErrorExistsDifferentStructure message. Does not implicitly {@link nebulaidl.admin.WorkflowErrorExistsDifferentStructure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowErrorExistsDifferentStructure
                 * @static
                 * @param {nebulaidl.admin.IWorkflowErrorExistsDifferentStructure} message WorkflowErrorExistsDifferentStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowErrorExistsDifferentStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowErrorExistsDifferentStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowErrorExistsDifferentStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowErrorExistsDifferentStructure} WorkflowErrorExistsDifferentStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowErrorExistsDifferentStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowErrorExistsDifferentStructure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowErrorExistsDifferentStructure message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowErrorExistsDifferentStructure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowErrorExistsDifferentStructure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return WorkflowErrorExistsDifferentStructure;
            })();
    
            admin.WorkflowErrorExistsIdenticalStructure = (function() {
    
                /**
                 * Properties of a WorkflowErrorExistsIdenticalStructure.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowErrorExistsIdenticalStructure
                 * @property {nebulaidl.core.IIdentifier|null} [id] WorkflowErrorExistsIdenticalStructure id
                 */
    
                /**
                 * Constructs a new WorkflowErrorExistsIdenticalStructure.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowErrorExistsIdenticalStructure.
                 * @implements IWorkflowErrorExistsIdenticalStructure
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowErrorExistsIdenticalStructure=} [properties] Properties to set
                 */
                function WorkflowErrorExistsIdenticalStructure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowErrorExistsIdenticalStructure id.
                 * @member {nebulaidl.core.IIdentifier|null|undefined} id
                 * @memberof nebulaidl.admin.WorkflowErrorExistsIdenticalStructure
                 * @instance
                 */
                WorkflowErrorExistsIdenticalStructure.prototype.id = null;
    
                /**
                 * Creates a new WorkflowErrorExistsIdenticalStructure instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowErrorExistsIdenticalStructure
                 * @static
                 * @param {nebulaidl.admin.IWorkflowErrorExistsIdenticalStructure=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowErrorExistsIdenticalStructure} WorkflowErrorExistsIdenticalStructure instance
                 */
                WorkflowErrorExistsIdenticalStructure.create = function create(properties) {
                    return new WorkflowErrorExistsIdenticalStructure(properties);
                };
    
                /**
                 * Encodes the specified WorkflowErrorExistsIdenticalStructure message. Does not implicitly {@link nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowErrorExistsIdenticalStructure
                 * @static
                 * @param {nebulaidl.admin.IWorkflowErrorExistsIdenticalStructure} message WorkflowErrorExistsIdenticalStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowErrorExistsIdenticalStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        $root.nebulaidl.core.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowErrorExistsIdenticalStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowErrorExistsIdenticalStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowErrorExistsIdenticalStructure} WorkflowErrorExistsIdenticalStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowErrorExistsIdenticalStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowErrorExistsIdenticalStructure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.nebulaidl.core.Identifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowErrorExistsIdenticalStructure message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowErrorExistsIdenticalStructure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowErrorExistsIdenticalStructure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        var error = $root.nebulaidl.core.Identifier.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    return null;
                };
    
                return WorkflowErrorExistsIdenticalStructure;
            })();
    
            admin.CreateWorkflowFailureReason = (function() {
    
                /**
                 * Properties of a CreateWorkflowFailureReason.
                 * @memberof nebulaidl.admin
                 * @interface ICreateWorkflowFailureReason
                 * @property {nebulaidl.admin.IWorkflowErrorExistsDifferentStructure|null} [existsDifferentStructure] CreateWorkflowFailureReason existsDifferentStructure
                 * @property {nebulaidl.admin.IWorkflowErrorExistsIdenticalStructure|null} [existsIdenticalStructure] CreateWorkflowFailureReason existsIdenticalStructure
                 */
    
                /**
                 * Constructs a new CreateWorkflowFailureReason.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a CreateWorkflowFailureReason.
                 * @implements ICreateWorkflowFailureReason
                 * @constructor
                 * @param {nebulaidl.admin.ICreateWorkflowFailureReason=} [properties] Properties to set
                 */
                function CreateWorkflowFailureReason(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateWorkflowFailureReason existsDifferentStructure.
                 * @member {nebulaidl.admin.IWorkflowErrorExistsDifferentStructure|null|undefined} existsDifferentStructure
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @instance
                 */
                CreateWorkflowFailureReason.prototype.existsDifferentStructure = null;
    
                /**
                 * CreateWorkflowFailureReason existsIdenticalStructure.
                 * @member {nebulaidl.admin.IWorkflowErrorExistsIdenticalStructure|null|undefined} existsIdenticalStructure
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @instance
                 */
                CreateWorkflowFailureReason.prototype.existsIdenticalStructure = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * CreateWorkflowFailureReason reason.
                 * @member {"existsDifferentStructure"|"existsIdenticalStructure"|undefined} reason
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @instance
                 */
                Object.defineProperty(CreateWorkflowFailureReason.prototype, "reason", {
                    get: $util.oneOfGetter($oneOfFields = ["existsDifferentStructure", "existsIdenticalStructure"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new CreateWorkflowFailureReason instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @static
                 * @param {nebulaidl.admin.ICreateWorkflowFailureReason=} [properties] Properties to set
                 * @returns {nebulaidl.admin.CreateWorkflowFailureReason} CreateWorkflowFailureReason instance
                 */
                CreateWorkflowFailureReason.create = function create(properties) {
                    return new CreateWorkflowFailureReason(properties);
                };
    
                /**
                 * Encodes the specified CreateWorkflowFailureReason message. Does not implicitly {@link nebulaidl.admin.CreateWorkflowFailureReason.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @static
                 * @param {nebulaidl.admin.ICreateWorkflowFailureReason} message CreateWorkflowFailureReason message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateWorkflowFailureReason.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.existsDifferentStructure != null && message.hasOwnProperty("existsDifferentStructure"))
                        $root.nebulaidl.admin.WorkflowErrorExistsDifferentStructure.encode(message.existsDifferentStructure, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.existsIdenticalStructure != null && message.hasOwnProperty("existsIdenticalStructure"))
                        $root.nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.encode(message.existsIdenticalStructure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateWorkflowFailureReason message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.CreateWorkflowFailureReason} CreateWorkflowFailureReason
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateWorkflowFailureReason.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.CreateWorkflowFailureReason();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.existsDifferentStructure = $root.nebulaidl.admin.WorkflowErrorExistsDifferentStructure.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.existsIdenticalStructure = $root.nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateWorkflowFailureReason message.
                 * @function verify
                 * @memberof nebulaidl.admin.CreateWorkflowFailureReason
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateWorkflowFailureReason.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.existsDifferentStructure != null && message.hasOwnProperty("existsDifferentStructure")) {
                        properties.reason = 1;
                        {
                            var error = $root.nebulaidl.admin.WorkflowErrorExistsDifferentStructure.verify(message.existsDifferentStructure);
                            if (error)
                                return "existsDifferentStructure." + error;
                        }
                    }
                    if (message.existsIdenticalStructure != null && message.hasOwnProperty("existsIdenticalStructure")) {
                        if (properties.reason === 1)
                            return "reason: multiple values";
                        properties.reason = 1;
                        {
                            var error = $root.nebulaidl.admin.WorkflowErrorExistsIdenticalStructure.verify(message.existsIdenticalStructure);
                            if (error)
                                return "existsIdenticalStructure." + error;
                        }
                    }
                    return null;
                };
    
                return CreateWorkflowFailureReason;
            })();
    
            admin.WorkflowAttributes = (function() {
    
                /**
                 * Properties of a WorkflowAttributes.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributes
                 * @property {string|null} [project] WorkflowAttributes project
                 * @property {string|null} [domain] WorkflowAttributes domain
                 * @property {string|null} [workflow] WorkflowAttributes workflow
                 * @property {nebulaidl.admin.IMatchingAttributes|null} [matchingAttributes] WorkflowAttributes matchingAttributes
                 */
    
                /**
                 * Constructs a new WorkflowAttributes.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributes.
                 * @implements IWorkflowAttributes
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributes=} [properties] Properties to set
                 */
                function WorkflowAttributes(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowAttributes project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @instance
                 */
                WorkflowAttributes.prototype.project = "";
    
                /**
                 * WorkflowAttributes domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @instance
                 */
                WorkflowAttributes.prototype.domain = "";
    
                /**
                 * WorkflowAttributes workflow.
                 * @member {string} workflow
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @instance
                 */
                WorkflowAttributes.prototype.workflow = "";
    
                /**
                 * WorkflowAttributes matchingAttributes.
                 * @member {nebulaidl.admin.IMatchingAttributes|null|undefined} matchingAttributes
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @instance
                 */
                WorkflowAttributes.prototype.matchingAttributes = null;
    
                /**
                 * Creates a new WorkflowAttributes instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributes=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributes} WorkflowAttributes instance
                 */
                WorkflowAttributes.create = function create(properties) {
                    return new WorkflowAttributes(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributes message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributes.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributes} message WorkflowAttributes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.workflow);
                    if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes"))
                        $root.nebulaidl.admin.MatchingAttributes.encode(message.matchingAttributes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributes message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributes} WorkflowAttributes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.workflow = reader.string();
                            break;
                        case 4:
                            message.matchingAttributes = $root.nebulaidl.admin.MatchingAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributes message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        if (!$util.isString(message.workflow))
                            return "workflow: string expected";
                    if (message.matchingAttributes != null && message.hasOwnProperty("matchingAttributes")) {
                        var error = $root.nebulaidl.admin.MatchingAttributes.verify(message.matchingAttributes);
                        if (error)
                            return "matchingAttributes." + error;
                    }
                    return null;
                };
    
                return WorkflowAttributes;
            })();
    
            admin.WorkflowAttributesUpdateRequest = (function() {
    
                /**
                 * Properties of a WorkflowAttributesUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributesUpdateRequest
                 * @property {nebulaidl.admin.IWorkflowAttributes|null} [attributes] WorkflowAttributesUpdateRequest attributes
                 */
    
                /**
                 * Constructs a new WorkflowAttributesUpdateRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributesUpdateRequest.
                 * @implements IWorkflowAttributesUpdateRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateRequest=} [properties] Properties to set
                 */
                function WorkflowAttributesUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowAttributesUpdateRequest attributes.
                 * @member {nebulaidl.admin.IWorkflowAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateRequest
                 * @instance
                 */
                WorkflowAttributesUpdateRequest.prototype.attributes = null;
    
                /**
                 * Creates a new WorkflowAttributesUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributesUpdateRequest} WorkflowAttributesUpdateRequest instance
                 */
                WorkflowAttributesUpdateRequest.create = function create(properties) {
                    return new WorkflowAttributesUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributesUpdateRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributesUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateRequest} message WorkflowAttributesUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributesUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.WorkflowAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributesUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributesUpdateRequest} WorkflowAttributesUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributesUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributesUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.WorkflowAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributesUpdateRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributesUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.WorkflowAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };
    
                return WorkflowAttributesUpdateRequest;
            })();
    
            admin.WorkflowAttributesUpdateResponse = (function() {
    
                /**
                 * Properties of a WorkflowAttributesUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributesUpdateResponse
                 */
    
                /**
                 * Constructs a new WorkflowAttributesUpdateResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributesUpdateResponse.
                 * @implements IWorkflowAttributesUpdateResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateResponse=} [properties] Properties to set
                 */
                function WorkflowAttributesUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WorkflowAttributesUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributesUpdateResponse} WorkflowAttributesUpdateResponse instance
                 */
                WorkflowAttributesUpdateResponse.create = function create(properties) {
                    return new WorkflowAttributesUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributesUpdateResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributesUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateResponse} message WorkflowAttributesUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributesUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributesUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributesUpdateResponse} WorkflowAttributesUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributesUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributesUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributesUpdateResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributesUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributesUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return WorkflowAttributesUpdateResponse;
            })();
    
            admin.WorkflowAttributesGetRequest = (function() {
    
                /**
                 * Properties of a WorkflowAttributesGetRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributesGetRequest
                 * @property {string|null} [project] WorkflowAttributesGetRequest project
                 * @property {string|null} [domain] WorkflowAttributesGetRequest domain
                 * @property {string|null} [workflow] WorkflowAttributesGetRequest workflow
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] WorkflowAttributesGetRequest resourceType
                 */
    
                /**
                 * Constructs a new WorkflowAttributesGetRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributesGetRequest.
                 * @implements IWorkflowAttributesGetRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributesGetRequest=} [properties] Properties to set
                 */
                function WorkflowAttributesGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowAttributesGetRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @instance
                 */
                WorkflowAttributesGetRequest.prototype.project = "";
    
                /**
                 * WorkflowAttributesGetRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @instance
                 */
                WorkflowAttributesGetRequest.prototype.domain = "";
    
                /**
                 * WorkflowAttributesGetRequest workflow.
                 * @member {string} workflow
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @instance
                 */
                WorkflowAttributesGetRequest.prototype.workflow = "";
    
                /**
                 * WorkflowAttributesGetRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @instance
                 */
                WorkflowAttributesGetRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new WorkflowAttributesGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributesGetRequest} WorkflowAttributesGetRequest instance
                 */
                WorkflowAttributesGetRequest.create = function create(properties) {
                    return new WorkflowAttributesGetRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributesGetRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributesGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesGetRequest} message WorkflowAttributesGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributesGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.workflow);
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributesGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributesGetRequest} WorkflowAttributesGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributesGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributesGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.workflow = reader.string();
                            break;
                        case 4:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributesGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributesGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributesGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        if (!$util.isString(message.workflow))
                            return "workflow: string expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return WorkflowAttributesGetRequest;
            })();
    
            admin.WorkflowAttributesGetResponse = (function() {
    
                /**
                 * Properties of a WorkflowAttributesGetResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributesGetResponse
                 * @property {nebulaidl.admin.IWorkflowAttributes|null} [attributes] WorkflowAttributesGetResponse attributes
                 */
    
                /**
                 * Constructs a new WorkflowAttributesGetResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributesGetResponse.
                 * @implements IWorkflowAttributesGetResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributesGetResponse=} [properties] Properties to set
                 */
                function WorkflowAttributesGetResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowAttributesGetResponse attributes.
                 * @member {nebulaidl.admin.IWorkflowAttributes|null|undefined} attributes
                 * @memberof nebulaidl.admin.WorkflowAttributesGetResponse
                 * @instance
                 */
                WorkflowAttributesGetResponse.prototype.attributes = null;
    
                /**
                 * Creates a new WorkflowAttributesGetResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributesGetResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesGetResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributesGetResponse} WorkflowAttributesGetResponse instance
                 */
                WorkflowAttributesGetResponse.create = function create(properties) {
                    return new WorkflowAttributesGetResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributesGetResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributesGetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributesGetResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesGetResponse} message WorkflowAttributesGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributesGetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        $root.nebulaidl.admin.WorkflowAttributes.encode(message.attributes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributesGetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributesGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributesGetResponse} WorkflowAttributesGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributesGetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributesGetResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributes = $root.nebulaidl.admin.WorkflowAttributes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributesGetResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributesGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributesGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        var error = $root.nebulaidl.admin.WorkflowAttributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };
    
                return WorkflowAttributesGetResponse;
            })();
    
            admin.WorkflowAttributesDeleteRequest = (function() {
    
                /**
                 * Properties of a WorkflowAttributesDeleteRequest.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributesDeleteRequest
                 * @property {string|null} [project] WorkflowAttributesDeleteRequest project
                 * @property {string|null} [domain] WorkflowAttributesDeleteRequest domain
                 * @property {string|null} [workflow] WorkflowAttributesDeleteRequest workflow
                 * @property {nebulaidl.admin.MatchableResource|null} [resourceType] WorkflowAttributesDeleteRequest resourceType
                 */
    
                /**
                 * Constructs a new WorkflowAttributesDeleteRequest.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributesDeleteRequest.
                 * @implements IWorkflowAttributesDeleteRequest
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteRequest=} [properties] Properties to set
                 */
                function WorkflowAttributesDeleteRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WorkflowAttributesDeleteRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @instance
                 */
                WorkflowAttributesDeleteRequest.prototype.project = "";
    
                /**
                 * WorkflowAttributesDeleteRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @instance
                 */
                WorkflowAttributesDeleteRequest.prototype.domain = "";
    
                /**
                 * WorkflowAttributesDeleteRequest workflow.
                 * @member {string} workflow
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @instance
                 */
                WorkflowAttributesDeleteRequest.prototype.workflow = "";
    
                /**
                 * WorkflowAttributesDeleteRequest resourceType.
                 * @member {nebulaidl.admin.MatchableResource} resourceType
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @instance
                 */
                WorkflowAttributesDeleteRequest.prototype.resourceType = 0;
    
                /**
                 * Creates a new WorkflowAttributesDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteRequest=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributesDeleteRequest} WorkflowAttributesDeleteRequest instance
                 */
                WorkflowAttributesDeleteRequest.create = function create(properties) {
                    return new WorkflowAttributesDeleteRequest(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributesDeleteRequest message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributesDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteRequest} message WorkflowAttributesDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributesDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.workflow);
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.resourceType);
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributesDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributesDeleteRequest} WorkflowAttributesDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributesDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributesDeleteRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.workflow = reader.string();
                            break;
                        case 4:
                            message.resourceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributesDeleteRequest message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributesDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.workflow != null && message.hasOwnProperty("workflow"))
                        if (!$util.isString(message.workflow))
                            return "workflow: string expected";
                    if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                        switch (message.resourceType) {
                        default:
                            return "resourceType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };
    
                return WorkflowAttributesDeleteRequest;
            })();
    
            admin.WorkflowAttributesDeleteResponse = (function() {
    
                /**
                 * Properties of a WorkflowAttributesDeleteResponse.
                 * @memberof nebulaidl.admin
                 * @interface IWorkflowAttributesDeleteResponse
                 */
    
                /**
                 * Constructs a new WorkflowAttributesDeleteResponse.
                 * @memberof nebulaidl.admin
                 * @classdesc Represents a WorkflowAttributesDeleteResponse.
                 * @implements IWorkflowAttributesDeleteResponse
                 * @constructor
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteResponse=} [properties] Properties to set
                 */
                function WorkflowAttributesDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WorkflowAttributesDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteResponse=} [properties] Properties to set
                 * @returns {nebulaidl.admin.WorkflowAttributesDeleteResponse} WorkflowAttributesDeleteResponse instance
                 */
                WorkflowAttributesDeleteResponse.create = function create(properties) {
                    return new WorkflowAttributesDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified WorkflowAttributesDeleteResponse message. Does not implicitly {@link nebulaidl.admin.WorkflowAttributesDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteResponse
                 * @static
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteResponse} message WorkflowAttributesDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkflowAttributesDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WorkflowAttributesDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.admin.WorkflowAttributesDeleteResponse} WorkflowAttributesDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkflowAttributesDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.admin.WorkflowAttributesDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a WorkflowAttributesDeleteResponse message.
                 * @function verify
                 * @memberof nebulaidl.admin.WorkflowAttributesDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkflowAttributesDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return WorkflowAttributesDeleteResponse;
            })();
    
            return admin;
        })();
    
        nebulaidl.service = (function() {
    
            /**
             * Namespace service.
             * @memberof nebulaidl
             * @namespace
             */
            var service = {};
    
            service.AdminService = (function() {
    
                /**
                 * Constructs a new AdminService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents an AdminService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AdminService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (AdminService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AdminService;
    
                /**
                 * Creates new AdminService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.AdminService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {AdminService} RPC service. Useful where requests and/or responses are streamed.
                 */
                AdminService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createTask}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.TaskCreateResponse} [response] TaskCreateResponse
                 */
    
                /**
                 * Calls CreateTask.
                 * @function createTask
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskCreateRequest} request TaskCreateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateTaskCallback} callback Node-style callback called with the error, if any, and TaskCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createTask = function createTask(request, callback) {
                    return this.rpcCall(createTask, $root.nebulaidl.admin.TaskCreateRequest, $root.nebulaidl.admin.TaskCreateResponse, request, callback);
                }, "name", { value: "CreateTask" });
    
                /**
                 * Calls CreateTask.
                 * @function createTask
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskCreateRequest} request TaskCreateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.TaskCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getTask}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.Task} [response] Task
                 */
    
                /**
                 * Calls GetTask.
                 * @function getTask
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetTaskCallback} callback Node-style callback called with the error, if any, and Task
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getTask = function getTask(request, callback) {
                    return this.rpcCall(getTask, $root.nebulaidl.admin.ObjectGetRequest, $root.nebulaidl.admin.Task, request, callback);
                }, "name", { value: "GetTask" });
    
                /**
                 * Calls GetTask.
                 * @function getTask
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.Task>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listTaskIds}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListTaskIdsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NamedEntityIdentifierList} [response] NamedEntityIdentifierList
                 */
    
                /**
                 * Calls ListTaskIds.
                 * @function listTaskIds
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListTaskIdsCallback} callback Node-style callback called with the error, if any, and NamedEntityIdentifierList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listTaskIds = function listTaskIds(request, callback) {
                    return this.rpcCall(listTaskIds, $root.nebulaidl.admin.NamedEntityIdentifierListRequest, $root.nebulaidl.admin.NamedEntityIdentifierList, request, callback);
                }, "name", { value: "ListTaskIds" });
    
                /**
                 * Calls ListTaskIds.
                 * @function listTaskIds
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NamedEntityIdentifierList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listTasks}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListTasksCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.TaskList} [response] TaskList
                 */
    
                /**
                 * Calls ListTasks.
                 * @function listTasks
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListTasksCallback} callback Node-style callback called with the error, if any, and TaskList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listTasks = function listTasks(request, callback) {
                    return this.rpcCall(listTasks, $root.nebulaidl.admin.ResourceListRequest, $root.nebulaidl.admin.TaskList, request, callback);
                }, "name", { value: "ListTasks" });
    
                /**
                 * Calls ListTasks.
                 * @function listTasks
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.TaskList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createWorkflow}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateWorkflowCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowCreateResponse} [response] WorkflowCreateResponse
                 */
    
                /**
                 * Calls CreateWorkflow.
                 * @function createWorkflow
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowCreateRequest} request WorkflowCreateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateWorkflowCallback} callback Node-style callback called with the error, if any, and WorkflowCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createWorkflow = function createWorkflow(request, callback) {
                    return this.rpcCall(createWorkflow, $root.nebulaidl.admin.WorkflowCreateRequest, $root.nebulaidl.admin.WorkflowCreateResponse, request, callback);
                }, "name", { value: "CreateWorkflow" });
    
                /**
                 * Calls CreateWorkflow.
                 * @function createWorkflow
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowCreateRequest} request WorkflowCreateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getWorkflow}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetWorkflowCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.Workflow} [response] Workflow
                 */
    
                /**
                 * Calls GetWorkflow.
                 * @function getWorkflow
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetWorkflowCallback} callback Node-style callback called with the error, if any, and Workflow
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getWorkflow = function getWorkflow(request, callback) {
                    return this.rpcCall(getWorkflow, $root.nebulaidl.admin.ObjectGetRequest, $root.nebulaidl.admin.Workflow, request, callback);
                }, "name", { value: "GetWorkflow" });
    
                /**
                 * Calls GetWorkflow.
                 * @function getWorkflow
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.Workflow>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listWorkflowIds}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListWorkflowIdsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NamedEntityIdentifierList} [response] NamedEntityIdentifierList
                 */
    
                /**
                 * Calls ListWorkflowIds.
                 * @function listWorkflowIds
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListWorkflowIdsCallback} callback Node-style callback called with the error, if any, and NamedEntityIdentifierList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listWorkflowIds = function listWorkflowIds(request, callback) {
                    return this.rpcCall(listWorkflowIds, $root.nebulaidl.admin.NamedEntityIdentifierListRequest, $root.nebulaidl.admin.NamedEntityIdentifierList, request, callback);
                }, "name", { value: "ListWorkflowIds" });
    
                /**
                 * Calls ListWorkflowIds.
                 * @function listWorkflowIds
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NamedEntityIdentifierList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listWorkflows}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListWorkflowsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowList} [response] WorkflowList
                 */
    
                /**
                 * Calls ListWorkflows.
                 * @function listWorkflows
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListWorkflowsCallback} callback Node-style callback called with the error, if any, and WorkflowList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listWorkflows = function listWorkflows(request, callback) {
                    return this.rpcCall(listWorkflows, $root.nebulaidl.admin.ResourceListRequest, $root.nebulaidl.admin.WorkflowList, request, callback);
                }, "name", { value: "ListWorkflows" });
    
                /**
                 * Calls ListWorkflows.
                 * @function listWorkflows
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createLaunchPlan}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateLaunchPlanCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.LaunchPlanCreateResponse} [response] LaunchPlanCreateResponse
                 */
    
                /**
                 * Calls CreateLaunchPlan.
                 * @function createLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ILaunchPlanCreateRequest} request LaunchPlanCreateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlanCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createLaunchPlan = function createLaunchPlan(request, callback) {
                    return this.rpcCall(createLaunchPlan, $root.nebulaidl.admin.LaunchPlanCreateRequest, $root.nebulaidl.admin.LaunchPlanCreateResponse, request, callback);
                }, "name", { value: "CreateLaunchPlan" });
    
                /**
                 * Calls CreateLaunchPlan.
                 * @function createLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ILaunchPlanCreateRequest} request LaunchPlanCreateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.LaunchPlanCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getLaunchPlan}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetLaunchPlanCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.LaunchPlan} [response] LaunchPlan
                 */
    
                /**
                 * Calls GetLaunchPlan.
                 * @function getLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlan
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getLaunchPlan = function getLaunchPlan(request, callback) {
                    return this.rpcCall(getLaunchPlan, $root.nebulaidl.admin.ObjectGetRequest, $root.nebulaidl.admin.LaunchPlan, request, callback);
                }, "name", { value: "GetLaunchPlan" });
    
                /**
                 * Calls GetLaunchPlan.
                 * @function getLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.LaunchPlan>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getActiveLaunchPlan}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetActiveLaunchPlanCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.LaunchPlan} [response] LaunchPlan
                 */
    
                /**
                 * Calls GetActiveLaunchPlan.
                 * @function getActiveLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IActiveLaunchPlanRequest} request ActiveLaunchPlanRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetActiveLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlan
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getActiveLaunchPlan = function getActiveLaunchPlan(request, callback) {
                    return this.rpcCall(getActiveLaunchPlan, $root.nebulaidl.admin.ActiveLaunchPlanRequest, $root.nebulaidl.admin.LaunchPlan, request, callback);
                }, "name", { value: "GetActiveLaunchPlan" });
    
                /**
                 * Calls GetActiveLaunchPlan.
                 * @function getActiveLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IActiveLaunchPlanRequest} request ActiveLaunchPlanRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.LaunchPlan>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listActiveLaunchPlans}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListActiveLaunchPlansCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.LaunchPlanList} [response] LaunchPlanList
                 */
    
                /**
                 * Calls ListActiveLaunchPlans.
                 * @function listActiveLaunchPlans
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IActiveLaunchPlanListRequest} request ActiveLaunchPlanListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListActiveLaunchPlansCallback} callback Node-style callback called with the error, if any, and LaunchPlanList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listActiveLaunchPlans = function listActiveLaunchPlans(request, callback) {
                    return this.rpcCall(listActiveLaunchPlans, $root.nebulaidl.admin.ActiveLaunchPlanListRequest, $root.nebulaidl.admin.LaunchPlanList, request, callback);
                }, "name", { value: "ListActiveLaunchPlans" });
    
                /**
                 * Calls ListActiveLaunchPlans.
                 * @function listActiveLaunchPlans
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IActiveLaunchPlanListRequest} request ActiveLaunchPlanListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.LaunchPlanList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listLaunchPlanIds}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListLaunchPlanIdsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NamedEntityIdentifierList} [response] NamedEntityIdentifierList
                 */
    
                /**
                 * Calls ListLaunchPlanIds.
                 * @function listLaunchPlanIds
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListLaunchPlanIdsCallback} callback Node-style callback called with the error, if any, and NamedEntityIdentifierList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listLaunchPlanIds = function listLaunchPlanIds(request, callback) {
                    return this.rpcCall(listLaunchPlanIds, $root.nebulaidl.admin.NamedEntityIdentifierListRequest, $root.nebulaidl.admin.NamedEntityIdentifierList, request, callback);
                }, "name", { value: "ListLaunchPlanIds" });
    
                /**
                 * Calls ListLaunchPlanIds.
                 * @function listLaunchPlanIds
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityIdentifierListRequest} request NamedEntityIdentifierListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NamedEntityIdentifierList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listLaunchPlans}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListLaunchPlansCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.LaunchPlanList} [response] LaunchPlanList
                 */
    
                /**
                 * Calls ListLaunchPlans.
                 * @function listLaunchPlans
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListLaunchPlansCallback} callback Node-style callback called with the error, if any, and LaunchPlanList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listLaunchPlans = function listLaunchPlans(request, callback) {
                    return this.rpcCall(listLaunchPlans, $root.nebulaidl.admin.ResourceListRequest, $root.nebulaidl.admin.LaunchPlanList, request, callback);
                }, "name", { value: "ListLaunchPlans" });
    
                /**
                 * Calls ListLaunchPlans.
                 * @function listLaunchPlans
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.LaunchPlanList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateLaunchPlan}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateLaunchPlanCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.LaunchPlanUpdateResponse} [response] LaunchPlanUpdateResponse
                 */
    
                /**
                 * Calls UpdateLaunchPlan.
                 * @function updateLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ILaunchPlanUpdateRequest} request LaunchPlanUpdateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateLaunchPlanCallback} callback Node-style callback called with the error, if any, and LaunchPlanUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateLaunchPlan = function updateLaunchPlan(request, callback) {
                    return this.rpcCall(updateLaunchPlan, $root.nebulaidl.admin.LaunchPlanUpdateRequest, $root.nebulaidl.admin.LaunchPlanUpdateResponse, request, callback);
                }, "name", { value: "UpdateLaunchPlan" });
    
                /**
                 * Calls UpdateLaunchPlan.
                 * @function updateLaunchPlan
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ILaunchPlanUpdateRequest} request LaunchPlanUpdateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.LaunchPlanUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ExecutionCreateResponse} [response] ExecutionCreateResponse
                 */
    
                /**
                 * Calls CreateExecution.
                 * @function createExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionCreateRequest} request ExecutionCreateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createExecution = function createExecution(request, callback) {
                    return this.rpcCall(createExecution, $root.nebulaidl.admin.ExecutionCreateRequest, $root.nebulaidl.admin.ExecutionCreateResponse, request, callback);
                }, "name", { value: "CreateExecution" });
    
                /**
                 * Calls CreateExecution.
                 * @function createExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionCreateRequest} request ExecutionCreateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ExecutionCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#relaunchExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef RelaunchExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ExecutionCreateResponse} [response] ExecutionCreateResponse
                 */
    
                /**
                 * Calls RelaunchExecution.
                 * @function relaunchExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionRelaunchRequest} request ExecutionRelaunchRequest message or plain object
                 * @param {nebulaidl.service.AdminService.RelaunchExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.relaunchExecution = function relaunchExecution(request, callback) {
                    return this.rpcCall(relaunchExecution, $root.nebulaidl.admin.ExecutionRelaunchRequest, $root.nebulaidl.admin.ExecutionCreateResponse, request, callback);
                }, "name", { value: "RelaunchExecution" });
    
                /**
                 * Calls RelaunchExecution.
                 * @function relaunchExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionRelaunchRequest} request ExecutionRelaunchRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ExecutionCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#recoverExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef RecoverExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ExecutionCreateResponse} [response] ExecutionCreateResponse
                 */
    
                /**
                 * Calls RecoverExecution.
                 * @function recoverExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionRecoverRequest} request ExecutionRecoverRequest message or plain object
                 * @param {nebulaidl.service.AdminService.RecoverExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.recoverExecution = function recoverExecution(request, callback) {
                    return this.rpcCall(recoverExecution, $root.nebulaidl.admin.ExecutionRecoverRequest, $root.nebulaidl.admin.ExecutionCreateResponse, request, callback);
                }, "name", { value: "RecoverExecution" });
    
                /**
                 * Calls RecoverExecution.
                 * @function recoverExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionRecoverRequest} request ExecutionRecoverRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ExecutionCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.Execution} [response] Execution
                 */
    
                /**
                 * Calls GetExecution.
                 * @function getExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionGetRequest} request WorkflowExecutionGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetExecutionCallback} callback Node-style callback called with the error, if any, and Execution
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getExecution = function getExecution(request, callback) {
                    return this.rpcCall(getExecution, $root.nebulaidl.admin.WorkflowExecutionGetRequest, $root.nebulaidl.admin.Execution, request, callback);
                }, "name", { value: "GetExecution" });
    
                /**
                 * Calls GetExecution.
                 * @function getExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionGetRequest} request WorkflowExecutionGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.Execution>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ExecutionUpdateResponse} [response] ExecutionUpdateResponse
                 */
    
                /**
                 * Calls UpdateExecution.
                 * @function updateExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionUpdateRequest} request ExecutionUpdateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateExecution = function updateExecution(request, callback) {
                    return this.rpcCall(updateExecution, $root.nebulaidl.admin.ExecutionUpdateRequest, $root.nebulaidl.admin.ExecutionUpdateResponse, request, callback);
                }, "name", { value: "UpdateExecution" });
    
                /**
                 * Calls UpdateExecution.
                 * @function updateExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionUpdateRequest} request ExecutionUpdateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ExecutionUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getExecutionData}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetExecutionDataCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowExecutionGetDataResponse} [response] WorkflowExecutionGetDataResponse
                 */
    
                /**
                 * Calls GetExecutionData.
                 * @function getExecutionData
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataRequest} request WorkflowExecutionGetDataRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetExecutionDataCallback} callback Node-style callback called with the error, if any, and WorkflowExecutionGetDataResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getExecutionData = function getExecutionData(request, callback) {
                    return this.rpcCall(getExecutionData, $root.nebulaidl.admin.WorkflowExecutionGetDataRequest, $root.nebulaidl.admin.WorkflowExecutionGetDataResponse, request, callback);
                }, "name", { value: "GetExecutionData" });
    
                /**
                 * Calls GetExecutionData.
                 * @function getExecutionData
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionGetDataRequest} request WorkflowExecutionGetDataRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowExecutionGetDataResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listExecutions}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListExecutionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ExecutionList} [response] ExecutionList
                 */
    
                /**
                 * Calls ListExecutions.
                 * @function listExecutions
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListExecutionsCallback} callback Node-style callback called with the error, if any, and ExecutionList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listExecutions = function listExecutions(request, callback) {
                    return this.rpcCall(listExecutions, $root.nebulaidl.admin.ResourceListRequest, $root.nebulaidl.admin.ExecutionList, request, callback);
                }, "name", { value: "ListExecutions" });
    
                /**
                 * Calls ListExecutions.
                 * @function listExecutions
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IResourceListRequest} request ResourceListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ExecutionList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#terminateExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef TerminateExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ExecutionTerminateResponse} [response] ExecutionTerminateResponse
                 */
    
                /**
                 * Calls TerminateExecution.
                 * @function terminateExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionTerminateRequest} request ExecutionTerminateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.TerminateExecutionCallback} callback Node-style callback called with the error, if any, and ExecutionTerminateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.terminateExecution = function terminateExecution(request, callback) {
                    return this.rpcCall(terminateExecution, $root.nebulaidl.admin.ExecutionTerminateRequest, $root.nebulaidl.admin.ExecutionTerminateResponse, request, callback);
                }, "name", { value: "TerminateExecution" });
    
                /**
                 * Calls TerminateExecution.
                 * @function terminateExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IExecutionTerminateRequest} request ExecutionTerminateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ExecutionTerminateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getNodeExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetNodeExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NodeExecution} [response] NodeExecution
                 */
    
                /**
                 * Calls GetNodeExecution.
                 * @function getNodeExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionGetRequest} request NodeExecutionGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetNodeExecutionCallback} callback Node-style callback called with the error, if any, and NodeExecution
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getNodeExecution = function getNodeExecution(request, callback) {
                    return this.rpcCall(getNodeExecution, $root.nebulaidl.admin.NodeExecutionGetRequest, $root.nebulaidl.admin.NodeExecution, request, callback);
                }, "name", { value: "GetNodeExecution" });
    
                /**
                 * Calls GetNodeExecution.
                 * @function getNodeExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionGetRequest} request NodeExecutionGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NodeExecution>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listNodeExecutions}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListNodeExecutionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NodeExecutionList} [response] NodeExecutionList
                 */
    
                /**
                 * Calls ListNodeExecutions.
                 * @function listNodeExecutions
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionListRequest} request NodeExecutionListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListNodeExecutionsCallback} callback Node-style callback called with the error, if any, and NodeExecutionList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listNodeExecutions = function listNodeExecutions(request, callback) {
                    return this.rpcCall(listNodeExecutions, $root.nebulaidl.admin.NodeExecutionListRequest, $root.nebulaidl.admin.NodeExecutionList, request, callback);
                }, "name", { value: "ListNodeExecutions" });
    
                /**
                 * Calls ListNodeExecutions.
                 * @function listNodeExecutions
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionListRequest} request NodeExecutionListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NodeExecutionList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listNodeExecutionsForTask}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListNodeExecutionsForTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NodeExecutionList} [response] NodeExecutionList
                 */
    
                /**
                 * Calls ListNodeExecutionsForTask.
                 * @function listNodeExecutionsForTask
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionForTaskListRequest} request NodeExecutionForTaskListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListNodeExecutionsForTaskCallback} callback Node-style callback called with the error, if any, and NodeExecutionList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listNodeExecutionsForTask = function listNodeExecutionsForTask(request, callback) {
                    return this.rpcCall(listNodeExecutionsForTask, $root.nebulaidl.admin.NodeExecutionForTaskListRequest, $root.nebulaidl.admin.NodeExecutionList, request, callback);
                }, "name", { value: "ListNodeExecutionsForTask" });
    
                /**
                 * Calls ListNodeExecutionsForTask.
                 * @function listNodeExecutionsForTask
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionForTaskListRequest} request NodeExecutionForTaskListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NodeExecutionList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getNodeExecutionData}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetNodeExecutionDataCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NodeExecutionGetDataResponse} [response] NodeExecutionGetDataResponse
                 */
    
                /**
                 * Calls GetNodeExecutionData.
                 * @function getNodeExecutionData
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionGetDataRequest} request NodeExecutionGetDataRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetNodeExecutionDataCallback} callback Node-style callback called with the error, if any, and NodeExecutionGetDataResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getNodeExecutionData = function getNodeExecutionData(request, callback) {
                    return this.rpcCall(getNodeExecutionData, $root.nebulaidl.admin.NodeExecutionGetDataRequest, $root.nebulaidl.admin.NodeExecutionGetDataResponse, request, callback);
                }, "name", { value: "GetNodeExecutionData" });
    
                /**
                 * Calls GetNodeExecutionData.
                 * @function getNodeExecutionData
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionGetDataRequest} request NodeExecutionGetDataRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NodeExecutionGetDataResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#registerProject}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef RegisterProjectCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectRegisterResponse} [response] ProjectRegisterResponse
                 */
    
                /**
                 * Calls RegisterProject.
                 * @function registerProject
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectRegisterRequest} request ProjectRegisterRequest message or plain object
                 * @param {nebulaidl.service.AdminService.RegisterProjectCallback} callback Node-style callback called with the error, if any, and ProjectRegisterResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.registerProject = function registerProject(request, callback) {
                    return this.rpcCall(registerProject, $root.nebulaidl.admin.ProjectRegisterRequest, $root.nebulaidl.admin.ProjectRegisterResponse, request, callback);
                }, "name", { value: "RegisterProject" });
    
                /**
                 * Calls RegisterProject.
                 * @function registerProject
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectRegisterRequest} request ProjectRegisterRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectRegisterResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateProject}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateProjectCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectUpdateResponse} [response] ProjectUpdateResponse
                 */
    
                /**
                 * Calls UpdateProject.
                 * @function updateProject
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProject} request Project message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateProjectCallback} callback Node-style callback called with the error, if any, and ProjectUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateProject = function updateProject(request, callback) {
                    return this.rpcCall(updateProject, $root.nebulaidl.admin.Project, $root.nebulaidl.admin.ProjectUpdateResponse, request, callback);
                }, "name", { value: "UpdateProject" });
    
                /**
                 * Calls UpdateProject.
                 * @function updateProject
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProject} request Project message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listProjects}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListProjectsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.Projects} [response] Projects
                 */
    
                /**
                 * Calls ListProjects.
                 * @function listProjects
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectListRequest} request ProjectListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListProjectsCallback} callback Node-style callback called with the error, if any, and Projects
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listProjects = function listProjects(request, callback) {
                    return this.rpcCall(listProjects, $root.nebulaidl.admin.ProjectListRequest, $root.nebulaidl.admin.Projects, request, callback);
                }, "name", { value: "ListProjects" });
    
                /**
                 * Calls ListProjects.
                 * @function listProjects
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectListRequest} request ProjectListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.Projects>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createWorkflowEvent}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateWorkflowEventCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowExecutionEventResponse} [response] WorkflowExecutionEventResponse
                 */
    
                /**
                 * Calls CreateWorkflowEvent.
                 * @function createWorkflowEvent
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionEventRequest} request WorkflowExecutionEventRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateWorkflowEventCallback} callback Node-style callback called with the error, if any, and WorkflowExecutionEventResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createWorkflowEvent = function createWorkflowEvent(request, callback) {
                    return this.rpcCall(createWorkflowEvent, $root.nebulaidl.admin.WorkflowExecutionEventRequest, $root.nebulaidl.admin.WorkflowExecutionEventResponse, request, callback);
                }, "name", { value: "CreateWorkflowEvent" });
    
                /**
                 * Calls CreateWorkflowEvent.
                 * @function createWorkflowEvent
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionEventRequest} request WorkflowExecutionEventRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowExecutionEventResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createNodeEvent}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateNodeEventCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NodeExecutionEventResponse} [response] NodeExecutionEventResponse
                 */
    
                /**
                 * Calls CreateNodeEvent.
                 * @function createNodeEvent
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionEventRequest} request NodeExecutionEventRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateNodeEventCallback} callback Node-style callback called with the error, if any, and NodeExecutionEventResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createNodeEvent = function createNodeEvent(request, callback) {
                    return this.rpcCall(createNodeEvent, $root.nebulaidl.admin.NodeExecutionEventRequest, $root.nebulaidl.admin.NodeExecutionEventResponse, request, callback);
                }, "name", { value: "CreateNodeEvent" });
    
                /**
                 * Calls CreateNodeEvent.
                 * @function createNodeEvent
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INodeExecutionEventRequest} request NodeExecutionEventRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NodeExecutionEventResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#createTaskEvent}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef CreateTaskEventCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.TaskExecutionEventResponse} [response] TaskExecutionEventResponse
                 */
    
                /**
                 * Calls CreateTaskEvent.
                 * @function createTaskEvent
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionEventRequest} request TaskExecutionEventRequest message or plain object
                 * @param {nebulaidl.service.AdminService.CreateTaskEventCallback} callback Node-style callback called with the error, if any, and TaskExecutionEventResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.createTaskEvent = function createTaskEvent(request, callback) {
                    return this.rpcCall(createTaskEvent, $root.nebulaidl.admin.TaskExecutionEventRequest, $root.nebulaidl.admin.TaskExecutionEventResponse, request, callback);
                }, "name", { value: "CreateTaskEvent" });
    
                /**
                 * Calls CreateTaskEvent.
                 * @function createTaskEvent
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionEventRequest} request TaskExecutionEventRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.TaskExecutionEventResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getTaskExecution}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetTaskExecutionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.TaskExecution} [response] TaskExecution
                 */
    
                /**
                 * Calls GetTaskExecution.
                 * @function getTaskExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionGetRequest} request TaskExecutionGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetTaskExecutionCallback} callback Node-style callback called with the error, if any, and TaskExecution
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getTaskExecution = function getTaskExecution(request, callback) {
                    return this.rpcCall(getTaskExecution, $root.nebulaidl.admin.TaskExecutionGetRequest, $root.nebulaidl.admin.TaskExecution, request, callback);
                }, "name", { value: "GetTaskExecution" });
    
                /**
                 * Calls GetTaskExecution.
                 * @function getTaskExecution
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionGetRequest} request TaskExecutionGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.TaskExecution>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listTaskExecutions}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListTaskExecutionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.TaskExecutionList} [response] TaskExecutionList
                 */
    
                /**
                 * Calls ListTaskExecutions.
                 * @function listTaskExecutions
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionListRequest} request TaskExecutionListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListTaskExecutionsCallback} callback Node-style callback called with the error, if any, and TaskExecutionList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listTaskExecutions = function listTaskExecutions(request, callback) {
                    return this.rpcCall(listTaskExecutions, $root.nebulaidl.admin.TaskExecutionListRequest, $root.nebulaidl.admin.TaskExecutionList, request, callback);
                }, "name", { value: "ListTaskExecutions" });
    
                /**
                 * Calls ListTaskExecutions.
                 * @function listTaskExecutions
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionListRequest} request TaskExecutionListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.TaskExecutionList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getTaskExecutionData}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetTaskExecutionDataCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.TaskExecutionGetDataResponse} [response] TaskExecutionGetDataResponse
                 */
    
                /**
                 * Calls GetTaskExecutionData.
                 * @function getTaskExecutionData
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionGetDataRequest} request TaskExecutionGetDataRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetTaskExecutionDataCallback} callback Node-style callback called with the error, if any, and TaskExecutionGetDataResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getTaskExecutionData = function getTaskExecutionData(request, callback) {
                    return this.rpcCall(getTaskExecutionData, $root.nebulaidl.admin.TaskExecutionGetDataRequest, $root.nebulaidl.admin.TaskExecutionGetDataResponse, request, callback);
                }, "name", { value: "GetTaskExecutionData" });
    
                /**
                 * Calls GetTaskExecutionData.
                 * @function getTaskExecutionData
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.ITaskExecutionGetDataRequest} request TaskExecutionGetDataRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.TaskExecutionGetDataResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateProjectDomainAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateProjectDomainAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectDomainAttributesUpdateResponse} [response] ProjectDomainAttributesUpdateResponse
                 */
    
                /**
                 * Calls UpdateProjectDomainAttributes.
                 * @function updateProjectDomainAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateRequest} request ProjectDomainAttributesUpdateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateProjectDomainAttributesCallback} callback Node-style callback called with the error, if any, and ProjectDomainAttributesUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateProjectDomainAttributes = function updateProjectDomainAttributes(request, callback) {
                    return this.rpcCall(updateProjectDomainAttributes, $root.nebulaidl.admin.ProjectDomainAttributesUpdateRequest, $root.nebulaidl.admin.ProjectDomainAttributesUpdateResponse, request, callback);
                }, "name", { value: "UpdateProjectDomainAttributes" });
    
                /**
                 * Calls UpdateProjectDomainAttributes.
                 * @function updateProjectDomainAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectDomainAttributesUpdateRequest} request ProjectDomainAttributesUpdateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectDomainAttributesUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getProjectDomainAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetProjectDomainAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectDomainAttributesGetResponse} [response] ProjectDomainAttributesGetResponse
                 */
    
                /**
                 * Calls GetProjectDomainAttributes.
                 * @function getProjectDomainAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetRequest} request ProjectDomainAttributesGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetProjectDomainAttributesCallback} callback Node-style callback called with the error, if any, and ProjectDomainAttributesGetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getProjectDomainAttributes = function getProjectDomainAttributes(request, callback) {
                    return this.rpcCall(getProjectDomainAttributes, $root.nebulaidl.admin.ProjectDomainAttributesGetRequest, $root.nebulaidl.admin.ProjectDomainAttributesGetResponse, request, callback);
                }, "name", { value: "GetProjectDomainAttributes" });
    
                /**
                 * Calls GetProjectDomainAttributes.
                 * @function getProjectDomainAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectDomainAttributesGetRequest} request ProjectDomainAttributesGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectDomainAttributesGetResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#deleteProjectDomainAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef DeleteProjectDomainAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectDomainAttributesDeleteResponse} [response] ProjectDomainAttributesDeleteResponse
                 */
    
                /**
                 * Calls DeleteProjectDomainAttributes.
                 * @function deleteProjectDomainAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteRequest} request ProjectDomainAttributesDeleteRequest message or plain object
                 * @param {nebulaidl.service.AdminService.DeleteProjectDomainAttributesCallback} callback Node-style callback called with the error, if any, and ProjectDomainAttributesDeleteResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.deleteProjectDomainAttributes = function deleteProjectDomainAttributes(request, callback) {
                    return this.rpcCall(deleteProjectDomainAttributes, $root.nebulaidl.admin.ProjectDomainAttributesDeleteRequest, $root.nebulaidl.admin.ProjectDomainAttributesDeleteResponse, request, callback);
                }, "name", { value: "DeleteProjectDomainAttributes" });
    
                /**
                 * Calls DeleteProjectDomainAttributes.
                 * @function deleteProjectDomainAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectDomainAttributesDeleteRequest} request ProjectDomainAttributesDeleteRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectDomainAttributesDeleteResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateProjectAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateProjectAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectAttributesUpdateResponse} [response] ProjectAttributesUpdateResponse
                 */
    
                /**
                 * Calls UpdateProjectAttributes.
                 * @function updateProjectAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectAttributesUpdateRequest} request ProjectAttributesUpdateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateProjectAttributesCallback} callback Node-style callback called with the error, if any, and ProjectAttributesUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateProjectAttributes = function updateProjectAttributes(request, callback) {
                    return this.rpcCall(updateProjectAttributes, $root.nebulaidl.admin.ProjectAttributesUpdateRequest, $root.nebulaidl.admin.ProjectAttributesUpdateResponse, request, callback);
                }, "name", { value: "UpdateProjectAttributes" });
    
                /**
                 * Calls UpdateProjectAttributes.
                 * @function updateProjectAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectAttributesUpdateRequest} request ProjectAttributesUpdateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectAttributesUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getProjectAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetProjectAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectAttributesGetResponse} [response] ProjectAttributesGetResponse
                 */
    
                /**
                 * Calls GetProjectAttributes.
                 * @function getProjectAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectAttributesGetRequest} request ProjectAttributesGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetProjectAttributesCallback} callback Node-style callback called with the error, if any, and ProjectAttributesGetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getProjectAttributes = function getProjectAttributes(request, callback) {
                    return this.rpcCall(getProjectAttributes, $root.nebulaidl.admin.ProjectAttributesGetRequest, $root.nebulaidl.admin.ProjectAttributesGetResponse, request, callback);
                }, "name", { value: "GetProjectAttributes" });
    
                /**
                 * Calls GetProjectAttributes.
                 * @function getProjectAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectAttributesGetRequest} request ProjectAttributesGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectAttributesGetResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#deleteProjectAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef DeleteProjectAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ProjectAttributesDeleteResponse} [response] ProjectAttributesDeleteResponse
                 */
    
                /**
                 * Calls DeleteProjectAttributes.
                 * @function deleteProjectAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectAttributesDeleteRequest} request ProjectAttributesDeleteRequest message or plain object
                 * @param {nebulaidl.service.AdminService.DeleteProjectAttributesCallback} callback Node-style callback called with the error, if any, and ProjectAttributesDeleteResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.deleteProjectAttributes = function deleteProjectAttributes(request, callback) {
                    return this.rpcCall(deleteProjectAttributes, $root.nebulaidl.admin.ProjectAttributesDeleteRequest, $root.nebulaidl.admin.ProjectAttributesDeleteResponse, request, callback);
                }, "name", { value: "DeleteProjectAttributes" });
    
                /**
                 * Calls DeleteProjectAttributes.
                 * @function deleteProjectAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IProjectAttributesDeleteRequest} request ProjectAttributesDeleteRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ProjectAttributesDeleteResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateWorkflowAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateWorkflowAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowAttributesUpdateResponse} [response] WorkflowAttributesUpdateResponse
                 */
    
                /**
                 * Calls UpdateWorkflowAttributes.
                 * @function updateWorkflowAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateRequest} request WorkflowAttributesUpdateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateWorkflowAttributesCallback} callback Node-style callback called with the error, if any, and WorkflowAttributesUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateWorkflowAttributes = function updateWorkflowAttributes(request, callback) {
                    return this.rpcCall(updateWorkflowAttributes, $root.nebulaidl.admin.WorkflowAttributesUpdateRequest, $root.nebulaidl.admin.WorkflowAttributesUpdateResponse, request, callback);
                }, "name", { value: "UpdateWorkflowAttributes" });
    
                /**
                 * Calls UpdateWorkflowAttributes.
                 * @function updateWorkflowAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowAttributesUpdateRequest} request WorkflowAttributesUpdateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowAttributesUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getWorkflowAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetWorkflowAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowAttributesGetResponse} [response] WorkflowAttributesGetResponse
                 */
    
                /**
                 * Calls GetWorkflowAttributes.
                 * @function getWorkflowAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowAttributesGetRequest} request WorkflowAttributesGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetWorkflowAttributesCallback} callback Node-style callback called with the error, if any, and WorkflowAttributesGetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getWorkflowAttributes = function getWorkflowAttributes(request, callback) {
                    return this.rpcCall(getWorkflowAttributes, $root.nebulaidl.admin.WorkflowAttributesGetRequest, $root.nebulaidl.admin.WorkflowAttributesGetResponse, request, callback);
                }, "name", { value: "GetWorkflowAttributes" });
    
                /**
                 * Calls GetWorkflowAttributes.
                 * @function getWorkflowAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowAttributesGetRequest} request WorkflowAttributesGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowAttributesGetResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#deleteWorkflowAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef DeleteWorkflowAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowAttributesDeleteResponse} [response] WorkflowAttributesDeleteResponse
                 */
    
                /**
                 * Calls DeleteWorkflowAttributes.
                 * @function deleteWorkflowAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteRequest} request WorkflowAttributesDeleteRequest message or plain object
                 * @param {nebulaidl.service.AdminService.DeleteWorkflowAttributesCallback} callback Node-style callback called with the error, if any, and WorkflowAttributesDeleteResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.deleteWorkflowAttributes = function deleteWorkflowAttributes(request, callback) {
                    return this.rpcCall(deleteWorkflowAttributes, $root.nebulaidl.admin.WorkflowAttributesDeleteRequest, $root.nebulaidl.admin.WorkflowAttributesDeleteResponse, request, callback);
                }, "name", { value: "DeleteWorkflowAttributes" });
    
                /**
                 * Calls DeleteWorkflowAttributes.
                 * @function deleteWorkflowAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowAttributesDeleteRequest} request WorkflowAttributesDeleteRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowAttributesDeleteResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listMatchableAttributes}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListMatchableAttributesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.ListMatchableAttributesResponse} [response] ListMatchableAttributesResponse
                 */
    
                /**
                 * Calls ListMatchableAttributes.
                 * @function listMatchableAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IListMatchableAttributesRequest} request ListMatchableAttributesRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListMatchableAttributesCallback} callback Node-style callback called with the error, if any, and ListMatchableAttributesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listMatchableAttributes = function listMatchableAttributes(request, callback) {
                    return this.rpcCall(listMatchableAttributes, $root.nebulaidl.admin.ListMatchableAttributesRequest, $root.nebulaidl.admin.ListMatchableAttributesResponse, request, callback);
                }, "name", { value: "ListMatchableAttributes" });
    
                /**
                 * Calls ListMatchableAttributes.
                 * @function listMatchableAttributes
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IListMatchableAttributesRequest} request ListMatchableAttributesRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.ListMatchableAttributesResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listNamedEntities}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListNamedEntitiesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NamedEntityList} [response] NamedEntityList
                 */
    
                /**
                 * Calls ListNamedEntities.
                 * @function listNamedEntities
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityListRequest} request NamedEntityListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListNamedEntitiesCallback} callback Node-style callback called with the error, if any, and NamedEntityList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listNamedEntities = function listNamedEntities(request, callback) {
                    return this.rpcCall(listNamedEntities, $root.nebulaidl.admin.NamedEntityListRequest, $root.nebulaidl.admin.NamedEntityList, request, callback);
                }, "name", { value: "ListNamedEntities" });
    
                /**
                 * Calls ListNamedEntities.
                 * @function listNamedEntities
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityListRequest} request NamedEntityListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NamedEntityList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getNamedEntity}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetNamedEntityCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NamedEntity} [response] NamedEntity
                 */
    
                /**
                 * Calls GetNamedEntity.
                 * @function getNamedEntity
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityGetRequest} request NamedEntityGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetNamedEntityCallback} callback Node-style callback called with the error, if any, and NamedEntity
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getNamedEntity = function getNamedEntity(request, callback) {
                    return this.rpcCall(getNamedEntity, $root.nebulaidl.admin.NamedEntityGetRequest, $root.nebulaidl.admin.NamedEntity, request, callback);
                }, "name", { value: "GetNamedEntity" });
    
                /**
                 * Calls GetNamedEntity.
                 * @function getNamedEntity
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityGetRequest} request NamedEntityGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NamedEntity>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#updateNamedEntity}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef UpdateNamedEntityCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.NamedEntityUpdateResponse} [response] NamedEntityUpdateResponse
                 */
    
                /**
                 * Calls UpdateNamedEntity.
                 * @function updateNamedEntity
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityUpdateRequest} request NamedEntityUpdateRequest message or plain object
                 * @param {nebulaidl.service.AdminService.UpdateNamedEntityCallback} callback Node-style callback called with the error, if any, and NamedEntityUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.updateNamedEntity = function updateNamedEntity(request, callback) {
                    return this.rpcCall(updateNamedEntity, $root.nebulaidl.admin.NamedEntityUpdateRequest, $root.nebulaidl.admin.NamedEntityUpdateResponse, request, callback);
                }, "name", { value: "UpdateNamedEntity" });
    
                /**
                 * Calls UpdateNamedEntity.
                 * @function updateNamedEntity
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.INamedEntityUpdateRequest} request NamedEntityUpdateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.NamedEntityUpdateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getVersion}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetVersionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.GetVersionResponse} [response] GetVersionResponse
                 */
    
                /**
                 * Calls GetVersion.
                 * @function getVersion
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IGetVersionRequest} request GetVersionRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetVersionCallback} callback Node-style callback called with the error, if any, and GetVersionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getVersion = function getVersion(request, callback) {
                    return this.rpcCall(getVersion, $root.nebulaidl.admin.GetVersionRequest, $root.nebulaidl.admin.GetVersionResponse, request, callback);
                }, "name", { value: "GetVersion" });
    
                /**
                 * Calls GetVersion.
                 * @function getVersion
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IGetVersionRequest} request GetVersionRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.GetVersionResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getDescriptionEntity}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetDescriptionEntityCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.DescriptionEntity} [response] DescriptionEntity
                 */
    
                /**
                 * Calls GetDescriptionEntity.
                 * @function getDescriptionEntity
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetDescriptionEntityCallback} callback Node-style callback called with the error, if any, and DescriptionEntity
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getDescriptionEntity = function getDescriptionEntity(request, callback) {
                    return this.rpcCall(getDescriptionEntity, $root.nebulaidl.admin.ObjectGetRequest, $root.nebulaidl.admin.DescriptionEntity, request, callback);
                }, "name", { value: "GetDescriptionEntity" });
    
                /**
                 * Calls GetDescriptionEntity.
                 * @function getDescriptionEntity
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IObjectGetRequest} request ObjectGetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.DescriptionEntity>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#listDescriptionEntities}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef ListDescriptionEntitiesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.DescriptionEntityList} [response] DescriptionEntityList
                 */
    
                /**
                 * Calls ListDescriptionEntities.
                 * @function listDescriptionEntities
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IDescriptionEntityListRequest} request DescriptionEntityListRequest message or plain object
                 * @param {nebulaidl.service.AdminService.ListDescriptionEntitiesCallback} callback Node-style callback called with the error, if any, and DescriptionEntityList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.listDescriptionEntities = function listDescriptionEntities(request, callback) {
                    return this.rpcCall(listDescriptionEntities, $root.nebulaidl.admin.DescriptionEntityListRequest, $root.nebulaidl.admin.DescriptionEntityList, request, callback);
                }, "name", { value: "ListDescriptionEntities" });
    
                /**
                 * Calls ListDescriptionEntities.
                 * @function listDescriptionEntities
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IDescriptionEntityListRequest} request DescriptionEntityListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.DescriptionEntityList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AdminService#getExecutionMetrics}.
                 * @memberof nebulaidl.service.AdminService
                 * @typedef GetExecutionMetricsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.WorkflowExecutionGetMetricsResponse} [response] WorkflowExecutionGetMetricsResponse
                 */
    
                /**
                 * Calls GetExecutionMetrics.
                 * @function getExecutionMetrics
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsRequest} request WorkflowExecutionGetMetricsRequest message or plain object
                 * @param {nebulaidl.service.AdminService.GetExecutionMetricsCallback} callback Node-style callback called with the error, if any, and WorkflowExecutionGetMetricsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AdminService.prototype.getExecutionMetrics = function getExecutionMetrics(request, callback) {
                    return this.rpcCall(getExecutionMetrics, $root.nebulaidl.admin.WorkflowExecutionGetMetricsRequest, $root.nebulaidl.admin.WorkflowExecutionGetMetricsResponse, request, callback);
                }, "name", { value: "GetExecutionMetrics" });
    
                /**
                 * Calls GetExecutionMetrics.
                 * @function getExecutionMetrics
                 * @memberof nebulaidl.service.AdminService
                 * @instance
                 * @param {nebulaidl.admin.IWorkflowExecutionGetMetricsRequest} request WorkflowExecutionGetMetricsRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.WorkflowExecutionGetMetricsResponse>} Promise
                 * @variation 2
                 */
    
                return AdminService;
            })();
    
            service.AsyncAgentService = (function() {
    
                /**
                 * Constructs a new AsyncAgentService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents an AsyncAgentService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AsyncAgentService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (AsyncAgentService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AsyncAgentService;
    
                /**
                 * Creates new AsyncAgentService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {AsyncAgentService} RPC service. Useful where requests and/or responses are streamed.
                 */
                AsyncAgentService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.AsyncAgentService#createTask}.
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @typedef CreateTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.CreateTaskResponse} [response] CreateTaskResponse
                 */
    
                /**
                 * Calls CreateTask.
                 * @function createTask
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @instance
                 * @param {nebulaidl.admin.ICreateTaskRequest} request CreateTaskRequest message or plain object
                 * @param {nebulaidl.service.AsyncAgentService.CreateTaskCallback} callback Node-style callback called with the error, if any, and CreateTaskResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AsyncAgentService.prototype.createTask = function createTask(request, callback) {
                    return this.rpcCall(createTask, $root.nebulaidl.admin.CreateTaskRequest, $root.nebulaidl.admin.CreateTaskResponse, request, callback);
                }, "name", { value: "CreateTask" });
    
                /**
                 * Calls CreateTask.
                 * @function createTask
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @instance
                 * @param {nebulaidl.admin.ICreateTaskRequest} request CreateTaskRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.CreateTaskResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AsyncAgentService#getTask}.
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @typedef GetTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.GetTaskResponse} [response] GetTaskResponse
                 */
    
                /**
                 * Calls GetTask.
                 * @function getTask
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @instance
                 * @param {nebulaidl.admin.IGetTaskRequest} request GetTaskRequest message or plain object
                 * @param {nebulaidl.service.AsyncAgentService.GetTaskCallback} callback Node-style callback called with the error, if any, and GetTaskResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AsyncAgentService.prototype.getTask = function getTask(request, callback) {
                    return this.rpcCall(getTask, $root.nebulaidl.admin.GetTaskRequest, $root.nebulaidl.admin.GetTaskResponse, request, callback);
                }, "name", { value: "GetTask" });
    
                /**
                 * Calls GetTask.
                 * @function getTask
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @instance
                 * @param {nebulaidl.admin.IGetTaskRequest} request GetTaskRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.GetTaskResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AsyncAgentService#deleteTask}.
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @typedef DeleteTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.DeleteTaskResponse} [response] DeleteTaskResponse
                 */
    
                /**
                 * Calls DeleteTask.
                 * @function deleteTask
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @instance
                 * @param {nebulaidl.admin.IDeleteTaskRequest} request DeleteTaskRequest message or plain object
                 * @param {nebulaidl.service.AsyncAgentService.DeleteTaskCallback} callback Node-style callback called with the error, if any, and DeleteTaskResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AsyncAgentService.prototype.deleteTask = function deleteTask(request, callback) {
                    return this.rpcCall(deleteTask, $root.nebulaidl.admin.DeleteTaskRequest, $root.nebulaidl.admin.DeleteTaskResponse, request, callback);
                }, "name", { value: "DeleteTask" });
    
                /**
                 * Calls DeleteTask.
                 * @function deleteTask
                 * @memberof nebulaidl.service.AsyncAgentService
                 * @instance
                 * @param {nebulaidl.admin.IDeleteTaskRequest} request DeleteTaskRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.DeleteTaskResponse>} Promise
                 * @variation 2
                 */
    
                return AsyncAgentService;
            })();
    
            service.OAuth2MetadataRequest = (function() {
    
                /**
                 * Properties of a OAuth2MetadataRequest.
                 * @memberof nebulaidl.service
                 * @interface IOAuth2MetadataRequest
                 */
    
                /**
                 * Constructs a new OAuth2MetadataRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a OAuth2MetadataRequest.
                 * @implements IOAuth2MetadataRequest
                 * @constructor
                 * @param {nebulaidl.service.IOAuth2MetadataRequest=} [properties] Properties to set
                 */
                function OAuth2MetadataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new OAuth2MetadataRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.OAuth2MetadataRequest
                 * @static
                 * @param {nebulaidl.service.IOAuth2MetadataRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.OAuth2MetadataRequest} OAuth2MetadataRequest instance
                 */
                OAuth2MetadataRequest.create = function create(properties) {
                    return new OAuth2MetadataRequest(properties);
                };
    
                /**
                 * Encodes the specified OAuth2MetadataRequest message. Does not implicitly {@link nebulaidl.service.OAuth2MetadataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.OAuth2MetadataRequest
                 * @static
                 * @param {nebulaidl.service.IOAuth2MetadataRequest} message OAuth2MetadataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OAuth2MetadataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a OAuth2MetadataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.OAuth2MetadataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.OAuth2MetadataRequest} OAuth2MetadataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OAuth2MetadataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.OAuth2MetadataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a OAuth2MetadataRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.OAuth2MetadataRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OAuth2MetadataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return OAuth2MetadataRequest;
            })();
    
            service.OAuth2MetadataResponse = (function() {
    
                /**
                 * Properties of a OAuth2MetadataResponse.
                 * @memberof nebulaidl.service
                 * @interface IOAuth2MetadataResponse
                 * @property {string|null} [issuer] OAuth2MetadataResponse issuer
                 * @property {string|null} [authorizationEndpoint] OAuth2MetadataResponse authorizationEndpoint
                 * @property {string|null} [tokenEndpoint] OAuth2MetadataResponse tokenEndpoint
                 * @property {Array.<string>|null} [responseTypesSupported] OAuth2MetadataResponse responseTypesSupported
                 * @property {Array.<string>|null} [scopesSupported] OAuth2MetadataResponse scopesSupported
                 * @property {Array.<string>|null} [tokenEndpointAuthMethodsSupported] OAuth2MetadataResponse tokenEndpointAuthMethodsSupported
                 * @property {string|null} [jwksUri] OAuth2MetadataResponse jwksUri
                 * @property {Array.<string>|null} [codeChallengeMethodsSupported] OAuth2MetadataResponse codeChallengeMethodsSupported
                 * @property {Array.<string>|null} [grantTypesSupported] OAuth2MetadataResponse grantTypesSupported
                 * @property {string|null} [deviceAuthorizationEndpoint] OAuth2MetadataResponse deviceAuthorizationEndpoint
                 */
    
                /**
                 * Constructs a new OAuth2MetadataResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a OAuth2MetadataResponse.
                 * @implements IOAuth2MetadataResponse
                 * @constructor
                 * @param {nebulaidl.service.IOAuth2MetadataResponse=} [properties] Properties to set
                 */
                function OAuth2MetadataResponse(properties) {
                    this.responseTypesSupported = [];
                    this.scopesSupported = [];
                    this.tokenEndpointAuthMethodsSupported = [];
                    this.codeChallengeMethodsSupported = [];
                    this.grantTypesSupported = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OAuth2MetadataResponse issuer.
                 * @member {string} issuer
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.issuer = "";
    
                /**
                 * OAuth2MetadataResponse authorizationEndpoint.
                 * @member {string} authorizationEndpoint
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.authorizationEndpoint = "";
    
                /**
                 * OAuth2MetadataResponse tokenEndpoint.
                 * @member {string} tokenEndpoint
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.tokenEndpoint = "";
    
                /**
                 * OAuth2MetadataResponse responseTypesSupported.
                 * @member {Array.<string>} responseTypesSupported
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.responseTypesSupported = $util.emptyArray;
    
                /**
                 * OAuth2MetadataResponse scopesSupported.
                 * @member {Array.<string>} scopesSupported
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.scopesSupported = $util.emptyArray;
    
                /**
                 * OAuth2MetadataResponse tokenEndpointAuthMethodsSupported.
                 * @member {Array.<string>} tokenEndpointAuthMethodsSupported
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.tokenEndpointAuthMethodsSupported = $util.emptyArray;
    
                /**
                 * OAuth2MetadataResponse jwksUri.
                 * @member {string} jwksUri
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.jwksUri = "";
    
                /**
                 * OAuth2MetadataResponse codeChallengeMethodsSupported.
                 * @member {Array.<string>} codeChallengeMethodsSupported
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.codeChallengeMethodsSupported = $util.emptyArray;
    
                /**
                 * OAuth2MetadataResponse grantTypesSupported.
                 * @member {Array.<string>} grantTypesSupported
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.grantTypesSupported = $util.emptyArray;
    
                /**
                 * OAuth2MetadataResponse deviceAuthorizationEndpoint.
                 * @member {string} deviceAuthorizationEndpoint
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @instance
                 */
                OAuth2MetadataResponse.prototype.deviceAuthorizationEndpoint = "";
    
                /**
                 * Creates a new OAuth2MetadataResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @static
                 * @param {nebulaidl.service.IOAuth2MetadataResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.OAuth2MetadataResponse} OAuth2MetadataResponse instance
                 */
                OAuth2MetadataResponse.create = function create(properties) {
                    return new OAuth2MetadataResponse(properties);
                };
    
                /**
                 * Encodes the specified OAuth2MetadataResponse message. Does not implicitly {@link nebulaidl.service.OAuth2MetadataResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @static
                 * @param {nebulaidl.service.IOAuth2MetadataResponse} message OAuth2MetadataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OAuth2MetadataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.issuer != null && message.hasOwnProperty("issuer"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.issuer);
                    if (message.authorizationEndpoint != null && message.hasOwnProperty("authorizationEndpoint"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.authorizationEndpoint);
                    if (message.tokenEndpoint != null && message.hasOwnProperty("tokenEndpoint"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.tokenEndpoint);
                    if (message.responseTypesSupported != null && message.responseTypesSupported.length)
                        for (var i = 0; i < message.responseTypesSupported.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.responseTypesSupported[i]);
                    if (message.scopesSupported != null && message.scopesSupported.length)
                        for (var i = 0; i < message.scopesSupported.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.scopesSupported[i]);
                    if (message.tokenEndpointAuthMethodsSupported != null && message.tokenEndpointAuthMethodsSupported.length)
                        for (var i = 0; i < message.tokenEndpointAuthMethodsSupported.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.tokenEndpointAuthMethodsSupported[i]);
                    if (message.jwksUri != null && message.hasOwnProperty("jwksUri"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.jwksUri);
                    if (message.codeChallengeMethodsSupported != null && message.codeChallengeMethodsSupported.length)
                        for (var i = 0; i < message.codeChallengeMethodsSupported.length; ++i)
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.codeChallengeMethodsSupported[i]);
                    if (message.grantTypesSupported != null && message.grantTypesSupported.length)
                        for (var i = 0; i < message.grantTypesSupported.length; ++i)
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.grantTypesSupported[i]);
                    if (message.deviceAuthorizationEndpoint != null && message.hasOwnProperty("deviceAuthorizationEndpoint"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.deviceAuthorizationEndpoint);
                    return writer;
                };
    
                /**
                 * Decodes a OAuth2MetadataResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.OAuth2MetadataResponse} OAuth2MetadataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OAuth2MetadataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.OAuth2MetadataResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.issuer = reader.string();
                            break;
                        case 2:
                            message.authorizationEndpoint = reader.string();
                            break;
                        case 3:
                            message.tokenEndpoint = reader.string();
                            break;
                        case 4:
                            if (!(message.responseTypesSupported && message.responseTypesSupported.length))
                                message.responseTypesSupported = [];
                            message.responseTypesSupported.push(reader.string());
                            break;
                        case 5:
                            if (!(message.scopesSupported && message.scopesSupported.length))
                                message.scopesSupported = [];
                            message.scopesSupported.push(reader.string());
                            break;
                        case 6:
                            if (!(message.tokenEndpointAuthMethodsSupported && message.tokenEndpointAuthMethodsSupported.length))
                                message.tokenEndpointAuthMethodsSupported = [];
                            message.tokenEndpointAuthMethodsSupported.push(reader.string());
                            break;
                        case 7:
                            message.jwksUri = reader.string();
                            break;
                        case 8:
                            if (!(message.codeChallengeMethodsSupported && message.codeChallengeMethodsSupported.length))
                                message.codeChallengeMethodsSupported = [];
                            message.codeChallengeMethodsSupported.push(reader.string());
                            break;
                        case 9:
                            if (!(message.grantTypesSupported && message.grantTypesSupported.length))
                                message.grantTypesSupported = [];
                            message.grantTypesSupported.push(reader.string());
                            break;
                        case 10:
                            message.deviceAuthorizationEndpoint = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a OAuth2MetadataResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.OAuth2MetadataResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OAuth2MetadataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.issuer != null && message.hasOwnProperty("issuer"))
                        if (!$util.isString(message.issuer))
                            return "issuer: string expected";
                    if (message.authorizationEndpoint != null && message.hasOwnProperty("authorizationEndpoint"))
                        if (!$util.isString(message.authorizationEndpoint))
                            return "authorizationEndpoint: string expected";
                    if (message.tokenEndpoint != null && message.hasOwnProperty("tokenEndpoint"))
                        if (!$util.isString(message.tokenEndpoint))
                            return "tokenEndpoint: string expected";
                    if (message.responseTypesSupported != null && message.hasOwnProperty("responseTypesSupported")) {
                        if (!Array.isArray(message.responseTypesSupported))
                            return "responseTypesSupported: array expected";
                        for (var i = 0; i < message.responseTypesSupported.length; ++i)
                            if (!$util.isString(message.responseTypesSupported[i]))
                                return "responseTypesSupported: string[] expected";
                    }
                    if (message.scopesSupported != null && message.hasOwnProperty("scopesSupported")) {
                        if (!Array.isArray(message.scopesSupported))
                            return "scopesSupported: array expected";
                        for (var i = 0; i < message.scopesSupported.length; ++i)
                            if (!$util.isString(message.scopesSupported[i]))
                                return "scopesSupported: string[] expected";
                    }
                    if (message.tokenEndpointAuthMethodsSupported != null && message.hasOwnProperty("tokenEndpointAuthMethodsSupported")) {
                        if (!Array.isArray(message.tokenEndpointAuthMethodsSupported))
                            return "tokenEndpointAuthMethodsSupported: array expected";
                        for (var i = 0; i < message.tokenEndpointAuthMethodsSupported.length; ++i)
                            if (!$util.isString(message.tokenEndpointAuthMethodsSupported[i]))
                                return "tokenEndpointAuthMethodsSupported: string[] expected";
                    }
                    if (message.jwksUri != null && message.hasOwnProperty("jwksUri"))
                        if (!$util.isString(message.jwksUri))
                            return "jwksUri: string expected";
                    if (message.codeChallengeMethodsSupported != null && message.hasOwnProperty("codeChallengeMethodsSupported")) {
                        if (!Array.isArray(message.codeChallengeMethodsSupported))
                            return "codeChallengeMethodsSupported: array expected";
                        for (var i = 0; i < message.codeChallengeMethodsSupported.length; ++i)
                            if (!$util.isString(message.codeChallengeMethodsSupported[i]))
                                return "codeChallengeMethodsSupported: string[] expected";
                    }
                    if (message.grantTypesSupported != null && message.hasOwnProperty("grantTypesSupported")) {
                        if (!Array.isArray(message.grantTypesSupported))
                            return "grantTypesSupported: array expected";
                        for (var i = 0; i < message.grantTypesSupported.length; ++i)
                            if (!$util.isString(message.grantTypesSupported[i]))
                                return "grantTypesSupported: string[] expected";
                    }
                    if (message.deviceAuthorizationEndpoint != null && message.hasOwnProperty("deviceAuthorizationEndpoint"))
                        if (!$util.isString(message.deviceAuthorizationEndpoint))
                            return "deviceAuthorizationEndpoint: string expected";
                    return null;
                };
    
                return OAuth2MetadataResponse;
            })();
    
            service.PublicClientAuthConfigRequest = (function() {
    
                /**
                 * Properties of a PublicClientAuthConfigRequest.
                 * @memberof nebulaidl.service
                 * @interface IPublicClientAuthConfigRequest
                 */
    
                /**
                 * Constructs a new PublicClientAuthConfigRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a PublicClientAuthConfigRequest.
                 * @implements IPublicClientAuthConfigRequest
                 * @constructor
                 * @param {nebulaidl.service.IPublicClientAuthConfigRequest=} [properties] Properties to set
                 */
                function PublicClientAuthConfigRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new PublicClientAuthConfigRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.PublicClientAuthConfigRequest
                 * @static
                 * @param {nebulaidl.service.IPublicClientAuthConfigRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.PublicClientAuthConfigRequest} PublicClientAuthConfigRequest instance
                 */
                PublicClientAuthConfigRequest.create = function create(properties) {
                    return new PublicClientAuthConfigRequest(properties);
                };
    
                /**
                 * Encodes the specified PublicClientAuthConfigRequest message. Does not implicitly {@link nebulaidl.service.PublicClientAuthConfigRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.PublicClientAuthConfigRequest
                 * @static
                 * @param {nebulaidl.service.IPublicClientAuthConfigRequest} message PublicClientAuthConfigRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PublicClientAuthConfigRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a PublicClientAuthConfigRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.PublicClientAuthConfigRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.PublicClientAuthConfigRequest} PublicClientAuthConfigRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PublicClientAuthConfigRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.PublicClientAuthConfigRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PublicClientAuthConfigRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.PublicClientAuthConfigRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PublicClientAuthConfigRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return PublicClientAuthConfigRequest;
            })();
    
            service.PublicClientAuthConfigResponse = (function() {
    
                /**
                 * Properties of a PublicClientAuthConfigResponse.
                 * @memberof nebulaidl.service
                 * @interface IPublicClientAuthConfigResponse
                 * @property {string|null} [clientId] PublicClientAuthConfigResponse clientId
                 * @property {string|null} [redirectUri] PublicClientAuthConfigResponse redirectUri
                 * @property {Array.<string>|null} [scopes] PublicClientAuthConfigResponse scopes
                 * @property {string|null} [authorizationMetadataKey] PublicClientAuthConfigResponse authorizationMetadataKey
                 * @property {string|null} [serviceHttpEndpoint] PublicClientAuthConfigResponse serviceHttpEndpoint
                 * @property {string|null} [audience] PublicClientAuthConfigResponse audience
                 */
    
                /**
                 * Constructs a new PublicClientAuthConfigResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a PublicClientAuthConfigResponse.
                 * @implements IPublicClientAuthConfigResponse
                 * @constructor
                 * @param {nebulaidl.service.IPublicClientAuthConfigResponse=} [properties] Properties to set
                 */
                function PublicClientAuthConfigResponse(properties) {
                    this.scopes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PublicClientAuthConfigResponse clientId.
                 * @member {string} clientId
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @instance
                 */
                PublicClientAuthConfigResponse.prototype.clientId = "";
    
                /**
                 * PublicClientAuthConfigResponse redirectUri.
                 * @member {string} redirectUri
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @instance
                 */
                PublicClientAuthConfigResponse.prototype.redirectUri = "";
    
                /**
                 * PublicClientAuthConfigResponse scopes.
                 * @member {Array.<string>} scopes
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @instance
                 */
                PublicClientAuthConfigResponse.prototype.scopes = $util.emptyArray;
    
                /**
                 * PublicClientAuthConfigResponse authorizationMetadataKey.
                 * @member {string} authorizationMetadataKey
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @instance
                 */
                PublicClientAuthConfigResponse.prototype.authorizationMetadataKey = "";
    
                /**
                 * PublicClientAuthConfigResponse serviceHttpEndpoint.
                 * @member {string} serviceHttpEndpoint
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @instance
                 */
                PublicClientAuthConfigResponse.prototype.serviceHttpEndpoint = "";
    
                /**
                 * PublicClientAuthConfigResponse audience.
                 * @member {string} audience
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @instance
                 */
                PublicClientAuthConfigResponse.prototype.audience = "";
    
                /**
                 * Creates a new PublicClientAuthConfigResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @static
                 * @param {nebulaidl.service.IPublicClientAuthConfigResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.PublicClientAuthConfigResponse} PublicClientAuthConfigResponse instance
                 */
                PublicClientAuthConfigResponse.create = function create(properties) {
                    return new PublicClientAuthConfigResponse(properties);
                };
    
                /**
                 * Encodes the specified PublicClientAuthConfigResponse message. Does not implicitly {@link nebulaidl.service.PublicClientAuthConfigResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @static
                 * @param {nebulaidl.service.IPublicClientAuthConfigResponse} message PublicClientAuthConfigResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PublicClientAuthConfigResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.clientId != null && message.hasOwnProperty("clientId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientId);
                    if (message.redirectUri != null && message.hasOwnProperty("redirectUri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.redirectUri);
                    if (message.scopes != null && message.scopes.length)
                        for (var i = 0; i < message.scopes.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.scopes[i]);
                    if (message.authorizationMetadataKey != null && message.hasOwnProperty("authorizationMetadataKey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.authorizationMetadataKey);
                    if (message.serviceHttpEndpoint != null && message.hasOwnProperty("serviceHttpEndpoint"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.serviceHttpEndpoint);
                    if (message.audience != null && message.hasOwnProperty("audience"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.audience);
                    return writer;
                };
    
                /**
                 * Decodes a PublicClientAuthConfigResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.PublicClientAuthConfigResponse} PublicClientAuthConfigResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PublicClientAuthConfigResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.PublicClientAuthConfigResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.clientId = reader.string();
                            break;
                        case 2:
                            message.redirectUri = reader.string();
                            break;
                        case 3:
                            if (!(message.scopes && message.scopes.length))
                                message.scopes = [];
                            message.scopes.push(reader.string());
                            break;
                        case 4:
                            message.authorizationMetadataKey = reader.string();
                            break;
                        case 5:
                            message.serviceHttpEndpoint = reader.string();
                            break;
                        case 6:
                            message.audience = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PublicClientAuthConfigResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.PublicClientAuthConfigResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PublicClientAuthConfigResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientId != null && message.hasOwnProperty("clientId"))
                        if (!$util.isString(message.clientId))
                            return "clientId: string expected";
                    if (message.redirectUri != null && message.hasOwnProperty("redirectUri"))
                        if (!$util.isString(message.redirectUri))
                            return "redirectUri: string expected";
                    if (message.scopes != null && message.hasOwnProperty("scopes")) {
                        if (!Array.isArray(message.scopes))
                            return "scopes: array expected";
                        for (var i = 0; i < message.scopes.length; ++i)
                            if (!$util.isString(message.scopes[i]))
                                return "scopes: string[] expected";
                    }
                    if (message.authorizationMetadataKey != null && message.hasOwnProperty("authorizationMetadataKey"))
                        if (!$util.isString(message.authorizationMetadataKey))
                            return "authorizationMetadataKey: string expected";
                    if (message.serviceHttpEndpoint != null && message.hasOwnProperty("serviceHttpEndpoint"))
                        if (!$util.isString(message.serviceHttpEndpoint))
                            return "serviceHttpEndpoint: string expected";
                    if (message.audience != null && message.hasOwnProperty("audience"))
                        if (!$util.isString(message.audience))
                            return "audience: string expected";
                    return null;
                };
    
                return PublicClientAuthConfigResponse;
            })();
    
            service.AuthMetadataService = (function() {
    
                /**
                 * Constructs a new AuthMetadataService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents an AuthMetadataService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuthMetadataService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (AuthMetadataService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthMetadataService;
    
                /**
                 * Creates new AuthMetadataService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {AuthMetadataService} RPC service. Useful where requests and/or responses are streamed.
                 */
                AuthMetadataService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.AuthMetadataService#getOAuth2Metadata}.
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @typedef GetOAuth2MetadataCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.OAuth2MetadataResponse} [response] OAuth2MetadataResponse
                 */
    
                /**
                 * Calls GetOAuth2Metadata.
                 * @function getOAuth2Metadata
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @instance
                 * @param {nebulaidl.service.IOAuth2MetadataRequest} request OAuth2MetadataRequest message or plain object
                 * @param {nebulaidl.service.AuthMetadataService.GetOAuth2MetadataCallback} callback Node-style callback called with the error, if any, and OAuth2MetadataResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthMetadataService.prototype.getOAuth2Metadata = function getOAuth2Metadata(request, callback) {
                    return this.rpcCall(getOAuth2Metadata, $root.nebulaidl.service.OAuth2MetadataRequest, $root.nebulaidl.service.OAuth2MetadataResponse, request, callback);
                }, "name", { value: "GetOAuth2Metadata" });
    
                /**
                 * Calls GetOAuth2Metadata.
                 * @function getOAuth2Metadata
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @instance
                 * @param {nebulaidl.service.IOAuth2MetadataRequest} request OAuth2MetadataRequest message or plain object
                 * @returns {Promise<nebulaidl.service.OAuth2MetadataResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.AuthMetadataService#getPublicClientConfig}.
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @typedef GetPublicClientConfigCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.PublicClientAuthConfigResponse} [response] PublicClientAuthConfigResponse
                 */
    
                /**
                 * Calls GetPublicClientConfig.
                 * @function getPublicClientConfig
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @instance
                 * @param {nebulaidl.service.IPublicClientAuthConfigRequest} request PublicClientAuthConfigRequest message or plain object
                 * @param {nebulaidl.service.AuthMetadataService.GetPublicClientConfigCallback} callback Node-style callback called with the error, if any, and PublicClientAuthConfigResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthMetadataService.prototype.getPublicClientConfig = function getPublicClientConfig(request, callback) {
                    return this.rpcCall(getPublicClientConfig, $root.nebulaidl.service.PublicClientAuthConfigRequest, $root.nebulaidl.service.PublicClientAuthConfigResponse, request, callback);
                }, "name", { value: "GetPublicClientConfig" });
    
                /**
                 * Calls GetPublicClientConfig.
                 * @function getPublicClientConfig
                 * @memberof nebulaidl.service.AuthMetadataService
                 * @instance
                 * @param {nebulaidl.service.IPublicClientAuthConfigRequest} request PublicClientAuthConfigRequest message or plain object
                 * @returns {Promise<nebulaidl.service.PublicClientAuthConfigResponse>} Promise
                 * @variation 2
                 */
    
                return AuthMetadataService;
            })();
    
            service.CreateUploadLocationResponse = (function() {
    
                /**
                 * Properties of a CreateUploadLocationResponse.
                 * @memberof nebulaidl.service
                 * @interface ICreateUploadLocationResponse
                 * @property {string|null} [signedUrl] CreateUploadLocationResponse signedUrl
                 * @property {string|null} [nativeUrl] CreateUploadLocationResponse nativeUrl
                 * @property {google.protobuf.ITimestamp|null} [expiresAt] CreateUploadLocationResponse expiresAt
                 */
    
                /**
                 * Constructs a new CreateUploadLocationResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a CreateUploadLocationResponse.
                 * @implements ICreateUploadLocationResponse
                 * @constructor
                 * @param {nebulaidl.service.ICreateUploadLocationResponse=} [properties] Properties to set
                 */
                function CreateUploadLocationResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateUploadLocationResponse signedUrl.
                 * @member {string} signedUrl
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @instance
                 */
                CreateUploadLocationResponse.prototype.signedUrl = "";
    
                /**
                 * CreateUploadLocationResponse nativeUrl.
                 * @member {string} nativeUrl
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @instance
                 */
                CreateUploadLocationResponse.prototype.nativeUrl = "";
    
                /**
                 * CreateUploadLocationResponse expiresAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @instance
                 */
                CreateUploadLocationResponse.prototype.expiresAt = null;
    
                /**
                 * Creates a new CreateUploadLocationResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @static
                 * @param {nebulaidl.service.ICreateUploadLocationResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.CreateUploadLocationResponse} CreateUploadLocationResponse instance
                 */
                CreateUploadLocationResponse.create = function create(properties) {
                    return new CreateUploadLocationResponse(properties);
                };
    
                /**
                 * Encodes the specified CreateUploadLocationResponse message. Does not implicitly {@link nebulaidl.service.CreateUploadLocationResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @static
                 * @param {nebulaidl.service.ICreateUploadLocationResponse} message CreateUploadLocationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateUploadLocationResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signedUrl != null && message.hasOwnProperty("signedUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.signedUrl);
                    if (message.nativeUrl != null && message.hasOwnProperty("nativeUrl"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nativeUrl);
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                        $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateUploadLocationResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.CreateUploadLocationResponse} CreateUploadLocationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateUploadLocationResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.CreateUploadLocationResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.signedUrl = reader.string();
                            break;
                        case 2:
                            message.nativeUrl = reader.string();
                            break;
                        case 3:
                            message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateUploadLocationResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.CreateUploadLocationResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateUploadLocationResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signedUrl != null && message.hasOwnProperty("signedUrl"))
                        if (!$util.isString(message.signedUrl))
                            return "signedUrl: string expected";
                    if (message.nativeUrl != null && message.hasOwnProperty("nativeUrl"))
                        if (!$util.isString(message.nativeUrl))
                            return "nativeUrl: string expected";
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                        if (error)
                            return "expiresAt." + error;
                    }
                    return null;
                };
    
                return CreateUploadLocationResponse;
            })();
    
            service.CreateUploadLocationRequest = (function() {
    
                /**
                 * Properties of a CreateUploadLocationRequest.
                 * @memberof nebulaidl.service
                 * @interface ICreateUploadLocationRequest
                 * @property {string|null} [project] CreateUploadLocationRequest project
                 * @property {string|null} [domain] CreateUploadLocationRequest domain
                 * @property {string|null} [filename] CreateUploadLocationRequest filename
                 * @property {google.protobuf.IDuration|null} [expiresIn] CreateUploadLocationRequest expiresIn
                 * @property {Uint8Array|null} [contentMd5] CreateUploadLocationRequest contentMd5
                 * @property {string|null} [filenameRoot] CreateUploadLocationRequest filenameRoot
                 */
    
                /**
                 * Constructs a new CreateUploadLocationRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a CreateUploadLocationRequest.
                 * @implements ICreateUploadLocationRequest
                 * @constructor
                 * @param {nebulaidl.service.ICreateUploadLocationRequest=} [properties] Properties to set
                 */
                function CreateUploadLocationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateUploadLocationRequest project.
                 * @member {string} project
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @instance
                 */
                CreateUploadLocationRequest.prototype.project = "";
    
                /**
                 * CreateUploadLocationRequest domain.
                 * @member {string} domain
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @instance
                 */
                CreateUploadLocationRequest.prototype.domain = "";
    
                /**
                 * CreateUploadLocationRequest filename.
                 * @member {string} filename
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @instance
                 */
                CreateUploadLocationRequest.prototype.filename = "";
    
                /**
                 * CreateUploadLocationRequest expiresIn.
                 * @member {google.protobuf.IDuration|null|undefined} expiresIn
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @instance
                 */
                CreateUploadLocationRequest.prototype.expiresIn = null;
    
                /**
                 * CreateUploadLocationRequest contentMd5.
                 * @member {Uint8Array} contentMd5
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @instance
                 */
                CreateUploadLocationRequest.prototype.contentMd5 = $util.newBuffer([]);
    
                /**
                 * CreateUploadLocationRequest filenameRoot.
                 * @member {string} filenameRoot
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @instance
                 */
                CreateUploadLocationRequest.prototype.filenameRoot = "";
    
                /**
                 * Creates a new CreateUploadLocationRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @static
                 * @param {nebulaidl.service.ICreateUploadLocationRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.CreateUploadLocationRequest} CreateUploadLocationRequest instance
                 */
                CreateUploadLocationRequest.create = function create(properties) {
                    return new CreateUploadLocationRequest(properties);
                };
    
                /**
                 * Encodes the specified CreateUploadLocationRequest message. Does not implicitly {@link nebulaidl.service.CreateUploadLocationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @static
                 * @param {nebulaidl.service.ICreateUploadLocationRequest} message CreateUploadLocationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateUploadLocationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.project != null && message.hasOwnProperty("project"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.domain);
                    if (message.filename != null && message.hasOwnProperty("filename"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.filename);
                    if (message.expiresIn != null && message.hasOwnProperty("expiresIn"))
                        $root.google.protobuf.Duration.encode(message.expiresIn, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.contentMd5 != null && message.hasOwnProperty("contentMd5"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.contentMd5);
                    if (message.filenameRoot != null && message.hasOwnProperty("filenameRoot"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.filenameRoot);
                    return writer;
                };
    
                /**
                 * Decodes a CreateUploadLocationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.CreateUploadLocationRequest} CreateUploadLocationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateUploadLocationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.CreateUploadLocationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.project = reader.string();
                            break;
                        case 2:
                            message.domain = reader.string();
                            break;
                        case 3:
                            message.filename = reader.string();
                            break;
                        case 4:
                            message.expiresIn = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.contentMd5 = reader.bytes();
                            break;
                        case 6:
                            message.filenameRoot = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateUploadLocationRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.CreateUploadLocationRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateUploadLocationRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.filename != null && message.hasOwnProperty("filename"))
                        if (!$util.isString(message.filename))
                            return "filename: string expected";
                    if (message.expiresIn != null && message.hasOwnProperty("expiresIn")) {
                        var error = $root.google.protobuf.Duration.verify(message.expiresIn);
                        if (error)
                            return "expiresIn." + error;
                    }
                    if (message.contentMd5 != null && message.hasOwnProperty("contentMd5"))
                        if (!(message.contentMd5 && typeof message.contentMd5.length === "number" || $util.isString(message.contentMd5)))
                            return "contentMd5: buffer expected";
                    if (message.filenameRoot != null && message.hasOwnProperty("filenameRoot"))
                        if (!$util.isString(message.filenameRoot))
                            return "filenameRoot: string expected";
                    return null;
                };
    
                return CreateUploadLocationRequest;
            })();
    
            service.CreateDownloadLocationRequest = (function() {
    
                /**
                 * Properties of a CreateDownloadLocationRequest.
                 * @memberof nebulaidl.service
                 * @interface ICreateDownloadLocationRequest
                 * @property {string|null} [nativeUrl] CreateDownloadLocationRequest nativeUrl
                 * @property {google.protobuf.IDuration|null} [expiresIn] CreateDownloadLocationRequest expiresIn
                 */
    
                /**
                 * Constructs a new CreateDownloadLocationRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a CreateDownloadLocationRequest.
                 * @implements ICreateDownloadLocationRequest
                 * @constructor
                 * @param {nebulaidl.service.ICreateDownloadLocationRequest=} [properties] Properties to set
                 */
                function CreateDownloadLocationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateDownloadLocationRequest nativeUrl.
                 * @member {string} nativeUrl
                 * @memberof nebulaidl.service.CreateDownloadLocationRequest
                 * @instance
                 */
                CreateDownloadLocationRequest.prototype.nativeUrl = "";
    
                /**
                 * CreateDownloadLocationRequest expiresIn.
                 * @member {google.protobuf.IDuration|null|undefined} expiresIn
                 * @memberof nebulaidl.service.CreateDownloadLocationRequest
                 * @instance
                 */
                CreateDownloadLocationRequest.prototype.expiresIn = null;
    
                /**
                 * Creates a new CreateDownloadLocationRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.CreateDownloadLocationRequest
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLocationRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.CreateDownloadLocationRequest} CreateDownloadLocationRequest instance
                 */
                CreateDownloadLocationRequest.create = function create(properties) {
                    return new CreateDownloadLocationRequest(properties);
                };
    
                /**
                 * Encodes the specified CreateDownloadLocationRequest message. Does not implicitly {@link nebulaidl.service.CreateDownloadLocationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.CreateDownloadLocationRequest
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLocationRequest} message CreateDownloadLocationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDownloadLocationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nativeUrl != null && message.hasOwnProperty("nativeUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nativeUrl);
                    if (message.expiresIn != null && message.hasOwnProperty("expiresIn"))
                        $root.google.protobuf.Duration.encode(message.expiresIn, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateDownloadLocationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.CreateDownloadLocationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.CreateDownloadLocationRequest} CreateDownloadLocationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDownloadLocationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.CreateDownloadLocationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nativeUrl = reader.string();
                            break;
                        case 2:
                            message.expiresIn = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateDownloadLocationRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.CreateDownloadLocationRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateDownloadLocationRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nativeUrl != null && message.hasOwnProperty("nativeUrl"))
                        if (!$util.isString(message.nativeUrl))
                            return "nativeUrl: string expected";
                    if (message.expiresIn != null && message.hasOwnProperty("expiresIn")) {
                        var error = $root.google.protobuf.Duration.verify(message.expiresIn);
                        if (error)
                            return "expiresIn." + error;
                    }
                    return null;
                };
    
                return CreateDownloadLocationRequest;
            })();
    
            service.CreateDownloadLocationResponse = (function() {
    
                /**
                 * Properties of a CreateDownloadLocationResponse.
                 * @memberof nebulaidl.service
                 * @interface ICreateDownloadLocationResponse
                 * @property {string|null} [signedUrl] CreateDownloadLocationResponse signedUrl
                 * @property {google.protobuf.ITimestamp|null} [expiresAt] CreateDownloadLocationResponse expiresAt
                 */
    
                /**
                 * Constructs a new CreateDownloadLocationResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a CreateDownloadLocationResponse.
                 * @implements ICreateDownloadLocationResponse
                 * @constructor
                 * @param {nebulaidl.service.ICreateDownloadLocationResponse=} [properties] Properties to set
                 */
                function CreateDownloadLocationResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateDownloadLocationResponse signedUrl.
                 * @member {string} signedUrl
                 * @memberof nebulaidl.service.CreateDownloadLocationResponse
                 * @instance
                 */
                CreateDownloadLocationResponse.prototype.signedUrl = "";
    
                /**
                 * CreateDownloadLocationResponse expiresAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                 * @memberof nebulaidl.service.CreateDownloadLocationResponse
                 * @instance
                 */
                CreateDownloadLocationResponse.prototype.expiresAt = null;
    
                /**
                 * Creates a new CreateDownloadLocationResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.CreateDownloadLocationResponse
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLocationResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.CreateDownloadLocationResponse} CreateDownloadLocationResponse instance
                 */
                CreateDownloadLocationResponse.create = function create(properties) {
                    return new CreateDownloadLocationResponse(properties);
                };
    
                /**
                 * Encodes the specified CreateDownloadLocationResponse message. Does not implicitly {@link nebulaidl.service.CreateDownloadLocationResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.CreateDownloadLocationResponse
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLocationResponse} message CreateDownloadLocationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDownloadLocationResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signedUrl != null && message.hasOwnProperty("signedUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.signedUrl);
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                        $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateDownloadLocationResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.CreateDownloadLocationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.CreateDownloadLocationResponse} CreateDownloadLocationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDownloadLocationResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.CreateDownloadLocationResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.signedUrl = reader.string();
                            break;
                        case 2:
                            message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateDownloadLocationResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.CreateDownloadLocationResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateDownloadLocationResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signedUrl != null && message.hasOwnProperty("signedUrl"))
                        if (!$util.isString(message.signedUrl))
                            return "signedUrl: string expected";
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                        if (error)
                            return "expiresAt." + error;
                    }
                    return null;
                };
    
                return CreateDownloadLocationResponse;
            })();
    
            /**
             * ArtifactType enum.
             * @name nebulaidl.service.ArtifactType
             * @enum {string}
             * @property {number} ARTIFACT_TYPE_UNDEFINED=0 ARTIFACT_TYPE_UNDEFINED value
             * @property {number} ARTIFACT_TYPE_DECK=1 ARTIFACT_TYPE_DECK value
             */
            service.ArtifactType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ARTIFACT_TYPE_UNDEFINED"] = 0;
                values[valuesById[1] = "ARTIFACT_TYPE_DECK"] = 1;
                return values;
            })();
    
            service.CreateDownloadLinkRequest = (function() {
    
                /**
                 * Properties of a CreateDownloadLinkRequest.
                 * @memberof nebulaidl.service
                 * @interface ICreateDownloadLinkRequest
                 * @property {nebulaidl.service.ArtifactType|null} [artifactType] CreateDownloadLinkRequest artifactType
                 * @property {google.protobuf.IDuration|null} [expiresIn] CreateDownloadLinkRequest expiresIn
                 * @property {nebulaidl.core.INodeExecutionIdentifier|null} [nodeExecutionId] CreateDownloadLinkRequest nodeExecutionId
                 */
    
                /**
                 * Constructs a new CreateDownloadLinkRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a CreateDownloadLinkRequest.
                 * @implements ICreateDownloadLinkRequest
                 * @constructor
                 * @param {nebulaidl.service.ICreateDownloadLinkRequest=} [properties] Properties to set
                 */
                function CreateDownloadLinkRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateDownloadLinkRequest artifactType.
                 * @member {nebulaidl.service.ArtifactType} artifactType
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @instance
                 */
                CreateDownloadLinkRequest.prototype.artifactType = 0;
    
                /**
                 * CreateDownloadLinkRequest expiresIn.
                 * @member {google.protobuf.IDuration|null|undefined} expiresIn
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @instance
                 */
                CreateDownloadLinkRequest.prototype.expiresIn = null;
    
                /**
                 * CreateDownloadLinkRequest nodeExecutionId.
                 * @member {nebulaidl.core.INodeExecutionIdentifier|null|undefined} nodeExecutionId
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @instance
                 */
                CreateDownloadLinkRequest.prototype.nodeExecutionId = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * CreateDownloadLinkRequest source.
                 * @member {"nodeExecutionId"|undefined} source
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @instance
                 */
                Object.defineProperty(CreateDownloadLinkRequest.prototype, "source", {
                    get: $util.oneOfGetter($oneOfFields = ["nodeExecutionId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new CreateDownloadLinkRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLinkRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.CreateDownloadLinkRequest} CreateDownloadLinkRequest instance
                 */
                CreateDownloadLinkRequest.create = function create(properties) {
                    return new CreateDownloadLinkRequest(properties);
                };
    
                /**
                 * Encodes the specified CreateDownloadLinkRequest message. Does not implicitly {@link nebulaidl.service.CreateDownloadLinkRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLinkRequest} message CreateDownloadLinkRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDownloadLinkRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.artifactType != null && message.hasOwnProperty("artifactType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.artifactType);
                    if (message.expiresIn != null && message.hasOwnProperty("expiresIn"))
                        $root.google.protobuf.Duration.encode(message.expiresIn, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId"))
                        $root.nebulaidl.core.NodeExecutionIdentifier.encode(message.nodeExecutionId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateDownloadLinkRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.CreateDownloadLinkRequest} CreateDownloadLinkRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDownloadLinkRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.CreateDownloadLinkRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.artifactType = reader.int32();
                            break;
                        case 2:
                            message.expiresIn = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.nodeExecutionId = $root.nebulaidl.core.NodeExecutionIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateDownloadLinkRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.CreateDownloadLinkRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateDownloadLinkRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.artifactType != null && message.hasOwnProperty("artifactType"))
                        switch (message.artifactType) {
                        default:
                            return "artifactType: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.expiresIn != null && message.hasOwnProperty("expiresIn")) {
                        var error = $root.google.protobuf.Duration.verify(message.expiresIn);
                        if (error)
                            return "expiresIn." + error;
                    }
                    if (message.nodeExecutionId != null && message.hasOwnProperty("nodeExecutionId")) {
                        properties.source = 1;
                        {
                            var error = $root.nebulaidl.core.NodeExecutionIdentifier.verify(message.nodeExecutionId);
                            if (error)
                                return "nodeExecutionId." + error;
                        }
                    }
                    return null;
                };
    
                return CreateDownloadLinkRequest;
            })();
    
            service.CreateDownloadLinkResponse = (function() {
    
                /**
                 * Properties of a CreateDownloadLinkResponse.
                 * @memberof nebulaidl.service
                 * @interface ICreateDownloadLinkResponse
                 * @property {Array.<string>|null} [signedUrl] CreateDownloadLinkResponse signedUrl
                 * @property {google.protobuf.ITimestamp|null} [expiresAt] CreateDownloadLinkResponse expiresAt
                 * @property {nebulaidl.service.IPreSignedURLs|null} [preSignedUrls] CreateDownloadLinkResponse preSignedUrls
                 */
    
                /**
                 * Constructs a new CreateDownloadLinkResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a CreateDownloadLinkResponse.
                 * @implements ICreateDownloadLinkResponse
                 * @constructor
                 * @param {nebulaidl.service.ICreateDownloadLinkResponse=} [properties] Properties to set
                 */
                function CreateDownloadLinkResponse(properties) {
                    this.signedUrl = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateDownloadLinkResponse signedUrl.
                 * @member {Array.<string>} signedUrl
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @instance
                 */
                CreateDownloadLinkResponse.prototype.signedUrl = $util.emptyArray;
    
                /**
                 * CreateDownloadLinkResponse expiresAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @instance
                 */
                CreateDownloadLinkResponse.prototype.expiresAt = null;
    
                /**
                 * CreateDownloadLinkResponse preSignedUrls.
                 * @member {nebulaidl.service.IPreSignedURLs|null|undefined} preSignedUrls
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @instance
                 */
                CreateDownloadLinkResponse.prototype.preSignedUrls = null;
    
                /**
                 * Creates a new CreateDownloadLinkResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLinkResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.CreateDownloadLinkResponse} CreateDownloadLinkResponse instance
                 */
                CreateDownloadLinkResponse.create = function create(properties) {
                    return new CreateDownloadLinkResponse(properties);
                };
    
                /**
                 * Encodes the specified CreateDownloadLinkResponse message. Does not implicitly {@link nebulaidl.service.CreateDownloadLinkResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @static
                 * @param {nebulaidl.service.ICreateDownloadLinkResponse} message CreateDownloadLinkResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDownloadLinkResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signedUrl != null && message.signedUrl.length)
                        for (var i = 0; i < message.signedUrl.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signedUrl[i]);
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                        $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.preSignedUrls != null && message.hasOwnProperty("preSignedUrls"))
                        $root.nebulaidl.service.PreSignedURLs.encode(message.preSignedUrls, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a CreateDownloadLinkResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.CreateDownloadLinkResponse} CreateDownloadLinkResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDownloadLinkResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.CreateDownloadLinkResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.signedUrl && message.signedUrl.length))
                                message.signedUrl = [];
                            message.signedUrl.push(reader.string());
                            break;
                        case 2:
                            message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.preSignedUrls = $root.nebulaidl.service.PreSignedURLs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CreateDownloadLinkResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.CreateDownloadLinkResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateDownloadLinkResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signedUrl != null && message.hasOwnProperty("signedUrl")) {
                        if (!Array.isArray(message.signedUrl))
                            return "signedUrl: array expected";
                        for (var i = 0; i < message.signedUrl.length; ++i)
                            if (!$util.isString(message.signedUrl[i]))
                                return "signedUrl: string[] expected";
                    }
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                        if (error)
                            return "expiresAt." + error;
                    }
                    if (message.preSignedUrls != null && message.hasOwnProperty("preSignedUrls")) {
                        var error = $root.nebulaidl.service.PreSignedURLs.verify(message.preSignedUrls);
                        if (error)
                            return "preSignedUrls." + error;
                    }
                    return null;
                };
    
                return CreateDownloadLinkResponse;
            })();
    
            service.PreSignedURLs = (function() {
    
                /**
                 * Properties of a PreSignedURLs.
                 * @memberof nebulaidl.service
                 * @interface IPreSignedURLs
                 * @property {Array.<string>|null} [signedUrl] PreSignedURLs signedUrl
                 * @property {google.protobuf.ITimestamp|null} [expiresAt] PreSignedURLs expiresAt
                 */
    
                /**
                 * Constructs a new PreSignedURLs.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a PreSignedURLs.
                 * @implements IPreSignedURLs
                 * @constructor
                 * @param {nebulaidl.service.IPreSignedURLs=} [properties] Properties to set
                 */
                function PreSignedURLs(properties) {
                    this.signedUrl = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PreSignedURLs signedUrl.
                 * @member {Array.<string>} signedUrl
                 * @memberof nebulaidl.service.PreSignedURLs
                 * @instance
                 */
                PreSignedURLs.prototype.signedUrl = $util.emptyArray;
    
                /**
                 * PreSignedURLs expiresAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                 * @memberof nebulaidl.service.PreSignedURLs
                 * @instance
                 */
                PreSignedURLs.prototype.expiresAt = null;
    
                /**
                 * Creates a new PreSignedURLs instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.PreSignedURLs
                 * @static
                 * @param {nebulaidl.service.IPreSignedURLs=} [properties] Properties to set
                 * @returns {nebulaidl.service.PreSignedURLs} PreSignedURLs instance
                 */
                PreSignedURLs.create = function create(properties) {
                    return new PreSignedURLs(properties);
                };
    
                /**
                 * Encodes the specified PreSignedURLs message. Does not implicitly {@link nebulaidl.service.PreSignedURLs.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.PreSignedURLs
                 * @static
                 * @param {nebulaidl.service.IPreSignedURLs} message PreSignedURLs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PreSignedURLs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signedUrl != null && message.signedUrl.length)
                        for (var i = 0; i < message.signedUrl.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signedUrl[i]);
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                        $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a PreSignedURLs message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.PreSignedURLs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.PreSignedURLs} PreSignedURLs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PreSignedURLs.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.PreSignedURLs();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.signedUrl && message.signedUrl.length))
                                message.signedUrl = [];
                            message.signedUrl.push(reader.string());
                            break;
                        case 2:
                            message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a PreSignedURLs message.
                 * @function verify
                 * @memberof nebulaidl.service.PreSignedURLs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PreSignedURLs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signedUrl != null && message.hasOwnProperty("signedUrl")) {
                        if (!Array.isArray(message.signedUrl))
                            return "signedUrl: array expected";
                        for (var i = 0; i < message.signedUrl.length; ++i)
                            if (!$util.isString(message.signedUrl[i]))
                                return "signedUrl: string[] expected";
                    }
                    if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                        if (error)
                            return "expiresAt." + error;
                    }
                    return null;
                };
    
                return PreSignedURLs;
            })();
    
            service.GetDataRequest = (function() {
    
                /**
                 * Properties of a GetDataRequest.
                 * @memberof nebulaidl.service
                 * @interface IGetDataRequest
                 * @property {string|null} [nebulaUrl] GetDataRequest nebulaUrl
                 */
    
                /**
                 * Constructs a new GetDataRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a GetDataRequest.
                 * @implements IGetDataRequest
                 * @constructor
                 * @param {nebulaidl.service.IGetDataRequest=} [properties] Properties to set
                 */
                function GetDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetDataRequest nebulaUrl.
                 * @member {string} nebulaUrl
                 * @memberof nebulaidl.service.GetDataRequest
                 * @instance
                 */
                GetDataRequest.prototype.nebulaUrl = "";
    
                /**
                 * Creates a new GetDataRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.GetDataRequest
                 * @static
                 * @param {nebulaidl.service.IGetDataRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.GetDataRequest} GetDataRequest instance
                 */
                GetDataRequest.create = function create(properties) {
                    return new GetDataRequest(properties);
                };
    
                /**
                 * Encodes the specified GetDataRequest message. Does not implicitly {@link nebulaidl.service.GetDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.GetDataRequest
                 * @static
                 * @param {nebulaidl.service.IGetDataRequest} message GetDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nebulaUrl != null && message.hasOwnProperty("nebulaUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nebulaUrl);
                    return writer;
                };
    
                /**
                 * Decodes a GetDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.GetDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.GetDataRequest} GetDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.GetDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nebulaUrl = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GetDataRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.GetDataRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetDataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nebulaUrl != null && message.hasOwnProperty("nebulaUrl"))
                        if (!$util.isString(message.nebulaUrl))
                            return "nebulaUrl: string expected";
                    return null;
                };
    
                return GetDataRequest;
            })();
    
            service.GetDataResponse = (function() {
    
                /**
                 * Properties of a GetDataResponse.
                 * @memberof nebulaidl.service
                 * @interface IGetDataResponse
                 * @property {nebulaidl.core.ILiteralMap|null} [literalMap] GetDataResponse literalMap
                 * @property {nebulaidl.service.IPreSignedURLs|null} [preSignedUrls] GetDataResponse preSignedUrls
                 * @property {nebulaidl.core.ILiteral|null} [literal] GetDataResponse literal
                 */
    
                /**
                 * Constructs a new GetDataResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a GetDataResponse.
                 * @implements IGetDataResponse
                 * @constructor
                 * @param {nebulaidl.service.IGetDataResponse=} [properties] Properties to set
                 */
                function GetDataResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetDataResponse literalMap.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} literalMap
                 * @memberof nebulaidl.service.GetDataResponse
                 * @instance
                 */
                GetDataResponse.prototype.literalMap = null;
    
                /**
                 * GetDataResponse preSignedUrls.
                 * @member {nebulaidl.service.IPreSignedURLs|null|undefined} preSignedUrls
                 * @memberof nebulaidl.service.GetDataResponse
                 * @instance
                 */
                GetDataResponse.prototype.preSignedUrls = null;
    
                /**
                 * GetDataResponse literal.
                 * @member {nebulaidl.core.ILiteral|null|undefined} literal
                 * @memberof nebulaidl.service.GetDataResponse
                 * @instance
                 */
                GetDataResponse.prototype.literal = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * GetDataResponse data.
                 * @member {"literalMap"|"preSignedUrls"|"literal"|undefined} data
                 * @memberof nebulaidl.service.GetDataResponse
                 * @instance
                 */
                Object.defineProperty(GetDataResponse.prototype, "data", {
                    get: $util.oneOfGetter($oneOfFields = ["literalMap", "preSignedUrls", "literal"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new GetDataResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.GetDataResponse
                 * @static
                 * @param {nebulaidl.service.IGetDataResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.GetDataResponse} GetDataResponse instance
                 */
                GetDataResponse.create = function create(properties) {
                    return new GetDataResponse(properties);
                };
    
                /**
                 * Encodes the specified GetDataResponse message. Does not implicitly {@link nebulaidl.service.GetDataResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.GetDataResponse
                 * @static
                 * @param {nebulaidl.service.IGetDataResponse} message GetDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetDataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.literalMap != null && message.hasOwnProperty("literalMap"))
                        $root.nebulaidl.core.LiteralMap.encode(message.literalMap, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.preSignedUrls != null && message.hasOwnProperty("preSignedUrls"))
                        $root.nebulaidl.service.PreSignedURLs.encode(message.preSignedUrls, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.literal != null && message.hasOwnProperty("literal"))
                        $root.nebulaidl.core.Literal.encode(message.literal, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetDataResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.GetDataResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.GetDataResponse} GetDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetDataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.GetDataResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.literalMap = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.preSignedUrls = $root.nebulaidl.service.PreSignedURLs.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.literal = $root.nebulaidl.core.Literal.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GetDataResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.GetDataResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetDataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.literalMap != null && message.hasOwnProperty("literalMap")) {
                        properties.data = 1;
                        {
                            var error = $root.nebulaidl.core.LiteralMap.verify(message.literalMap);
                            if (error)
                                return "literalMap." + error;
                        }
                    }
                    if (message.preSignedUrls != null && message.hasOwnProperty("preSignedUrls")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.nebulaidl.service.PreSignedURLs.verify(message.preSignedUrls);
                            if (error)
                                return "preSignedUrls." + error;
                        }
                    }
                    if (message.literal != null && message.hasOwnProperty("literal")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.nebulaidl.core.Literal.verify(message.literal);
                            if (error)
                                return "literal." + error;
                        }
                    }
                    return null;
                };
    
                return GetDataResponse;
            })();
    
            service.DataProxyService = (function() {
    
                /**
                 * Constructs a new DataProxyService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a DataProxyService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function DataProxyService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (DataProxyService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DataProxyService;
    
                /**
                 * Creates new DataProxyService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.DataProxyService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {DataProxyService} RPC service. Useful where requests and/or responses are streamed.
                 */
                DataProxyService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.DataProxyService#createUploadLocation}.
                 * @memberof nebulaidl.service.DataProxyService
                 * @typedef CreateUploadLocationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.CreateUploadLocationResponse} [response] CreateUploadLocationResponse
                 */
    
                /**
                 * Calls CreateUploadLocation.
                 * @function createUploadLocation
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.ICreateUploadLocationRequest} request CreateUploadLocationRequest message or plain object
                 * @param {nebulaidl.service.DataProxyService.CreateUploadLocationCallback} callback Node-style callback called with the error, if any, and CreateUploadLocationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DataProxyService.prototype.createUploadLocation = function createUploadLocation(request, callback) {
                    return this.rpcCall(createUploadLocation, $root.nebulaidl.service.CreateUploadLocationRequest, $root.nebulaidl.service.CreateUploadLocationResponse, request, callback);
                }, "name", { value: "CreateUploadLocation" });
    
                /**
                 * Calls CreateUploadLocation.
                 * @function createUploadLocation
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.ICreateUploadLocationRequest} request CreateUploadLocationRequest message or plain object
                 * @returns {Promise<nebulaidl.service.CreateUploadLocationResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.DataProxyService#createDownloadLocation}.
                 * @memberof nebulaidl.service.DataProxyService
                 * @typedef CreateDownloadLocationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.CreateDownloadLocationResponse} [response] CreateDownloadLocationResponse
                 */
    
                /**
                 * Calls CreateDownloadLocation.
                 * @function createDownloadLocation
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.ICreateDownloadLocationRequest} request CreateDownloadLocationRequest message or plain object
                 * @param {nebulaidl.service.DataProxyService.CreateDownloadLocationCallback} callback Node-style callback called with the error, if any, and CreateDownloadLocationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DataProxyService.prototype.createDownloadLocation = function createDownloadLocation(request, callback) {
                    return this.rpcCall(createDownloadLocation, $root.nebulaidl.service.CreateDownloadLocationRequest, $root.nebulaidl.service.CreateDownloadLocationResponse, request, callback);
                }, "name", { value: "CreateDownloadLocation" });
    
                /**
                 * Calls CreateDownloadLocation.
                 * @function createDownloadLocation
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.ICreateDownloadLocationRequest} request CreateDownloadLocationRequest message or plain object
                 * @returns {Promise<nebulaidl.service.CreateDownloadLocationResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.DataProxyService#createDownloadLink}.
                 * @memberof nebulaidl.service.DataProxyService
                 * @typedef CreateDownloadLinkCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.CreateDownloadLinkResponse} [response] CreateDownloadLinkResponse
                 */
    
                /**
                 * Calls CreateDownloadLink.
                 * @function createDownloadLink
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.ICreateDownloadLinkRequest} request CreateDownloadLinkRequest message or plain object
                 * @param {nebulaidl.service.DataProxyService.CreateDownloadLinkCallback} callback Node-style callback called with the error, if any, and CreateDownloadLinkResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DataProxyService.prototype.createDownloadLink = function createDownloadLink(request, callback) {
                    return this.rpcCall(createDownloadLink, $root.nebulaidl.service.CreateDownloadLinkRequest, $root.nebulaidl.service.CreateDownloadLinkResponse, request, callback);
                }, "name", { value: "CreateDownloadLink" });
    
                /**
                 * Calls CreateDownloadLink.
                 * @function createDownloadLink
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.ICreateDownloadLinkRequest} request CreateDownloadLinkRequest message or plain object
                 * @returns {Promise<nebulaidl.service.CreateDownloadLinkResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.DataProxyService#getData}.
                 * @memberof nebulaidl.service.DataProxyService
                 * @typedef GetDataCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.GetDataResponse} [response] GetDataResponse
                 */
    
                /**
                 * Calls GetData.
                 * @function getData
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.IGetDataRequest} request GetDataRequest message or plain object
                 * @param {nebulaidl.service.DataProxyService.GetDataCallback} callback Node-style callback called with the error, if any, and GetDataResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DataProxyService.prototype.getData = function getData(request, callback) {
                    return this.rpcCall(getData, $root.nebulaidl.service.GetDataRequest, $root.nebulaidl.service.GetDataResponse, request, callback);
                }, "name", { value: "GetData" });
    
                /**
                 * Calls GetData.
                 * @function getData
                 * @memberof nebulaidl.service.DataProxyService
                 * @instance
                 * @param {nebulaidl.service.IGetDataRequest} request GetDataRequest message or plain object
                 * @returns {Promise<nebulaidl.service.GetDataResponse>} Promise
                 * @variation 2
                 */
    
                return DataProxyService;
            })();
    
            service.ExternalPluginService = (function() {
    
                /**
                 * Constructs a new ExternalPluginService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents an ExternalPluginService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ExternalPluginService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (ExternalPluginService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ExternalPluginService;
    
                /**
                 * Creates new ExternalPluginService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ExternalPluginService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ExternalPluginService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.ExternalPluginService#createTask}.
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @typedef CreateTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.TaskCreateResponse} [response] TaskCreateResponse
                 */
    
                /**
                 * Calls CreateTask.
                 * @function createTask
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @instance
                 * @param {nebulaidl.service.ITaskCreateRequest} request TaskCreateRequest message or plain object
                 * @param {nebulaidl.service.ExternalPluginService.CreateTaskCallback} callback Node-style callback called with the error, if any, and TaskCreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ExternalPluginService.prototype.createTask = function createTask(request, callback) {
                    return this.rpcCall(createTask, $root.nebulaidl.service.TaskCreateRequest, $root.nebulaidl.service.TaskCreateResponse, request, callback);
                }, "name", { value: "CreateTask" });
    
                /**
                 * Calls CreateTask.
                 * @function createTask
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @instance
                 * @param {nebulaidl.service.ITaskCreateRequest} request TaskCreateRequest message or plain object
                 * @returns {Promise<nebulaidl.service.TaskCreateResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.ExternalPluginService#getTask}.
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @typedef GetTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.TaskGetResponse} [response] TaskGetResponse
                 */
    
                /**
                 * Calls GetTask.
                 * @function getTask
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @instance
                 * @param {nebulaidl.service.ITaskGetRequest} request TaskGetRequest message or plain object
                 * @param {nebulaidl.service.ExternalPluginService.GetTaskCallback} callback Node-style callback called with the error, if any, and TaskGetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ExternalPluginService.prototype.getTask = function getTask(request, callback) {
                    return this.rpcCall(getTask, $root.nebulaidl.service.TaskGetRequest, $root.nebulaidl.service.TaskGetResponse, request, callback);
                }, "name", { value: "GetTask" });
    
                /**
                 * Calls GetTask.
                 * @function getTask
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @instance
                 * @param {nebulaidl.service.ITaskGetRequest} request TaskGetRequest message or plain object
                 * @returns {Promise<nebulaidl.service.TaskGetResponse>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.ExternalPluginService#deleteTask}.
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @typedef DeleteTaskCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.TaskDeleteResponse} [response] TaskDeleteResponse
                 */
    
                /**
                 * Calls DeleteTask.
                 * @function deleteTask
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @instance
                 * @param {nebulaidl.service.ITaskDeleteRequest} request TaskDeleteRequest message or plain object
                 * @param {nebulaidl.service.ExternalPluginService.DeleteTaskCallback} callback Node-style callback called with the error, if any, and TaskDeleteResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ExternalPluginService.prototype.deleteTask = function deleteTask(request, callback) {
                    return this.rpcCall(deleteTask, $root.nebulaidl.service.TaskDeleteRequest, $root.nebulaidl.service.TaskDeleteResponse, request, callback);
                }, "name", { value: "DeleteTask" });
    
                /**
                 * Calls DeleteTask.
                 * @function deleteTask
                 * @memberof nebulaidl.service.ExternalPluginService
                 * @instance
                 * @param {nebulaidl.service.ITaskDeleteRequest} request TaskDeleteRequest message or plain object
                 * @returns {Promise<nebulaidl.service.TaskDeleteResponse>} Promise
                 * @variation 2
                 */
    
                return ExternalPluginService;
            })();
    
            /**
             * State enum.
             * @name nebulaidl.service.State
             * @enum {string}
             * @property {number} RETRYABLE_FAILURE=0 RETRYABLE_FAILURE value
             * @property {number} PERMANENT_FAILURE=1 PERMANENT_FAILURE value
             * @property {number} PENDING=2 PENDING value
             * @property {number} RUNNING=3 RUNNING value
             * @property {number} SUCCEEDED=4 SUCCEEDED value
             */
            service.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RETRYABLE_FAILURE"] = 0;
                values[valuesById[1] = "PERMANENT_FAILURE"] = 1;
                values[valuesById[2] = "PENDING"] = 2;
                values[valuesById[3] = "RUNNING"] = 3;
                values[valuesById[4] = "SUCCEEDED"] = 4;
                return values;
            })();
    
            service.TaskCreateRequest = (function() {
    
                /**
                 * Properties of a TaskCreateRequest.
                 * @memberof nebulaidl.service
                 * @interface ITaskCreateRequest
                 * @property {nebulaidl.core.ILiteralMap|null} [inputs] TaskCreateRequest inputs
                 * @property {nebulaidl.core.ITaskTemplate|null} [template] TaskCreateRequest template
                 * @property {string|null} [outputPrefix] TaskCreateRequest outputPrefix
                 */
    
                /**
                 * Constructs a new TaskCreateRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a TaskCreateRequest.
                 * @implements ITaskCreateRequest
                 * @constructor
                 * @param {nebulaidl.service.ITaskCreateRequest=} [properties] Properties to set
                 */
                function TaskCreateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskCreateRequest inputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} inputs
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @instance
                 */
                TaskCreateRequest.prototype.inputs = null;
    
                /**
                 * TaskCreateRequest template.
                 * @member {nebulaidl.core.ITaskTemplate|null|undefined} template
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @instance
                 */
                TaskCreateRequest.prototype.template = null;
    
                /**
                 * TaskCreateRequest outputPrefix.
                 * @member {string} outputPrefix
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @instance
                 */
                TaskCreateRequest.prototype.outputPrefix = "";
    
                /**
                 * Creates a new TaskCreateRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @static
                 * @param {nebulaidl.service.ITaskCreateRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.TaskCreateRequest} TaskCreateRequest instance
                 */
                TaskCreateRequest.create = function create(properties) {
                    return new TaskCreateRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskCreateRequest message. Does not implicitly {@link nebulaidl.service.TaskCreateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @static
                 * @param {nebulaidl.service.ITaskCreateRequest} message TaskCreateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskCreateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.hasOwnProperty("inputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.inputs, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.template != null && message.hasOwnProperty("template"))
                        $root.nebulaidl.core.TaskTemplate.encode(message.template, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.outputPrefix != null && message.hasOwnProperty("outputPrefix"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputPrefix);
                    return writer;
                };
    
                /**
                 * Decodes a TaskCreateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.TaskCreateRequest} TaskCreateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskCreateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.TaskCreateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.template = $root.nebulaidl.core.TaskTemplate.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.outputPrefix = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskCreateRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.TaskCreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskCreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.inputs);
                        if (error)
                            return "inputs." + error;
                    }
                    if (message.template != null && message.hasOwnProperty("template")) {
                        var error = $root.nebulaidl.core.TaskTemplate.verify(message.template);
                        if (error)
                            return "template." + error;
                    }
                    if (message.outputPrefix != null && message.hasOwnProperty("outputPrefix"))
                        if (!$util.isString(message.outputPrefix))
                            return "outputPrefix: string expected";
                    return null;
                };
    
                return TaskCreateRequest;
            })();
    
            service.TaskCreateResponse = (function() {
    
                /**
                 * Properties of a TaskCreateResponse.
                 * @memberof nebulaidl.service
                 * @interface ITaskCreateResponse
                 * @property {string|null} [jobId] TaskCreateResponse jobId
                 */
    
                /**
                 * Constructs a new TaskCreateResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a TaskCreateResponse.
                 * @implements ITaskCreateResponse
                 * @constructor
                 * @param {nebulaidl.service.ITaskCreateResponse=} [properties] Properties to set
                 */
                function TaskCreateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskCreateResponse jobId.
                 * @member {string} jobId
                 * @memberof nebulaidl.service.TaskCreateResponse
                 * @instance
                 */
                TaskCreateResponse.prototype.jobId = "";
    
                /**
                 * Creates a new TaskCreateResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.TaskCreateResponse
                 * @static
                 * @param {nebulaidl.service.ITaskCreateResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.TaskCreateResponse} TaskCreateResponse instance
                 */
                TaskCreateResponse.create = function create(properties) {
                    return new TaskCreateResponse(properties);
                };
    
                /**
                 * Encodes the specified TaskCreateResponse message. Does not implicitly {@link nebulaidl.service.TaskCreateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.TaskCreateResponse
                 * @static
                 * @param {nebulaidl.service.ITaskCreateResponse} message TaskCreateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskCreateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.jobId != null && message.hasOwnProperty("jobId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.jobId);
                    return writer;
                };
    
                /**
                 * Decodes a TaskCreateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.TaskCreateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.TaskCreateResponse} TaskCreateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskCreateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.TaskCreateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.jobId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskCreateResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.TaskCreateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskCreateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.jobId != null && message.hasOwnProperty("jobId"))
                        if (!$util.isString(message.jobId))
                            return "jobId: string expected";
                    return null;
                };
    
                return TaskCreateResponse;
            })();
    
            service.TaskGetRequest = (function() {
    
                /**
                 * Properties of a TaskGetRequest.
                 * @memberof nebulaidl.service
                 * @interface ITaskGetRequest
                 * @property {string|null} [taskType] TaskGetRequest taskType
                 * @property {string|null} [jobId] TaskGetRequest jobId
                 */
    
                /**
                 * Constructs a new TaskGetRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a TaskGetRequest.
                 * @implements ITaskGetRequest
                 * @constructor
                 * @param {nebulaidl.service.ITaskGetRequest=} [properties] Properties to set
                 */
                function TaskGetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskGetRequest taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.service.TaskGetRequest
                 * @instance
                 */
                TaskGetRequest.prototype.taskType = "";
    
                /**
                 * TaskGetRequest jobId.
                 * @member {string} jobId
                 * @memberof nebulaidl.service.TaskGetRequest
                 * @instance
                 */
                TaskGetRequest.prototype.jobId = "";
    
                /**
                 * Creates a new TaskGetRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.TaskGetRequest
                 * @static
                 * @param {nebulaidl.service.ITaskGetRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.TaskGetRequest} TaskGetRequest instance
                 */
                TaskGetRequest.create = function create(properties) {
                    return new TaskGetRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskGetRequest message. Does not implicitly {@link nebulaidl.service.TaskGetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.TaskGetRequest
                 * @static
                 * @param {nebulaidl.service.ITaskGetRequest} message TaskGetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskGetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskType);
                    if (message.jobId != null && message.hasOwnProperty("jobId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.jobId);
                    return writer;
                };
    
                /**
                 * Decodes a TaskGetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.TaskGetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.TaskGetRequest} TaskGetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskGetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.TaskGetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskType = reader.string();
                            break;
                        case 2:
                            message.jobId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskGetRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.TaskGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.jobId != null && message.hasOwnProperty("jobId"))
                        if (!$util.isString(message.jobId))
                            return "jobId: string expected";
                    return null;
                };
    
                return TaskGetRequest;
            })();
    
            service.TaskGetResponse = (function() {
    
                /**
                 * Properties of a TaskGetResponse.
                 * @memberof nebulaidl.service
                 * @interface ITaskGetResponse
                 * @property {nebulaidl.service.State|null} [state] TaskGetResponse state
                 * @property {nebulaidl.core.ILiteralMap|null} [outputs] TaskGetResponse outputs
                 */
    
                /**
                 * Constructs a new TaskGetResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a TaskGetResponse.
                 * @implements ITaskGetResponse
                 * @constructor
                 * @param {nebulaidl.service.ITaskGetResponse=} [properties] Properties to set
                 */
                function TaskGetResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskGetResponse state.
                 * @member {nebulaidl.service.State} state
                 * @memberof nebulaidl.service.TaskGetResponse
                 * @instance
                 */
                TaskGetResponse.prototype.state = 0;
    
                /**
                 * TaskGetResponse outputs.
                 * @member {nebulaidl.core.ILiteralMap|null|undefined} outputs
                 * @memberof nebulaidl.service.TaskGetResponse
                 * @instance
                 */
                TaskGetResponse.prototype.outputs = null;
    
                /**
                 * Creates a new TaskGetResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.TaskGetResponse
                 * @static
                 * @param {nebulaidl.service.ITaskGetResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.TaskGetResponse} TaskGetResponse instance
                 */
                TaskGetResponse.create = function create(properties) {
                    return new TaskGetResponse(properties);
                };
    
                /**
                 * Encodes the specified TaskGetResponse message. Does not implicitly {@link nebulaidl.service.TaskGetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.TaskGetResponse
                 * @static
                 * @param {nebulaidl.service.ITaskGetResponse} message TaskGetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskGetResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.outputs != null && message.hasOwnProperty("outputs"))
                        $root.nebulaidl.core.LiteralMap.encode(message.outputs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a TaskGetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.TaskGetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.TaskGetResponse} TaskGetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskGetResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.TaskGetResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = reader.int32();
                            break;
                        case 2:
                            message.outputs = $root.nebulaidl.core.LiteralMap.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskGetResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.TaskGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        var error = $root.nebulaidl.core.LiteralMap.verify(message.outputs);
                        if (error)
                            return "outputs." + error;
                    }
                    return null;
                };
    
                return TaskGetResponse;
            })();
    
            service.TaskDeleteRequest = (function() {
    
                /**
                 * Properties of a TaskDeleteRequest.
                 * @memberof nebulaidl.service
                 * @interface ITaskDeleteRequest
                 * @property {string|null} [taskType] TaskDeleteRequest taskType
                 * @property {string|null} [jobId] TaskDeleteRequest jobId
                 */
    
                /**
                 * Constructs a new TaskDeleteRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a TaskDeleteRequest.
                 * @implements ITaskDeleteRequest
                 * @constructor
                 * @param {nebulaidl.service.ITaskDeleteRequest=} [properties] Properties to set
                 */
                function TaskDeleteRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TaskDeleteRequest taskType.
                 * @member {string} taskType
                 * @memberof nebulaidl.service.TaskDeleteRequest
                 * @instance
                 */
                TaskDeleteRequest.prototype.taskType = "";
    
                /**
                 * TaskDeleteRequest jobId.
                 * @member {string} jobId
                 * @memberof nebulaidl.service.TaskDeleteRequest
                 * @instance
                 */
                TaskDeleteRequest.prototype.jobId = "";
    
                /**
                 * Creates a new TaskDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.TaskDeleteRequest
                 * @static
                 * @param {nebulaidl.service.ITaskDeleteRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.TaskDeleteRequest} TaskDeleteRequest instance
                 */
                TaskDeleteRequest.create = function create(properties) {
                    return new TaskDeleteRequest(properties);
                };
    
                /**
                 * Encodes the specified TaskDeleteRequest message. Does not implicitly {@link nebulaidl.service.TaskDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.TaskDeleteRequest
                 * @static
                 * @param {nebulaidl.service.ITaskDeleteRequest} message TaskDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskType);
                    if (message.jobId != null && message.hasOwnProperty("jobId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.jobId);
                    return writer;
                };
    
                /**
                 * Decodes a TaskDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.TaskDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.TaskDeleteRequest} TaskDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.TaskDeleteRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskType = reader.string();
                            break;
                        case 2:
                            message.jobId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskDeleteRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.TaskDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskType != null && message.hasOwnProperty("taskType"))
                        if (!$util.isString(message.taskType))
                            return "taskType: string expected";
                    if (message.jobId != null && message.hasOwnProperty("jobId"))
                        if (!$util.isString(message.jobId))
                            return "jobId: string expected";
                    return null;
                };
    
                return TaskDeleteRequest;
            })();
    
            service.TaskDeleteResponse = (function() {
    
                /**
                 * Properties of a TaskDeleteResponse.
                 * @memberof nebulaidl.service
                 * @interface ITaskDeleteResponse
                 */
    
                /**
                 * Constructs a new TaskDeleteResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a TaskDeleteResponse.
                 * @implements ITaskDeleteResponse
                 * @constructor
                 * @param {nebulaidl.service.ITaskDeleteResponse=} [properties] Properties to set
                 */
                function TaskDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new TaskDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.TaskDeleteResponse
                 * @static
                 * @param {nebulaidl.service.ITaskDeleteResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.TaskDeleteResponse} TaskDeleteResponse instance
                 */
                TaskDeleteResponse.create = function create(properties) {
                    return new TaskDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified TaskDeleteResponse message. Does not implicitly {@link nebulaidl.service.TaskDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.TaskDeleteResponse
                 * @static
                 * @param {nebulaidl.service.ITaskDeleteResponse} message TaskDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a TaskDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.TaskDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.TaskDeleteResponse} TaskDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.TaskDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a TaskDeleteResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.TaskDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return TaskDeleteResponse;
            })();
    
            service.UserInfoRequest = (function() {
    
                /**
                 * Properties of a UserInfoRequest.
                 * @memberof nebulaidl.service
                 * @interface IUserInfoRequest
                 */
    
                /**
                 * Constructs a new UserInfoRequest.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a UserInfoRequest.
                 * @implements IUserInfoRequest
                 * @constructor
                 * @param {nebulaidl.service.IUserInfoRequest=} [properties] Properties to set
                 */
                function UserInfoRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new UserInfoRequest instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.UserInfoRequest
                 * @static
                 * @param {nebulaidl.service.IUserInfoRequest=} [properties] Properties to set
                 * @returns {nebulaidl.service.UserInfoRequest} UserInfoRequest instance
                 */
                UserInfoRequest.create = function create(properties) {
                    return new UserInfoRequest(properties);
                };
    
                /**
                 * Encodes the specified UserInfoRequest message. Does not implicitly {@link nebulaidl.service.UserInfoRequest.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.UserInfoRequest
                 * @static
                 * @param {nebulaidl.service.IUserInfoRequest} message UserInfoRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UserInfoRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a UserInfoRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.UserInfoRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.UserInfoRequest} UserInfoRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UserInfoRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.UserInfoRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a UserInfoRequest message.
                 * @function verify
                 * @memberof nebulaidl.service.UserInfoRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UserInfoRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                return UserInfoRequest;
            })();
    
            service.UserInfoResponse = (function() {
    
                /**
                 * Properties of a UserInfoResponse.
                 * @memberof nebulaidl.service
                 * @interface IUserInfoResponse
                 * @property {string|null} [subject] UserInfoResponse subject
                 * @property {string|null} [name] UserInfoResponse name
                 * @property {string|null} [preferredUsername] UserInfoResponse preferredUsername
                 * @property {string|null} [givenName] UserInfoResponse givenName
                 * @property {string|null} [familyName] UserInfoResponse familyName
                 * @property {string|null} [email] UserInfoResponse email
                 * @property {string|null} [picture] UserInfoResponse picture
                 * @property {google.protobuf.IStruct|null} [additionalClaims] UserInfoResponse additionalClaims
                 */
    
                /**
                 * Constructs a new UserInfoResponse.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a UserInfoResponse.
                 * @implements IUserInfoResponse
                 * @constructor
                 * @param {nebulaidl.service.IUserInfoResponse=} [properties] Properties to set
                 */
                function UserInfoResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UserInfoResponse subject.
                 * @member {string} subject
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.subject = "";
    
                /**
                 * UserInfoResponse name.
                 * @member {string} name
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.name = "";
    
                /**
                 * UserInfoResponse preferredUsername.
                 * @member {string} preferredUsername
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.preferredUsername = "";
    
                /**
                 * UserInfoResponse givenName.
                 * @member {string} givenName
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.givenName = "";
    
                /**
                 * UserInfoResponse familyName.
                 * @member {string} familyName
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.familyName = "";
    
                /**
                 * UserInfoResponse email.
                 * @member {string} email
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.email = "";
    
                /**
                 * UserInfoResponse picture.
                 * @member {string} picture
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.picture = "";
    
                /**
                 * UserInfoResponse additionalClaims.
                 * @member {google.protobuf.IStruct|null|undefined} additionalClaims
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @instance
                 */
                UserInfoResponse.prototype.additionalClaims = null;
    
                /**
                 * Creates a new UserInfoResponse instance using the specified properties.
                 * @function create
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @static
                 * @param {nebulaidl.service.IUserInfoResponse=} [properties] Properties to set
                 * @returns {nebulaidl.service.UserInfoResponse} UserInfoResponse instance
                 */
                UserInfoResponse.create = function create(properties) {
                    return new UserInfoResponse(properties);
                };
    
                /**
                 * Encodes the specified UserInfoResponse message. Does not implicitly {@link nebulaidl.service.UserInfoResponse.verify|verify} messages.
                 * @function encode
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @static
                 * @param {nebulaidl.service.IUserInfoResponse} message UserInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UserInfoResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.subject != null && message.hasOwnProperty("subject"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.preferredUsername != null && message.hasOwnProperty("preferredUsername"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.preferredUsername);
                    if (message.givenName != null && message.hasOwnProperty("givenName"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.givenName);
                    if (message.familyName != null && message.hasOwnProperty("familyName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.familyName);
                    if (message.email != null && message.hasOwnProperty("email"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.email);
                    if (message.picture != null && message.hasOwnProperty("picture"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.picture);
                    if (message.additionalClaims != null && message.hasOwnProperty("additionalClaims"))
                        $root.google.protobuf.Struct.encode(message.additionalClaims, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a UserInfoResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {nebulaidl.service.UserInfoResponse} UserInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UserInfoResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nebulaidl.service.UserInfoResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.subject = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.preferredUsername = reader.string();
                            break;
                        case 4:
                            message.givenName = reader.string();
                            break;
                        case 5:
                            message.familyName = reader.string();
                            break;
                        case 6:
                            message.email = reader.string();
                            break;
                        case 7:
                            message.picture = reader.string();
                            break;
                        case 8:
                            message.additionalClaims = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a UserInfoResponse message.
                 * @function verify
                 * @memberof nebulaidl.service.UserInfoResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UserInfoResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.subject != null && message.hasOwnProperty("subject"))
                        if (!$util.isString(message.subject))
                            return "subject: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.preferredUsername != null && message.hasOwnProperty("preferredUsername"))
                        if (!$util.isString(message.preferredUsername))
                            return "preferredUsername: string expected";
                    if (message.givenName != null && message.hasOwnProperty("givenName"))
                        if (!$util.isString(message.givenName))
                            return "givenName: string expected";
                    if (message.familyName != null && message.hasOwnProperty("familyName"))
                        if (!$util.isString(message.familyName))
                            return "familyName: string expected";
                    if (message.email != null && message.hasOwnProperty("email"))
                        if (!$util.isString(message.email))
                            return "email: string expected";
                    if (message.picture != null && message.hasOwnProperty("picture"))
                        if (!$util.isString(message.picture))
                            return "picture: string expected";
                    if (message.additionalClaims != null && message.hasOwnProperty("additionalClaims")) {
                        var error = $root.google.protobuf.Struct.verify(message.additionalClaims);
                        if (error)
                            return "additionalClaims." + error;
                    }
                    return null;
                };
    
                return UserInfoResponse;
            })();
    
            service.IdentityService = (function() {
    
                /**
                 * Constructs a new IdentityService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents an IdentityService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function IdentityService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (IdentityService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = IdentityService;
    
                /**
                 * Creates new IdentityService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.IdentityService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {IdentityService} RPC service. Useful where requests and/or responses are streamed.
                 */
                IdentityService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.IdentityService#userInfo}.
                 * @memberof nebulaidl.service.IdentityService
                 * @typedef UserInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.service.UserInfoResponse} [response] UserInfoResponse
                 */
    
                /**
                 * Calls UserInfo.
                 * @function userInfo
                 * @memberof nebulaidl.service.IdentityService
                 * @instance
                 * @param {nebulaidl.service.IUserInfoRequest} request UserInfoRequest message or plain object
                 * @param {nebulaidl.service.IdentityService.UserInfoCallback} callback Node-style callback called with the error, if any, and UserInfoResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(IdentityService.prototype.userInfo = function userInfo(request, callback) {
                    return this.rpcCall(userInfo, $root.nebulaidl.service.UserInfoRequest, $root.nebulaidl.service.UserInfoResponse, request, callback);
                }, "name", { value: "UserInfo" });
    
                /**
                 * Calls UserInfo.
                 * @function userInfo
                 * @memberof nebulaidl.service.IdentityService
                 * @instance
                 * @param {nebulaidl.service.IUserInfoRequest} request UserInfoRequest message or plain object
                 * @returns {Promise<nebulaidl.service.UserInfoResponse>} Promise
                 * @variation 2
                 */
    
                return IdentityService;
            })();
    
            service.SignalService = (function() {
    
                /**
                 * Constructs a new SignalService service.
                 * @memberof nebulaidl.service
                 * @classdesc Represents a SignalService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function SignalService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (SignalService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SignalService;
    
                /**
                 * Creates new SignalService service using the specified rpc implementation.
                 * @function create
                 * @memberof nebulaidl.service.SignalService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {SignalService} RPC service. Useful where requests and/or responses are streamed.
                 */
                SignalService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link nebulaidl.service.SignalService#getOrCreateSignal}.
                 * @memberof nebulaidl.service.SignalService
                 * @typedef GetOrCreateSignalCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.Signal} [response] Signal
                 */
    
                /**
                 * Calls GetOrCreateSignal.
                 * @function getOrCreateSignal
                 * @memberof nebulaidl.service.SignalService
                 * @instance
                 * @param {nebulaidl.admin.ISignalGetOrCreateRequest} request SignalGetOrCreateRequest message or plain object
                 * @param {nebulaidl.service.SignalService.GetOrCreateSignalCallback} callback Node-style callback called with the error, if any, and Signal
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SignalService.prototype.getOrCreateSignal = function getOrCreateSignal(request, callback) {
                    return this.rpcCall(getOrCreateSignal, $root.nebulaidl.admin.SignalGetOrCreateRequest, $root.nebulaidl.admin.Signal, request, callback);
                }, "name", { value: "GetOrCreateSignal" });
    
                /**
                 * Calls GetOrCreateSignal.
                 * @function getOrCreateSignal
                 * @memberof nebulaidl.service.SignalService
                 * @instance
                 * @param {nebulaidl.admin.ISignalGetOrCreateRequest} request SignalGetOrCreateRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.Signal>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.SignalService#listSignals}.
                 * @memberof nebulaidl.service.SignalService
                 * @typedef ListSignalsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.SignalList} [response] SignalList
                 */
    
                /**
                 * Calls ListSignals.
                 * @function listSignals
                 * @memberof nebulaidl.service.SignalService
                 * @instance
                 * @param {nebulaidl.admin.ISignalListRequest} request SignalListRequest message or plain object
                 * @param {nebulaidl.service.SignalService.ListSignalsCallback} callback Node-style callback called with the error, if any, and SignalList
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SignalService.prototype.listSignals = function listSignals(request, callback) {
                    return this.rpcCall(listSignals, $root.nebulaidl.admin.SignalListRequest, $root.nebulaidl.admin.SignalList, request, callback);
                }, "name", { value: "ListSignals" });
    
                /**
                 * Calls ListSignals.
                 * @function listSignals
                 * @memberof nebulaidl.service.SignalService
                 * @instance
                 * @param {nebulaidl.admin.ISignalListRequest} request SignalListRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.SignalList>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link nebulaidl.service.SignalService#setSignal}.
                 * @memberof nebulaidl.service.SignalService
                 * @typedef SetSignalCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {nebulaidl.admin.SignalSetResponse} [response] SignalSetResponse
                 */
    
                /**
                 * Calls SetSignal.
                 * @function setSignal
                 * @memberof nebulaidl.service.SignalService
                 * @instance
                 * @param {nebulaidl.admin.ISignalSetRequest} request SignalSetRequest message or plain object
                 * @param {nebulaidl.service.SignalService.SetSignalCallback} callback Node-style callback called with the error, if any, and SignalSetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SignalService.prototype.setSignal = function setSignal(request, callback) {
                    return this.rpcCall(setSignal, $root.nebulaidl.admin.SignalSetRequest, $root.nebulaidl.admin.SignalSetResponse, request, callback);
                }, "name", { value: "SetSignal" });
    
                /**
                 * Calls SetSignal.
                 * @function setSignal
                 * @memberof nebulaidl.service.SignalService
                 * @instance
                 * @param {nebulaidl.admin.ISignalSetRequest} request SignalSetRequest message or plain object
                 * @returns {Promise<nebulaidl.admin.SignalSetResponse>} Promise
                 * @variation 2
                 */
    
                return SignalService;
            })();
    
            return service;
        })();
    
        return nebulaidl;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Timestamp = (function() {
    
                /**
                 * Properties of a Timestamp.
                 * @memberof google.protobuf
                 * @interface ITimestamp
                 * @property {Long|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */
    
                /**
                 * Constructs a new Timestamp.
                 * @memberof google.protobuf
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Timestamp seconds.
                 * @member {Long} seconds
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;
    
                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 * @returns {google.protobuf.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };
    
                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                return Timestamp;
            })();
    
            protobuf.Duration = (function() {
    
                /**
                 * Properties of a Duration.
                 * @memberof google.protobuf
                 * @interface IDuration
                 * @property {Long|null} [seconds] Duration seconds
                 * @property {number|null} [nanos] Duration nanos
                 */
    
                /**
                 * Constructs a new Duration.
                 * @memberof google.protobuf
                 * @classdesc Represents a Duration.
                 * @implements IDuration
                 * @constructor
                 * @param {google.protobuf.IDuration=} [properties] Properties to set
                 */
                function Duration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Duration seconds.
                 * @member {Long} seconds
                 * @memberof google.protobuf.Duration
                 * @instance
                 */
                Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Duration nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Duration
                 * @instance
                 */
                Duration.prototype.nanos = 0;
    
                /**
                 * Creates a new Duration instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {google.protobuf.IDuration=} [properties] Properties to set
                 * @returns {google.protobuf.Duration} Duration instance
                 */
                Duration.create = function create(properties) {
                    return new Duration(properties);
                };
    
                /**
                 * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {google.protobuf.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Decodes a Duration message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Duration message.
                 * @function verify
                 * @memberof google.protobuf.Duration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Duration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                return Duration;
            })();
    
            protobuf.Struct = (function() {
    
                /**
                 * Properties of a Struct.
                 * @memberof google.protobuf
                 * @interface IStruct
                 * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
                 */
    
                /**
                 * Constructs a new Struct.
                 * @memberof google.protobuf
                 * @classdesc Represents a Struct.
                 * @implements IStruct
                 * @constructor
                 * @param {google.protobuf.IStruct=} [properties] Properties to set
                 */
                function Struct(properties) {
                    this.fields = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Struct fields.
                 * @member {Object.<string,google.protobuf.IValue>} fields
                 * @memberof google.protobuf.Struct
                 * @instance
                 */
                Struct.prototype.fields = $util.emptyObject;
    
                /**
                 * Creates a new Struct instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Struct
                 * @static
                 * @param {google.protobuf.IStruct=} [properties] Properties to set
                 * @returns {google.protobuf.Struct} Struct instance
                 */
                Struct.create = function create(properties) {
                    return new Struct(properties);
                };
    
                /**
                 * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Struct
                 * @static
                 * @param {google.protobuf.IStruct} message Struct message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Struct.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fields != null && message.hasOwnProperty("fields"))
                        for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Decodes a Struct message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Struct
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Struct} Struct
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Struct.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.fields === $util.emptyObject)
                                message.fields = {};
                            key = reader.string();
                            reader.pos++;
                            message.fields[key] = $root.google.protobuf.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Struct message.
                 * @function verify
                 * @memberof google.protobuf.Struct
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Struct.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        if (!$util.isObject(message.fields))
                            return "fields: object expected";
                        var key = Object.keys(message.fields);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                            if (error)
                                return "fields." + error;
                        }
                    }
                    return null;
                };
    
                return Struct;
            })();
    
            protobuf.Value = (function() {
    
                /**
                 * Properties of a Value.
                 * @memberof google.protobuf
                 * @interface IValue
                 * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
                 * @property {number|null} [numberValue] Value numberValue
                 * @property {string|null} [stringValue] Value stringValue
                 * @property {boolean|null} [boolValue] Value boolValue
                 * @property {google.protobuf.IStruct|null} [structValue] Value structValue
                 * @property {google.protobuf.IListValue|null} [listValue] Value listValue
                 */
    
                /**
                 * Constructs a new Value.
                 * @memberof google.protobuf
                 * @classdesc Represents a Value.
                 * @implements IValue
                 * @constructor
                 * @param {google.protobuf.IValue=} [properties] Properties to set
                 */
                function Value(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Value nullValue.
                 * @member {google.protobuf.NullValue} nullValue
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Value.prototype.nullValue = 0;
    
                /**
                 * Value numberValue.
                 * @member {number} numberValue
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Value.prototype.numberValue = 0;
    
                /**
                 * Value stringValue.
                 * @member {string} stringValue
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Value.prototype.stringValue = "";
    
                /**
                 * Value boolValue.
                 * @member {boolean} boolValue
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Value.prototype.boolValue = false;
    
                /**
                 * Value structValue.
                 * @member {google.protobuf.IStruct|null|undefined} structValue
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Value.prototype.structValue = null;
    
                /**
                 * Value listValue.
                 * @member {google.protobuf.IListValue|null|undefined} listValue
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Value.prototype.listValue = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Value kind.
                 * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
                 * @memberof google.protobuf.Value
                 * @instance
                 */
                Object.defineProperty(Value.prototype, "kind", {
                    get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Value instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Value
                 * @static
                 * @param {google.protobuf.IValue=} [properties] Properties to set
                 * @returns {google.protobuf.Value} Value instance
                 */
                Value.create = function create(properties) {
                    return new Value(properties);
                };
    
                /**
                 * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Value
                 * @static
                 * @param {google.protobuf.IValue} message Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Value.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nullValue != null && message.hasOwnProperty("nullValue"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                    if (message.numberValue != null && message.hasOwnProperty("numberValue"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                    if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                    if (message.structValue != null && message.hasOwnProperty("structValue"))
                        $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.listValue != null && message.hasOwnProperty("listValue"))
                        $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Value message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Value} Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Value.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nullValue = reader.int32();
                            break;
                        case 2:
                            message.numberValue = reader.double();
                            break;
                        case 3:
                            message.stringValue = reader.string();
                            break;
                        case 4:
                            message.boolValue = reader.bool();
                            break;
                        case 5:
                            message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Value message.
                 * @function verify
                 * @memberof google.protobuf.Value
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Value.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                        properties.kind = 1;
                        switch (message.nullValue) {
                        default:
                            return "nullValue: enum value expected";
                        case 0:
                            break;
                        }
                    }
                    if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (typeof message.numberValue !== "number")
                            return "numberValue: number expected";
                    }
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (typeof message.boolValue !== "boolean")
                            return "boolValue: boolean expected";
                    }
                    if (message.structValue != null && message.hasOwnProperty("structValue")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        {
                            var error = $root.google.protobuf.Struct.verify(message.structValue);
                            if (error)
                                return "structValue." + error;
                        }
                    }
                    if (message.listValue != null && message.hasOwnProperty("listValue")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        {
                            var error = $root.google.protobuf.ListValue.verify(message.listValue);
                            if (error)
                                return "listValue." + error;
                        }
                    }
                    return null;
                };
    
                return Value;
            })();
    
            /**
             * NullValue enum.
             * @name google.protobuf.NullValue
             * @enum {string}
             * @property {number} NULL_VALUE=0 NULL_VALUE value
             */
            protobuf.NullValue = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NULL_VALUE"] = 0;
                return values;
            })();
    
            protobuf.ListValue = (function() {
    
                /**
                 * Properties of a ListValue.
                 * @memberof google.protobuf
                 * @interface IListValue
                 * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
                 */
    
                /**
                 * Constructs a new ListValue.
                 * @memberof google.protobuf
                 * @classdesc Represents a ListValue.
                 * @implements IListValue
                 * @constructor
                 * @param {google.protobuf.IListValue=} [properties] Properties to set
                 */
                function ListValue(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ListValue values.
                 * @member {Array.<google.protobuf.IValue>} values
                 * @memberof google.protobuf.ListValue
                 * @instance
                 */
                ListValue.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new ListValue instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ListValue
                 * @static
                 * @param {google.protobuf.IListValue=} [properties] Properties to set
                 * @returns {google.protobuf.ListValue} ListValue instance
                 */
                ListValue.create = function create(properties) {
                    return new ListValue(properties);
                };
    
                /**
                 * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ListValue
                 * @static
                 * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ListValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ListValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ListValue} ListValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ListValue message.
                 * @function verify
                 * @memberof google.protobuf.ListValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i) {
                            var error = $root.google.protobuf.Value.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };
    
                return ListValue;
            })();
    
            protobuf.DoubleValue = (function() {
    
                /**
                 * Properties of a DoubleValue.
                 * @memberof google.protobuf
                 * @interface IDoubleValue
                 * @property {number|null} [value] DoubleValue value
                 */
    
                /**
                 * Constructs a new DoubleValue.
                 * @memberof google.protobuf
                 * @classdesc Represents a DoubleValue.
                 * @implements IDoubleValue
                 * @constructor
                 * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
                 */
                function DoubleValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DoubleValue value.
                 * @member {number} value
                 * @memberof google.protobuf.DoubleValue
                 * @instance
                 */
                DoubleValue.prototype.value = 0;
    
                /**
                 * Creates a new DoubleValue instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DoubleValue
                 * @static
                 * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
                 * @returns {google.protobuf.DoubleValue} DoubleValue instance
                 */
                DoubleValue.create = function create(properties) {
                    return new DoubleValue(properties);
                };
    
                /**
                 * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DoubleValue
                 * @static
                 * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a DoubleValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DoubleValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DoubleValue} DoubleValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DoubleValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DoubleValue message.
                 * @function verify
                 * @memberof google.protobuf.DoubleValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DoubleValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };
    
                return DoubleValue;
            })();
    
            protobuf.FloatValue = (function() {
    
                /**
                 * Properties of a FloatValue.
                 * @memberof google.protobuf
                 * @interface IFloatValue
                 * @property {number|null} [value] FloatValue value
                 */
    
                /**
                 * Constructs a new FloatValue.
                 * @memberof google.protobuf
                 * @classdesc Represents a FloatValue.
                 * @implements IFloatValue
                 * @constructor
                 * @param {google.protobuf.IFloatValue=} [properties] Properties to set
                 */
                function FloatValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FloatValue value.
                 * @member {number} value
                 * @memberof google.protobuf.FloatValue
                 * @instance
                 */
                FloatValue.prototype.value = 0;
    
                /**
                 * Creates a new FloatValue instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FloatValue
                 * @static
                 * @param {google.protobuf.IFloatValue=} [properties] Properties to set
                 * @returns {google.protobuf.FloatValue} FloatValue instance
                 */
                FloatValue.create = function create(properties) {
                    return new FloatValue(properties);
                };
    
                /**
                 * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FloatValue
                 * @static
                 * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FloatValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a FloatValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FloatValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FloatValue} FloatValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FloatValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FloatValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FloatValue message.
                 * @function verify
                 * @memberof google.protobuf.FloatValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FloatValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };
    
                return FloatValue;
            })();
    
            protobuf.Int64Value = (function() {
    
                /**
                 * Properties of an Int64Value.
                 * @memberof google.protobuf
                 * @interface IInt64Value
                 * @property {Long|null} [value] Int64Value value
                 */
    
                /**
                 * Constructs a new Int64Value.
                 * @memberof google.protobuf
                 * @classdesc Represents an Int64Value.
                 * @implements IInt64Value
                 * @constructor
                 * @param {google.protobuf.IInt64Value=} [properties] Properties to set
                 */
                function Int64Value(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int64Value value.
                 * @member {Long} value
                 * @memberof google.protobuf.Int64Value
                 * @instance
                 */
                Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Creates a new Int64Value instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Int64Value
                 * @static
                 * @param {google.protobuf.IInt64Value=} [properties] Properties to set
                 * @returns {google.protobuf.Int64Value} Int64Value instance
                 */
                Int64Value.create = function create(properties) {
                    return new Int64Value(properties);
                };
    
                /**
                 * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Int64Value
                 * @static
                 * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64Value.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                    return writer;
                };
    
                /**
                 * Decodes an Int64Value message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Int64Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Int64Value} Int64Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64Value.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int64Value();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Int64Value message.
                 * @function verify
                 * @memberof google.protobuf.Int64Value
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int64Value.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                            return "value: integer|Long expected";
                    return null;
                };
    
                return Int64Value;
            })();
    
            protobuf.UInt64Value = (function() {
    
                /**
                 * Properties of a UInt64Value.
                 * @memberof google.protobuf
                 * @interface IUInt64Value
                 * @property {Long|null} [value] UInt64Value value
                 */
    
                /**
                 * Constructs a new UInt64Value.
                 * @memberof google.protobuf
                 * @classdesc Represents a UInt64Value.
                 * @implements IUInt64Value
                 * @constructor
                 * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
                 */
                function UInt64Value(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UInt64Value value.
                 * @member {Long} value
                 * @memberof google.protobuf.UInt64Value
                 * @instance
                 */
                UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new UInt64Value instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UInt64Value
                 * @static
                 * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
                 * @returns {google.protobuf.UInt64Value} UInt64Value instance
                 */
                UInt64Value.create = function create(properties) {
                    return new UInt64Value(properties);
                };
    
                /**
                 * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UInt64Value
                 * @static
                 * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UInt64Value.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a UInt64Value message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UInt64Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UInt64Value} UInt64Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UInt64Value.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt64Value();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a UInt64Value message.
                 * @function verify
                 * @memberof google.protobuf.UInt64Value
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UInt64Value.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                            return "value: integer|Long expected";
                    return null;
                };
    
                return UInt64Value;
            })();
    
            protobuf.Int32Value = (function() {
    
                /**
                 * Properties of an Int32Value.
                 * @memberof google.protobuf
                 * @interface IInt32Value
                 * @property {number|null} [value] Int32Value value
                 */
    
                /**
                 * Constructs a new Int32Value.
                 * @memberof google.protobuf
                 * @classdesc Represents an Int32Value.
                 * @implements IInt32Value
                 * @constructor
                 * @param {google.protobuf.IInt32Value=} [properties] Properties to set
                 */
                function Int32Value(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int32Value value.
                 * @member {number} value
                 * @memberof google.protobuf.Int32Value
                 * @instance
                 */
                Int32Value.prototype.value = 0;
    
                /**
                 * Creates a new Int32Value instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Int32Value
                 * @static
                 * @param {google.protobuf.IInt32Value=} [properties] Properties to set
                 * @returns {google.protobuf.Int32Value} Int32Value instance
                 */
                Int32Value.create = function create(properties) {
                    return new Int32Value(properties);
                };
    
                /**
                 * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Int32Value
                 * @static
                 * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int32Value.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                    return writer;
                };
    
                /**
                 * Decodes an Int32Value message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Int32Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Int32Value} Int32Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int32Value.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int32Value();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an Int32Value message.
                 * @function verify
                 * @memberof google.protobuf.Int32Value
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int32Value.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value))
                            return "value: integer expected";
                    return null;
                };
    
                return Int32Value;
            })();
    
            protobuf.UInt32Value = (function() {
    
                /**
                 * Properties of a UInt32Value.
                 * @memberof google.protobuf
                 * @interface IUInt32Value
                 * @property {number|null} [value] UInt32Value value
                 */
    
                /**
                 * Constructs a new UInt32Value.
                 * @memberof google.protobuf
                 * @classdesc Represents a UInt32Value.
                 * @implements IUInt32Value
                 * @constructor
                 * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
                 */
                function UInt32Value(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UInt32Value value.
                 * @member {number} value
                 * @memberof google.protobuf.UInt32Value
                 * @instance
                 */
                UInt32Value.prototype.value = 0;
    
                /**
                 * Creates a new UInt32Value instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UInt32Value
                 * @static
                 * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
                 * @returns {google.protobuf.UInt32Value} UInt32Value instance
                 */
                UInt32Value.create = function create(properties) {
                    return new UInt32Value(properties);
                };
    
                /**
                 * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UInt32Value
                 * @static
                 * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UInt32Value.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a UInt32Value message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UInt32Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UInt32Value} UInt32Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UInt32Value.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt32Value();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a UInt32Value message.
                 * @function verify
                 * @memberof google.protobuf.UInt32Value
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UInt32Value.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value))
                            return "value: integer expected";
                    return null;
                };
    
                return UInt32Value;
            })();
    
            protobuf.BoolValue = (function() {
    
                /**
                 * Properties of a BoolValue.
                 * @memberof google.protobuf
                 * @interface IBoolValue
                 * @property {boolean|null} [value] BoolValue value
                 */
    
                /**
                 * Constructs a new BoolValue.
                 * @memberof google.protobuf
                 * @classdesc Represents a BoolValue.
                 * @implements IBoolValue
                 * @constructor
                 * @param {google.protobuf.IBoolValue=} [properties] Properties to set
                 */
                function BoolValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BoolValue value.
                 * @member {boolean} value
                 * @memberof google.protobuf.BoolValue
                 * @instance
                 */
                BoolValue.prototype.value = false;
    
                /**
                 * Creates a new BoolValue instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.BoolValue
                 * @static
                 * @param {google.protobuf.IBoolValue=} [properties] Properties to set
                 * @returns {google.protobuf.BoolValue} BoolValue instance
                 */
                BoolValue.create = function create(properties) {
                    return new BoolValue(properties);
                };
    
                /**
                 * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.BoolValue
                 * @static
                 * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoolValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a BoolValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.BoolValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.BoolValue} BoolValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoolValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BoolValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BoolValue message.
                 * @function verify
                 * @memberof google.protobuf.BoolValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoolValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                return BoolValue;
            })();
    
            protobuf.StringValue = (function() {
    
                /**
                 * Properties of a StringValue.
                 * @memberof google.protobuf
                 * @interface IStringValue
                 * @property {string|null} [value] StringValue value
                 */
    
                /**
                 * Constructs a new StringValue.
                 * @memberof google.protobuf
                 * @classdesc Represents a StringValue.
                 * @implements IStringValue
                 * @constructor
                 * @param {google.protobuf.IStringValue=} [properties] Properties to set
                 */
                function StringValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StringValue value.
                 * @member {string} value
                 * @memberof google.protobuf.StringValue
                 * @instance
                 */
                StringValue.prototype.value = "";
    
                /**
                 * Creates a new StringValue instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.StringValue
                 * @static
                 * @param {google.protobuf.IStringValue=} [properties] Properties to set
                 * @returns {google.protobuf.StringValue} StringValue instance
                 */
                StringValue.create = function create(properties) {
                    return new StringValue(properties);
                };
    
                /**
                 * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.StringValue
                 * @static
                 * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a StringValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.StringValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.StringValue} StringValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.StringValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a StringValue message.
                 * @function verify
                 * @memberof google.protobuf.StringValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
    
                return StringValue;
            })();
    
            protobuf.BytesValue = (function() {
    
                /**
                 * Properties of a BytesValue.
                 * @memberof google.protobuf
                 * @interface IBytesValue
                 * @property {Uint8Array|null} [value] BytesValue value
                 */
    
                /**
                 * Constructs a new BytesValue.
                 * @memberof google.protobuf
                 * @classdesc Represents a BytesValue.
                 * @implements IBytesValue
                 * @constructor
                 * @param {google.protobuf.IBytesValue=} [properties] Properties to set
                 */
                function BytesValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BytesValue value.
                 * @member {Uint8Array} value
                 * @memberof google.protobuf.BytesValue
                 * @instance
                 */
                BytesValue.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new BytesValue instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.BytesValue
                 * @static
                 * @param {google.protobuf.IBytesValue=} [properties] Properties to set
                 * @returns {google.protobuf.BytesValue} BytesValue instance
                 */
                BytesValue.create = function create(properties) {
                    return new BytesValue(properties);
                };
    
                /**
                 * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.BytesValue
                 * @static
                 * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BytesValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Decodes a BytesValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.BytesValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.BytesValue} BytesValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BytesValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BytesValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a BytesValue message.
                 * @function verify
                 * @memberof google.protobuf.BytesValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BytesValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                return BytesValue;
            })();
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
                 * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
                 * @property {string|null} [syntax] FileDescriptorProto syntax
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.publicDependency = [];
                    this.weakDependency = [];
                    this.messageType = [];
                    this.enumType = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto publicDependency.
                 * @member {Array.<number>} publicDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto weakDependency.
                 * @member {Array.<number>} weakDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto messageType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} messageType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.messageType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto sourceCodeInfo.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.sourceCodeInfo = null;
    
                /**
                 * FileDescriptorProto syntax.
                 * @member {string} syntax
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.syntax = "";
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.messageType != null && message.messageType.length)
                        for (var i = 0; i < message.messageType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.publicDependency != null && message.publicDependency.length)
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                    if (message.weakDependency != null && message.weakDependency.length)
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                    return writer;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 10:
                            if (!(message.publicDependency && message.publicDependency.length))
                                message.publicDependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.publicDependency.push(reader.int32());
                            } else
                                message.publicDependency.push(reader.int32());
                            break;
                        case 11:
                            if (!(message.weakDependency && message.weakDependency.length))
                                message.weakDependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weakDependency.push(reader.int32());
                            } else
                                message.weakDependency.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.messageType && message.messageType.length))
                                message.messageType = [];
                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.syntax = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                        if (!Array.isArray(message.publicDependency))
                            return "publicDependency: array expected";
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            if (!$util.isInteger(message.publicDependency[i]))
                                return "publicDependency: integer[] expected";
                    }
                    if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                        if (!Array.isArray(message.weakDependency))
                            return "weakDependency: array expected";
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            if (!$util.isInteger(message.weakDependency[i]))
                                return "weakDependency: integer[] expected";
                    }
                    if (message.messageType != null && message.hasOwnProperty("messageType")) {
                        if (!Array.isArray(message.messageType))
                            return "messageType: array expected";
                        for (var i = 0; i < message.messageType.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                            if (error)
                                return "messageType." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (!Array.isArray(message.enumType))
                            return "enumType: array expected";
                        for (var i = 0; i < message.enumType.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                        if (error)
                            return "sourceCodeInfo." + error;
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        if (!$util.isString(message.syntax))
                            return "syntax: string expected";
                    return null;
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
                 * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nestedType = [];
                    this.enumType = [];
                    this.extensionRange = [];
                    this.oneofDecl = [];
                    this.reservedRange = [];
                    this.reservedName = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nestedType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nestedType = $util.emptyArray;
    
                /**
                 * DescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * DescriptorProto extensionRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extensionRange = $util.emptyArray;
    
                /**
                 * DescriptorProto oneofDecl.
                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.oneofDecl = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * DescriptorProto reservedRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedRange = $util.emptyArray;
    
                /**
                 * DescriptorProto reservedName.
                 * @member {Array.<string>} reservedName
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedName = $util.emptyArray;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nestedType != null && message.nestedType.length)
                        for (var i = 0; i < message.nestedType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extensionRange != null && message.extensionRange.length)
                        for (var i = 0; i < message.extensionRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.oneofDecl != null && message.oneofDecl.length)
                        for (var i = 0; i < message.oneofDecl.length; ++i)
                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.reservedRange != null && message.reservedRange.length)
                        for (var i = 0; i < message.reservedRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reservedName != null && message.reservedName.length)
                        for (var i = 0; i < message.reservedName.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                    return writer;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nestedType && message.nestedType.length))
                                message.nestedType = [];
                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extensionRange && message.extensionRange.length))
                                message.extensionRange = [];
                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.oneofDecl && message.oneofDecl.length))
                                message.oneofDecl = [];
                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                        if (!Array.isArray(message.nestedType))
                            return "nestedType: array expected";
                        for (var i = 0; i < message.nestedType.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                            if (error)
                                return "nestedType." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (!Array.isArray(message.enumType))
                            return "enumType: array expected";
                        for (var i = 0; i < message.enumType.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                        if (!Array.isArray(message.extensionRange))
                            return "extensionRange: array expected";
                        for (var i = 0; i < message.extensionRange.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                            if (error)
                                return "extensionRange." + error;
                        }
                    }
                    if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                        if (!Array.isArray(message.oneofDecl))
                            return "oneofDecl: array expected";
                        for (var i = 0; i < message.oneofDecl.length; ++i) {
                            var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                            if (error)
                                return "oneofDecl." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                        if (!Array.isArray(message.reservedRange))
                            return "reservedRange: array expected";
                        for (var i = 0; i < message.reservedRange.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                            if (error)
                                return "reservedRange." + error;
                        }
                    }
                    if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                        if (!Array.isArray(message.reservedName))
                            return "reservedName: array expected";
                        for (var i = 0; i < message.reservedName.length; ++i)
                            if (!$util.isString(message.reservedName[i]))
                                return "reservedName: string[] expected";
                    }
                    return null;
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && message.hasOwnProperty("start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && message.hasOwnProperty("end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    return ExtensionRange;
                })();
    
                DescriptorProto.ReservedRange = (function() {
    
                    /**
                     * Properties of a ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IReservedRange
                     * @property {number|null} [start] ReservedRange start
                     * @property {number|null} [end] ReservedRange end
                     */
    
                    /**
                     * Constructs a new ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents a ReservedRange.
                     * @implements IReservedRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     */
                    function ReservedRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ReservedRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.start = 0;
    
                    /**
                     * ReservedRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.end = 0;
    
                    /**
                     * Creates a new ReservedRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                     */
                    ReservedRange.create = function create(properties) {
                        return new ReservedRange(properties);
                    };
    
                    /**
                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && message.hasOwnProperty("start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && message.hasOwnProperty("end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ReservedRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ReservedRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    return ReservedRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [typeName] FieldDescriptorProto typeName
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
                 * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
                 * @property {string|null} [jsonName] FieldDescriptorProto jsonName
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto typeName.
                 * @member {string} typeName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.typeName = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto defaultValue.
                 * @member {string} defaultValue
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.defaultValue = "";
    
                /**
                 * FieldDescriptorProto oneofIndex.
                 * @member {number} oneofIndex
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.oneofIndex = 0;
    
                /**
                 * FieldDescriptorProto jsonName.
                 * @member {string} jsonName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.jsonName = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && message.hasOwnProperty("number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.typeName != null && message.hasOwnProperty("typeName"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                    if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                    return writer;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.typeName = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.defaultValue = reader.string();
                            break;
                        case 9:
                            message.oneofIndex = reader.int32();
                            break;
                        case 10:
                            message.jsonName = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.typeName != null && message.hasOwnProperty("typeName"))
                        if (!$util.isString(message.typeName))
                            return "typeName: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        if (!$util.isString(message.defaultValue))
                            return "defaultValue: string expected";
                    if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                        if (!$util.isInteger(message.oneofIndex))
                            return "oneofIndex: integer expected";
                    if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                        if (!$util.isString(message.jsonName))
                            return "jsonName: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {string}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {string}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.OneofDescriptorProto = (function() {
    
                /**
                 * Properties of an OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IOneofDescriptorProto
                 * @property {string|null} [name] OneofDescriptorProto name
                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
                 */
    
                /**
                 * Constructs a new OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofDescriptorProto.
                 * @implements IOneofDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 */
                function OneofDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.name = "";
    
                /**
                 * OneofDescriptorProto options.
                 * @member {google.protobuf.IOneofOptions|null|undefined} options
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new OneofDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
                 */
                OneofDescriptorProto.create = function create(properties) {
                    return new OneofDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an OneofDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.OneofOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                return OneofDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && message.hasOwnProperty("number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [inputType] MethodDescriptorProto inputType
                 * @property {string|null} [outputType] MethodDescriptorProto outputType
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
                 * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto inputType.
                 * @member {string} inputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.inputType = "";
    
                /**
                 * MethodDescriptorProto outputType.
                 * @member {string} outputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.outputType = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * MethodDescriptorProto clientStreaming.
                 * @member {boolean} clientStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.clientStreaming = false;
    
                /**
                 * MethodDescriptorProto serverStreaming.
                 * @member {boolean} serverStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.serverStreaming = false;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.inputType != null && message.hasOwnProperty("inputType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                    if (message.outputType != null && message.hasOwnProperty("outputType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                    if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                    return writer;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.inputType = reader.string();
                            break;
                        case 3:
                            message.outputType = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.clientStreaming = reader.bool();
                            break;
                        case 6:
                            message.serverStreaming = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.inputType != null && message.hasOwnProperty("inputType"))
                        if (!$util.isString(message.inputType))
                            return "inputType: string expected";
                    if (message.outputType != null && message.hasOwnProperty("outputType"))
                        if (!$util.isString(message.outputType))
                            return "outputType: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                        if (typeof message.clientStreaming !== "boolean")
                            return "clientStreaming: boolean expected";
                    if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                        if (typeof message.serverStreaming !== "boolean")
                            return "serverStreaming: boolean expected";
                    return null;
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [javaPackage] FileOptions javaPackage
                 * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
                 * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
                 * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
                 * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
                 * @property {string|null} [goPackage] FileOptions goPackage
                 * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
                 * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
                 * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
                 * @property {boolean|null} [deprecated] FileOptions deprecated
                 * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
                 * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
                 * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions javaPackage.
                 * @member {string} javaPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaPackage = "";
    
                /**
                 * FileOptions javaOuterClassname.
                 * @member {string} javaOuterClassname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaOuterClassname = "";
    
                /**
                 * FileOptions javaMultipleFiles.
                 * @member {boolean} javaMultipleFiles
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaMultipleFiles = false;
    
                /**
                 * FileOptions javaGenerateEqualsAndHash.
                 * @member {boolean} javaGenerateEqualsAndHash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenerateEqualsAndHash = false;
    
                /**
                 * FileOptions javaStringCheckUtf8.
                 * @member {boolean} javaStringCheckUtf8
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaStringCheckUtf8 = false;
    
                /**
                 * FileOptions optimizeFor.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimizeFor = 1;
    
                /**
                 * FileOptions goPackage.
                 * @member {string} goPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.goPackage = "";
    
                /**
                 * FileOptions ccGenericServices.
                 * @member {boolean} ccGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccGenericServices = false;
    
                /**
                 * FileOptions javaGenericServices.
                 * @member {boolean} javaGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenericServices = false;
    
                /**
                 * FileOptions pyGenericServices.
                 * @member {boolean} pyGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.pyGenericServices = false;
    
                /**
                 * FileOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.deprecated = false;
    
                /**
                 * FileOptions ccEnableArenas.
                 * @member {boolean} ccEnableArenas
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccEnableArenas = false;
    
                /**
                 * FileOptions objcClassPrefix.
                 * @member {string} objcClassPrefix
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.objcClassPrefix = "";
    
                /**
                 * FileOptions csharpNamespace.
                 * @member {string} csharpNamespace
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.csharpNamespace = "";
    
                /**
                 * FileOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                    if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                    if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                    if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                    if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                    if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                    if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                    if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                    if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                    if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                    if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                    if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                    if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.javaPackage = reader.string();
                            break;
                        case 8:
                            message.javaOuterClassname = reader.string();
                            break;
                        case 10:
                            message.javaMultipleFiles = reader.bool();
                            break;
                        case 20:
                            message.javaGenerateEqualsAndHash = reader.bool();
                            break;
                        case 27:
                            message.javaStringCheckUtf8 = reader.bool();
                            break;
                        case 9:
                            message.optimizeFor = reader.int32();
                            break;
                        case 11:
                            message.goPackage = reader.string();
                            break;
                        case 16:
                            message.ccGenericServices = reader.bool();
                            break;
                        case 17:
                            message.javaGenericServices = reader.bool();
                            break;
                        case 18:
                            message.pyGenericServices = reader.bool();
                            break;
                        case 23:
                            message.deprecated = reader.bool();
                            break;
                        case 31:
                            message.ccEnableArenas = reader.bool();
                            break;
                        case 36:
                            message.objcClassPrefix = reader.string();
                            break;
                        case 37:
                            message.csharpNamespace = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                        if (!$util.isString(message.javaPackage))
                            return "javaPackage: string expected";
                    if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                        if (!$util.isString(message.javaOuterClassname))
                            return "javaOuterClassname: string expected";
                    if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                        if (typeof message.javaMultipleFiles !== "boolean")
                            return "javaMultipleFiles: boolean expected";
                    if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                        if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                            return "javaGenerateEqualsAndHash: boolean expected";
                    if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                        if (typeof message.javaStringCheckUtf8 !== "boolean")
                            return "javaStringCheckUtf8: boolean expected";
                    if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                        switch (message.optimizeFor) {
                        default:
                            return "optimizeFor: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                        if (!$util.isString(message.goPackage))
                            return "goPackage: string expected";
                    if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                        if (typeof message.ccGenericServices !== "boolean")
                            return "ccGenericServices: boolean expected";
                    if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                        if (typeof message.javaGenericServices !== "boolean")
                            return "javaGenericServices: boolean expected";
                    if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                        if (typeof message.pyGenericServices !== "boolean")
                            return "pyGenericServices: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                        if (typeof message.ccEnableArenas !== "boolean")
                            return "ccEnableArenas: boolean expected";
                    if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                        if (!$util.isString(message.objcClassPrefix))
                            return "objcClassPrefix: string expected";
                    if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                        if (!$util.isString(message.csharpNamespace))
                            return "csharpNamespace: string expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {string}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
                 * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
                 * @property {boolean|null} [deprecated] MessageOptions deprecated
                 * @property {boolean|null} [mapEntry] MessageOptions mapEntry
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions messageSetWireFormat.
                 * @member {boolean} messageSetWireFormat
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.messageSetWireFormat = false;
    
                /**
                 * MessageOptions noStandardDescriptorAccessor.
                 * @member {boolean} noStandardDescriptorAccessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.noStandardDescriptorAccessor = false;
    
                /**
                 * MessageOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.deprecated = false;
    
                /**
                 * MessageOptions mapEntry.
                 * @member {boolean} mapEntry
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.mapEntry = false;
    
                /**
                 * MessageOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                    if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.messageSetWireFormat = reader.bool();
                            break;
                        case 2:
                            message.noStandardDescriptorAccessor = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 7:
                            message.mapEntry = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                        if (typeof message.messageSetWireFormat !== "boolean")
                            return "messageSetWireFormat: boolean expected";
                    if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                        if (typeof message.noStandardDescriptorAccessor !== "boolean")
                            return "noStandardDescriptorAccessor: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                        if (typeof message.mapEntry !== "boolean")
                            return "mapEntry: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
                 * @property {boolean|null} [lazy] FieldOptions lazy
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {boolean|null} [weak] FieldOptions weak
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions jstype.
                 * @member {google.protobuf.FieldOptions.JSType} jstype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.jstype = 0;
    
                /**
                 * FieldOptions lazy.
                 * @member {boolean} lazy
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.lazy = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions weak.
                 * @member {boolean} weak
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.weak = false;
    
                /**
                 * FieldOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 6:
                            message.jstype = reader.int32();
                            break;
                        case 5:
                            message.lazy = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 10:
                            message.weak = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        switch (message.jstype) {
                        default:
                            return "jstype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        if (typeof message.lazy !== "boolean")
                            return "lazy: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        if (typeof message.weak !== "boolean")
                            return "weak: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {string}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                /**
                 * JSType enum.
                 * @name google.protobuf.FieldOptions.JSType
                 * @enum {string}
                 * @property {number} JS_NORMAL=0 JS_NORMAL value
                 * @property {number} JS_STRING=1 JS_STRING value
                 * @property {number} JS_NUMBER=2 JS_NUMBER value
                 */
                FieldOptions.JSType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JS_NORMAL"] = 0;
                    values[valuesById[1] = "JS_STRING"] = 1;
                    values[valuesById[2] = "JS_NUMBER"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.OneofOptions = (function() {
    
                /**
                 * Properties of an OneofOptions.
                 * @memberof google.protobuf
                 * @interface IOneofOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new OneofOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofOptions.
                 * @implements IOneofOptions
                 * @constructor
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 */
                function OneofOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 */
                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new OneofOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 * @returns {google.protobuf.OneofOptions} OneofOptions instance
                 */
                OneofOptions.create = function create(properties) {
                    return new OneofOptions(properties);
                };
    
                /**
                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an OneofOptions message.
                 * @function verify
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                return OneofOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {boolean|null} [allowAlias] EnumOptions allowAlias
                 * @property {boolean|null} [deprecated] EnumOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions allowAlias.
                 * @member {boolean} allowAlias
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.allowAlias = false;
    
                /**
                 * EnumOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.deprecated = false;
    
                /**
                 * EnumOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.allowAlias = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                        if (typeof message.allowAlias !== "boolean")
                            return "allowAlias: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.deprecated = false;
    
                /**
                 * EnumValueOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {boolean|null} [deprecated] ServiceOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.deprecated = false;
    
                /**
                 * ServiceOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {boolean|null} [deprecated] MethodOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
                 * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.deprecated = false;
    
                /**
                 * MethodOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * MethodOptions .google.api.http.
                 * @member {google.api.IHttpRule|null|undefined} .google.api.http
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype[".google.api.http"] = null;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                        $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 72295728:
                            message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                        var error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                        if (error)
                            return ".google.api.http." + error;
                    }
                    return null;
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifierValue] UninterpretedOption identifierValue
                 * @property {Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
                 * @property {Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
                 * @property {number|null} [doubleValue] UninterpretedOption doubleValue
                 * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
                 * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifierValue.
                 * @member {string} identifierValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifierValue = "";
    
                /**
                 * UninterpretedOption positiveIntValue.
                 * @member {Long} positiveIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negativeIntValue.
                 * @member {Long} negativeIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption doubleValue.
                 * @member {number} doubleValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.doubleValue = 0;
    
                /**
                 * UninterpretedOption stringValue.
                 * @member {Uint8Array} stringValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregateValue.
                 * @member {string} aggregateValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregateValue = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                    if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                    if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                    if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                    return writer;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifierValue = reader.string();
                            break;
                        case 4:
                            message.positiveIntValue = reader.uint64();
                            break;
                        case 5:
                            message.negativeIntValue = reader.int64();
                            break;
                        case 6:
                            message.doubleValue = reader.double();
                            break;
                        case 7:
                            message.stringValue = reader.bytes();
                            break;
                        case 8:
                            message.aggregateValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                        if (!$util.isString(message.identifierValue))
                            return "identifierValue: string expected";
                    if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                        if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                            return "positiveIntValue: integer|Long expected";
                    if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                        if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                            return "negativeIntValue: integer|Long expected";
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                        if (typeof message.doubleValue !== "number")
                            return "doubleValue: number expected";
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                            return "stringValue: buffer expected";
                    if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                        if (!$util.isString(message.aggregateValue))
                            return "aggregateValue: string expected";
                    return null;
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} namePart NamePart namePart
                     * @property {boolean} isExtension NamePart isExtension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart namePart.
                     * @member {string} namePart
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.namePart = "";
    
                    /**
                     * NamePart isExtension.
                     * @member {boolean} isExtension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.isExtension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                        return writer;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.namePart = reader.string();
                                break;
                            case 2:
                                message.isExtension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("namePart"))
                            throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                        if (!message.hasOwnProperty("isExtension"))
                            throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.namePart))
                            return "namePart: string expected";
                        if (typeof message.isExtension !== "boolean")
                            return "isExtension: boolean expected";
                        return null;
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     * @property {string|null} [leadingComments] Location leadingComments
                     * @property {string|null} [trailingComments] Location trailingComments
                     * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        this.leadingDetachedComments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Location leadingComments.
                     * @member {string} leadingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingComments = "";
    
                    /**
                     * Location trailingComments.
                     * @member {string} trailingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.trailingComments = "";
    
                    /**
                     * Location leadingDetachedComments.
                     * @member {Array.<string>} leadingDetachedComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingDetachedComments = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                        if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                        if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            case 3:
                                message.leadingComments = reader.string();
                                break;
                            case 4:
                                message.trailingComments = reader.string();
                                break;
                            case 6:
                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                    message.leadingDetachedComments = [];
                                message.leadingDetachedComments.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                            if (!$util.isString(message.leadingComments))
                                return "leadingComments: string expected";
                        if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                            if (!$util.isString(message.trailingComments))
                                return "trailingComments: string expected";
                        if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                            if (!Array.isArray(message.leadingDetachedComments))
                                return "leadingDetachedComments: array expected";
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                if (!$util.isString(message.leadingDetachedComments[i]))
                                    return "leadingDetachedComments: string[] expected";
                        }
                        return null;
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            protobuf.GeneratedCodeInfo = (function() {
    
                /**
                 * Properties of a GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @interface IGeneratedCodeInfo
                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
                 */
    
                /**
                 * Constructs a new GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a GeneratedCodeInfo.
                 * @implements IGeneratedCodeInfo
                 * @constructor
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 */
                function GeneratedCodeInfo(properties) {
                    this.annotation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeneratedCodeInfo annotation.
                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 */
                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
    
                /**
                 * Creates a new GeneratedCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
                 */
                GeneratedCodeInfo.create = function create(properties) {
                    return new GeneratedCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotation != null && message.annotation.length)
                        for (var i = 0; i < message.annotation.length; ++i)
                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a GeneratedCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneratedCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.annotation != null && message.hasOwnProperty("annotation")) {
                        if (!Array.isArray(message.annotation))
                            return "annotation: array expected";
                        for (var i = 0; i < message.annotation.length; ++i) {
                            var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                            if (error)
                                return "annotation." + error;
                        }
                    }
                    return null;
                };
    
                GeneratedCodeInfo.Annotation = (function() {
    
                    /**
                     * Properties of an Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @interface IAnnotation
                     * @property {Array.<number>|null} [path] Annotation path
                     * @property {string|null} [sourceFile] Annotation sourceFile
                     * @property {number|null} [begin] Annotation begin
                     * @property {number|null} [end] Annotation end
                     */
    
                    /**
                     * Constructs a new Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @classdesc Represents an Annotation.
                     * @implements IAnnotation
                     * @constructor
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     */
                    function Annotation(properties) {
                        this.path = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Annotation path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.path = $util.emptyArray;
    
                    /**
                     * Annotation sourceFile.
                     * @member {string} sourceFile
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.sourceFile = "";
    
                    /**
                     * Annotation begin.
                     * @member {number} begin
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.begin = 0;
    
                    /**
                     * Annotation end.
                     * @member {number} end
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.end = 0;
    
                    /**
                     * Creates a new Annotation instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                     */
                    Annotation.create = function create(properties) {
                        return new Annotation(properties);
                    };
    
                    /**
                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                        if (message.end != null && message.hasOwnProperty("end"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                message.sourceFile = reader.string();
                                break;
                            case 3:
                                message.begin = reader.int32();
                                break;
                            case 4:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Annotation message.
                     * @function verify
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Annotation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                            if (!$util.isString(message.sourceFile))
                                return "sourceFile: string expected";
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            if (!$util.isInteger(message.begin))
                                return "begin: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    return Annotation;
                })();
    
                return GeneratedCodeInfo;
            })();
    
            return protobuf;
        })();
    
        google.api = (function() {
    
            /**
             * Namespace api.
             * @memberof google
             * @namespace
             */
            var api = {};
    
            api.Http = (function() {
    
                /**
                 * Properties of a Http.
                 * @memberof google.api
                 * @interface IHttp
                 * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
                 */
    
                /**
                 * Constructs a new Http.
                 * @memberof google.api
                 * @classdesc Represents a Http.
                 * @implements IHttp
                 * @constructor
                 * @param {google.api.IHttp=} [properties] Properties to set
                 */
                function Http(properties) {
                    this.rules = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Http rules.
                 * @member {Array.<google.api.IHttpRule>} rules
                 * @memberof google.api.Http
                 * @instance
                 */
                Http.prototype.rules = $util.emptyArray;
    
                /**
                 * Creates a new Http instance using the specified properties.
                 * @function create
                 * @memberof google.api.Http
                 * @static
                 * @param {google.api.IHttp=} [properties] Properties to set
                 * @returns {google.api.Http} Http instance
                 */
                Http.create = function create(properties) {
                    return new Http(properties);
                };
    
                /**
                 * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.Http
                 * @static
                 * @param {google.api.IHttp} message Http message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Http.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rules != null && message.rules.length)
                        for (var i = 0; i < message.rules.length; ++i)
                            $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a Http message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.Http
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.Http} Http
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Http.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.rules && message.rules.length))
                                message.rules = [];
                            message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a Http message.
                 * @function verify
                 * @memberof google.api.Http
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Http.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rules != null && message.hasOwnProperty("rules")) {
                        if (!Array.isArray(message.rules))
                            return "rules: array expected";
                        for (var i = 0; i < message.rules.length; ++i) {
                            var error = $root.google.api.HttpRule.verify(message.rules[i]);
                            if (error)
                                return "rules." + error;
                        }
                    }
                    return null;
                };
    
                return Http;
            })();
    
            api.HttpRule = (function() {
    
                /**
                 * Properties of a HttpRule.
                 * @memberof google.api
                 * @interface IHttpRule
                 * @property {string|null} [get] HttpRule get
                 * @property {string|null} [put] HttpRule put
                 * @property {string|null} [post] HttpRule post
                 * @property {string|null} ["delete"] HttpRule delete
                 * @property {string|null} [patch] HttpRule patch
                 * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
                 * @property {string|null} [selector] HttpRule selector
                 * @property {string|null} [body] HttpRule body
                 * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
                 */
    
                /**
                 * Constructs a new HttpRule.
                 * @memberof google.api
                 * @classdesc Represents a HttpRule.
                 * @implements IHttpRule
                 * @constructor
                 * @param {google.api.IHttpRule=} [properties] Properties to set
                 */
                function HttpRule(properties) {
                    this.additionalBindings = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * HttpRule get.
                 * @member {string} get
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.get = "";
    
                /**
                 * HttpRule put.
                 * @member {string} put
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.put = "";
    
                /**
                 * HttpRule post.
                 * @member {string} post
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.post = "";
    
                /**
                 * HttpRule delete.
                 * @member {string} delete
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype["delete"] = "";
    
                /**
                 * HttpRule patch.
                 * @member {string} patch
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.patch = "";
    
                /**
                 * HttpRule custom.
                 * @member {google.api.ICustomHttpPattern|null|undefined} custom
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.custom = null;
    
                /**
                 * HttpRule selector.
                 * @member {string} selector
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.selector = "";
    
                /**
                 * HttpRule body.
                 * @member {string} body
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.body = "";
    
                /**
                 * HttpRule additionalBindings.
                 * @member {Array.<google.api.IHttpRule>} additionalBindings
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                HttpRule.prototype.additionalBindings = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * HttpRule pattern.
                 * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
                 * @memberof google.api.HttpRule
                 * @instance
                 */
                Object.defineProperty(HttpRule.prototype, "pattern", {
                    get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new HttpRule instance using the specified properties.
                 * @function create
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {google.api.IHttpRule=} [properties] Properties to set
                 * @returns {google.api.HttpRule} HttpRule instance
                 */
                HttpRule.create = function create(properties) {
                    return new HttpRule(properties);
                };
    
                /**
                 * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HttpRule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.selector != null && message.hasOwnProperty("selector"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                    if (message.get != null && message.hasOwnProperty("get"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                    if (message.put != null && message.hasOwnProperty("put"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                    if (message.post != null && message.hasOwnProperty("post"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                    if (message["delete"] != null && message.hasOwnProperty("delete"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                    if (message.patch != null && message.hasOwnProperty("patch"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                    if (message.body != null && message.hasOwnProperty("body"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                    if (message.custom != null && message.hasOwnProperty("custom"))
                        $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.additionalBindings != null && message.additionalBindings.length)
                        for (var i = 0; i < message.additionalBindings.length; ++i)
                            $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a HttpRule message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.HttpRule} HttpRule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HttpRule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.get = reader.string();
                            break;
                        case 3:
                            message.put = reader.string();
                            break;
                        case 4:
                            message.post = reader.string();
                            break;
                        case 5:
                            message["delete"] = reader.string();
                            break;
                        case 6:
                            message.patch = reader.string();
                            break;
                        case 8:
                            message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                            break;
                        case 1:
                            message.selector = reader.string();
                            break;
                        case 7:
                            message.body = reader.string();
                            break;
                        case 11:
                            if (!(message.additionalBindings && message.additionalBindings.length))
                                message.additionalBindings = [];
                            message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a HttpRule message.
                 * @function verify
                 * @memberof google.api.HttpRule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HttpRule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.get != null && message.hasOwnProperty("get")) {
                        properties.pattern = 1;
                        if (!$util.isString(message.get))
                            return "get: string expected";
                    }
                    if (message.put != null && message.hasOwnProperty("put")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message.put))
                            return "put: string expected";
                    }
                    if (message.post != null && message.hasOwnProperty("post")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message.post))
                            return "post: string expected";
                    }
                    if (message["delete"] != null && message.hasOwnProperty("delete")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message["delete"]))
                            return "delete: string expected";
                    }
                    if (message.patch != null && message.hasOwnProperty("patch")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        if (!$util.isString(message.patch))
                            return "patch: string expected";
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        if (properties.pattern === 1)
                            return "pattern: multiple values";
                        properties.pattern = 1;
                        {
                            var error = $root.google.api.CustomHttpPattern.verify(message.custom);
                            if (error)
                                return "custom." + error;
                        }
                    }
                    if (message.selector != null && message.hasOwnProperty("selector"))
                        if (!$util.isString(message.selector))
                            return "selector: string expected";
                    if (message.body != null && message.hasOwnProperty("body"))
                        if (!$util.isString(message.body))
                            return "body: string expected";
                    if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                        if (!Array.isArray(message.additionalBindings))
                            return "additionalBindings: array expected";
                        for (var i = 0; i < message.additionalBindings.length; ++i) {
                            var error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                            if (error)
                                return "additionalBindings." + error;
                        }
                    }
                    return null;
                };
    
                return HttpRule;
            })();
    
            api.CustomHttpPattern = (function() {
    
                /**
                 * Properties of a CustomHttpPattern.
                 * @memberof google.api
                 * @interface ICustomHttpPattern
                 * @property {string|null} [kind] CustomHttpPattern kind
                 * @property {string|null} [path] CustomHttpPattern path
                 */
    
                /**
                 * Constructs a new CustomHttpPattern.
                 * @memberof google.api
                 * @classdesc Represents a CustomHttpPattern.
                 * @implements ICustomHttpPattern
                 * @constructor
                 * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
                 */
                function CustomHttpPattern(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CustomHttpPattern kind.
                 * @member {string} kind
                 * @memberof google.api.CustomHttpPattern
                 * @instance
                 */
                CustomHttpPattern.prototype.kind = "";
    
                /**
                 * CustomHttpPattern path.
                 * @member {string} path
                 * @memberof google.api.CustomHttpPattern
                 * @instance
                 */
                CustomHttpPattern.prototype.path = "";
    
                /**
                 * Creates a new CustomHttpPattern instance using the specified properties.
                 * @function create
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
                 * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
                 */
                CustomHttpPattern.create = function create(properties) {
                    return new CustomHttpPattern(properties);
                };
    
                /**
                 * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomHttpPattern.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                    if (message.path != null && message.hasOwnProperty("path"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                    return writer;
                };
    
                /**
                 * Decodes a CustomHttpPattern message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.CustomHttpPattern} CustomHttpPattern
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomHttpPattern.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kind = reader.string();
                            break;
                        case 2:
                            message.path = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Verifies a CustomHttpPattern message.
                 * @function verify
                 * @memberof google.api.CustomHttpPattern
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CustomHttpPattern.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        if (!$util.isString(message.kind))
                            return "kind: string expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    return null;
                };
    
                return CustomHttpPattern;
            })();
    
            return api;
        })();
    
        return google;
    })();

    return $root;
});
